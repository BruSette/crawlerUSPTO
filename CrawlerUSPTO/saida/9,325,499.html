<html><head>
<base target="_top"/>
<title>United States Patent: 9325499</title></head>
<!---BUF1=9325499
BUF7=2016
BUF8=79653
BUF9=/1/
BUF51=9
---->
<body bgcolor="#FFFFFF">
<a name="top"></a>
<center>
<img alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" src="/netaicon/PTO/patfthdr.gif"/>
<br/>
<table>
<tbody><tr><td align="center">
<a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
<a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
<a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
</td></tr>
<tr><td align="center">
   <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=701&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=14&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=701&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=15&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=701&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=702&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=15&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

<a href="#bottom"><img alt="[Bottom]" border="0" src="/netaicon/PTO/bottom.gif" valign="middle"/></a>
</td></tr>
   <tr><td align="center">
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D701%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D15%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209325499"><img alt="[
View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9325499&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D701%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D15%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209325499">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09325499&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D701%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D15%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>

   </td></tr>
</tbody></table>
</center>
<table width="100%">
<tbody><tr><td align="left" width="50%"> </td>
<td align="right" valign="bottom" width="50%"><font size="-1">( <strong>701</strong></font> <font size="-2">of</font> <strong><font size="-1">7895</font></strong> <font size="-1">)</font></td></tr></tbody></table>
<hr/>
   <table width="100%">
   <tbody><tr>	<td align="left" width="50%"><b>United States Patent </b></td>
   <td align="right" width="50%"><b>9,325,499</b></td>
   </tr>
     <tr><td align="left" width="50%"><b>
         Juels
,   et al.</b>
     </td>
     <td align="right" width="50%"> <b>
     April 26, 2016
</b></td>
     </tr>
     </tbody></table>
       <hr/>
       <font size="+1">Message encryption and decryption utilizing low-entropy keys
</font><br/>
       <br/><center><b>Abstract</b></center>
       <p> In one embodiment, a first message is obtained and encrypted to produce a
     ciphertext. The first message is encrypted such that decryption of the
     ciphertext utilizing a first key yields the first message, and decryption
     of the ciphertext utilizing a second key different than the first key
     yields a second message that is distinct from the first message but
     shares one or more designated characteristics with the first message.
     Encrypting the first message may more particularly comprise mapping the
     first key to a first seed, mapping the first message to a second seed,
     determining an offset between the first and second seeds, and generating
     the ciphertext based on the determined offset. Such an arrangement
     prevents an attacker from determining solely from the second message if
     decryption of the ciphertext has been successful or unsuccessful. Other
     embodiments include decryption methods, apparatus for encryption and
     decryption, and associated articles of manufacture.
</p>
       <hr/>
<table width="100%"> <tbody><tr> <th align="left" scope="row" valign="top" width="10%">Inventors:</th> <td align="left" width="90%">
 <b>Juels; Ari</b> (Brookline, MA)<b>, Bowers; Kevin D.</b> (Melrose, MA) </td> </tr>
<tr><th align="left" scope="row" valign="top" width="10%">Applicant: </th><td align="left" width="90%"> <table> <tbody><tr> <th align="center" scope="column">Name</th> <th align="center" scope="column">City</th> <th align="center" scope="column">State</th> <th align="center" scope="column">Country</th> <th align="center" scope="column">Type</th> </tr> <tr> <td> <b><br/>EMC Corporation</b> </td><td> <br/>Hopkinton </td><td align="center"> <br/>MA </td><td align="center"> <br/>US </td> <td align="left"> </td>
</tr> </tbody></table>
<!-- AANM>
~AANM EMC Corporation
~AACI Hopkinton
~AAST MA
~AACO US
</AANM -->
</td></tr>
<tr> <th align="left" scope="row" valign="top" width="10%">Assignee:</th>
<td align="left" width="90%">

<b>EMC Corporation</b>
 (Hopkinton, 
MA)
<br/>

</td>
</tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Family ID:
       </th><td align="left" width="90%">
       <b>55754808
</b></td></tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Appl. No.:
       </th><td align="left" width="90%">
       <b>14/041,150</b></td></tr>
       <tr><th align="left" scope="row" valign="top" width="10%">Filed:
       </th><td align="left" width="90%">
       <b>September 30, 2013</b></td></tr>
     </tbody></table>
<hr/> <center><b>Related U.S. Patent Documents</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col" width="7%"></th><th scope="col"></th><th scope="col"></th> <th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Application Number</u></b></th><th align="center" scope="col"><b><u>Filing Date</u></b></th><th align="center" scope="col"><b><u>Patent Number</u></b></th><th align="center" scope="col"><b><u>Issue Date</u></b></th></tr><tr><td align="center"> </td><td align="center">61838557</td><td align="center">Jun 24, 2013</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table><td< td=""></td<><td< td=""></td<>     <hr/>
<p> <table width="100%"> <tbody><tr><td align="left" valign="top" width="30%"><b>Current U.S. Class:</b></td> <td align="right" valign="top" width="70%"><b>1/1</b> </td></tr> 
       <tr><td align="left" valign="top" width="30%"><b>Current CPC Class: </b></td>
       <td align="right" valign="top" width="70%">H04L 9/30 (20130101)</td></tr>
         <tr><td align="left" valign="top" width="30%"><b>Current International Class: </b></td>
         <td align="right" valign="top" width="70%">H04L 9/30 (20060101)</td></tr>
     </tbody></table>
</p><hr/><center><b>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=PALL&amp;Query=ref/9325499">[Referenced By]</a></b></center>       <hr/>
       <center><b>U.S. Patent Documents</b></center>
<table width="100%"> <tbody><tr><th scope="col" width="33%"></th> <th scope="col" width="33%"></th> <th scope="col" width="34%"></th></tr> <tr> <td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5206905">5206905</a></td><td align="left">
April 1993</td><td align="left">
Lee</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5894519">5894519</a></td><td align="left">
April 1999</td><td align="left">
Clemot</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6170058">6170058</a></td><td align="left">
January 2001</td><td align="left">
Kausik</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F7328350">7328350</a></td><td align="left">
February 2008</td><td align="left">
Hird</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F8429720">8429720</a></td><td align="left">
April 2013</td><td align="left">
Rajasekaran et al.</td></tr><tr><td align="left">

</td>
</tr> </tbody></table>
<table width="90%">   <tbody><tr><td><align="left"><br/>M Bellare et al., "Format-Preserving Encryption," Selected Areas in Cryptography, Jan. 2009, pp. 295-312. cited by applicant
.<br/>H. Bojinov et al., "Kamouflage: Loss-Resistant Password Management," 15th European Symposium on Research in Computer Security (ESORICS), Lecture Notes in Computer Science (LNCS), Sep. 2010, pp. 286-302, vol. 6345, Athens, Greece. cited by applicant
.<br/>Joseph Bonneau, "Guessing Human-Chosen Secrets," PhD Thesis, University of Cambridge, Technical Report No. 819, May 2012, 163 pages. cited by applicant
.<br/>B.M. Bowen et al., "Automating the Injection of Believable Decoys to Detect Snooping," Third ACM Conference on Wireless Network Security (WiSec), Mar. 2010, pp. 81-86. cited by applicant
.<br/>B.M. Bowen et al., "Baiting Inside Attackers Using Decoy Documents," Fifth International ICST Conference on Security and Privacy in Communication Networks (SecureComm), Sep. 2009, pp. 51-70, vol. 19. cited by applicant
.<br/>R. Canetti et al., "Hardness Amplification of Weakly Verifiable Puzzles," Second International Conference on Theory of Cryptography (TCC), Lecture Notes in Computer Science (LNCS), Feb. 2005, pp. 17-33, vol. 3378. cited by applicant
.<br/>A. Paes De Barros, "RES: Protocol Anomaly Detection IDS--Honeypots," http://seclists.org/focus-ids/2003/Feb/95, Feb. 2003, 2 pages. cited by applicant
.<br/>Yevgeniy Dodis, "On Extractors, Error-Correction and Hiding All Partial Information," IEEE Information Theory Workshop on Theory and Practice in Information-Theoretic Security, Oct. 2005, pp. 74-79, Awaji Island, Japan. cited by applicant
.<br/>Y. Dodis et al., "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data," Advances in Cryptology--Eurocrypt, International Conference on the Theory and Applications of Cryptographic Techniques, Lecture Notes in Computer
Science (LNCS), May 2004, pp. 523-540, vol. 3027, Interlaken, Switzerland. cited by applicant
.<br/>Y. Dodis et al., "Entropic Security and the Encryption of High Entropy Messages," Second Theory of Cryptography Conference (TCC), Lecture Notes in Computer Science (LNCS), Feb. 2005, pp. 556-577, vol. 3378. cited by applicant
.<br/>A. Juels et al., "Honeywords: Making Password-Cracking Detectable," Manuscript (v2.0), people.csail.mit.edu/rivest/honeywords, May 2013, pp. 1-19. cited by applicant
.<br/>A. Juels et al., "A Fuzzy Commitment Scheme," Sixth ACM Conference on Computer and Communications Security (CCS), Nov. 1999, pp. 28-36, Singapore. cited by applicant
.<br/>P.G. Kelley et al., "Guess Again (and Again and Again): Measuring Password Strength by Simulating Password-Cracking Algorithms," IEEE Symposium on Security and Privacy (SP), May 2012, pp. 523-537. cited by applicant
.<br/>David Pogue, "Remember All Those Passwords? No Need," The New York Times, Jun. 5, 2013, 4 pages. cited by applicant
.<br/>A. Russell et al., "How to Fool an Unbounded Adversary with a Short Key," Advances in Cryptology--EUROCRYPT, International Conference on the Theory and Applications of Cryptographic Techniques, Lecture Notes in Computer Science (LNCS), Apr.-May
2002, pp. 133-148, vol. 2332, Amsterdam, The Netherlands. cited by applicant
.<br/>C.E. Shannon, "Communication Theory of Secrecy Systems," Bell System Technical Journal, Oct. 1949, pp. 656-715, vol. 28, No. 4. cited by applicant
.<br/>M.G. Siegler, "One of the 32 Million with a RockYou Account? You May Want to Change All Your Passwords. Like Now." TechCrunch, http://techcrunch.com/2009/12/14/rockyou-hacked/, Dec. 2009, 5 pages. cited by applicant
.<br/>M. Weir et al., "Password Cracking Using Probabilistic Context-Free Grammars," IEEE 30th Symposium on Security and Privacy (SP), May 2009, pp. 391-405. cited by applicant
.<br/>Y. Zhang et al., "The Security of Modern Password Expiration: An Algorithmic Framework and Empirical Analysis," 17th ACM Conference on Computer and Communications Security (CCS), Oct. 2010, pp. 176-186. cited by applicant
.<br/>Q. Zhao et al., "A Comparative Study on Quality Assessment of High Resolution Fingerprint Images," 17th IEEE International Conference on Image Processing (ICIP), Sep. 2010, pp. 3089-3092, Hong Kong, China. cited by applicant
.<br/>T.A. Berson et al., "Secure, Keyed, and Collisionful Hash Functions," Technical Report SRI-CSL-94-08, SRI International Laboratory, 1993 (revised Sep. 1994). cited by applicant. </align="left"></td></tr> </tbody></table><br/><center><b>Other References</b></center> <br/>
       <i>Primary Examiner:</i> Goodchild; William
<br/>
       <i>Assistant Examiner:</i> Nipa; Wasika
<br/>
       <i>Attorney, Agent or Firm:</i> <coma>Ryan, Mason &amp; Lewis, LLP
<br/>
       <hr/>
       <center><b><i>Parent Case Text</i></b></center>
       <hr/>
       <br/><br/>PRIORITY CLAIM
<br/><br/> The present application claims the priority of U.S. Provisional Patent
     Application Ser. No. 61/838,557 filed Jun. 24, 2013, which is
     incorporated by reference herein.
         <hr/>
<center><b><i>Claims</i></b></center> <hr/> <br/><br/>What is claimed is: <br/><br/> 1.  A method comprising: obtaining a first message;  and encrypting the first message to produce a ciphertext;  wherein encrypting the first message comprises mapping a first
key to a first seed, mapping the first message to a second seed, determining an offset between the first and second seeds, and generating the ciphertext based on the determined offset;  wherein the first message is encrypted such that decryption of the
ciphertext utilizing the first key yields the first message and decryption of the ciphertext utilizing a second key different than the first key yields a second message that is distinct from the first message but shares one or more designated
characteristics with the first message in a manner that prevents an attacker from determining solely from the second message if decryption of the ciphertext has been successful or unsuccessful;  and wherein the obtaining and encrypting are performed by
at least one processing device comprising a processor coupled to a memory.
<br/><br/> 2.  The method of claim 1 wherein the first and second keys comprise respective valid and invalid low-entropy keys.
<br/><br/> 3.  The method of claim 1 wherein decryption of the ciphertext utilizing respective ones of a plurality of additional keys different than the first key yields respective additional messages that are distinct from the first message but share
designated characteristics with the first message in a manner that prevents an attacker from determining solely from a given one of the additional messages if decryption of the ciphertext has been successful or unsuccessful, and wherein an increase in a
maximum number of additional messages does not require any increase in a size of the ciphertext.
<br/><br/> 4.  The method of claim 1 wherein the first message comprises a valid password vault comprising a plurality of passwords, the first key comprises a master password of the password vault and the second message comprises an invalid password vault
that is configured to appear valid to an attacker.
<br/><br/> 5.  The method of claim 1 wherein the first message comprises a template utilized to generate multiple invalid password vaults.
<br/><br/> 6.  The method of claim 1 further comprising the steps of: partitioning a password space into multiple equivalence classes such that each equivalence class comprises passwords having a common password syntax;  and generating keys for respective
ones of the equivalence classes;  wherein the ciphertext is generated at least in part utilizing a key generated for a particular one of the equivalence classes.
<br/><br/> 7.  The method of claim 1 wherein the first message comprises a permutation utilized to map passwords to accounts in a password vault, the first key comprises a master password of the password vault and the second message comprises an invalid
permutation that is configured to appear valid to an attacker.
<br/><br/> 8.  The method of claim 1 wherein the first message comprises a key utilized to select a password from a password space.
<br/><br/> 9.  A method comprising: obtaining a first message;  and encrypting the first message to produce a ciphertext;  wherein the ciphertext comprises an offset between a first seed associated with the first message and another seed generated by
applying a key-to-seed mapping to a first key;  wherein the first message is encrypted such that decryption of the ciphertext utilizing the first key yields the first message and decryption of the ciphertext utilizing a second key different than the
first key yields a second message that is distinct from the first message but shares one or more designated characteristics with the first message in a manner that prevents an attacker from determining solely from the second message if decryption of the
ciphertext has been successful or unsuccessful;  and wherein the obtaining and encrypting are performed by at least one processing device comprising a processor coupled to a memory.
<br/><br/> 10.  The method of claim 9 wherein the ciphertext is of the form (.delta.,x) where .delta.= .sup.-1(m)-f.sub.x(.kappa.) denotes the offset, m denotes the first message, .sup.-1(m) denotes a message-to-seed mapping, .kappa.  denotes the first
key, f.sub.x(.kappa.) denotes the key-to-seed mapping and x denotes a supplementary key utilized by the key-to-seed mapping.
<br/><br/> 11.  The method of claim 10 wherein the message-to-seed mapping g.sup.-1(m) is implemented as a function that determines multiple seeds that each map to m and then selects a particular one of the multiple seeds.
<br/><br/> 12.  The method of claim 10 wherein the supplementary key is selected independently from a designated key space for each of a plurality of iterations of said encrypting.
<br/><br/> 13.  The method of claim 10 wherein the key-to-seed mapping comprises at least one of a hash function and a pseudorandom permutation.
<br/><br/> 14.  An article of manufacture comprising a non-transitory processor-readable storage medium having embodied therein one or more software programs, wherein the one or more software programs when executed by at least one processing device cause
said at least one processing device: to obtain a first message;  and to encrypt the first message to produce a ciphertext;  wherein encrypting the first message comprises mapping a first key to a first seed, mapping the first message to a second seed,
determining an offset between the first and second seeds, and generating the ciphertext based on the determined offset;  and wherein the first message is encrypted such that decryption of the ciphertext utilizing the first key yields the first message
and decryption of the ciphertext utilizing a second key different than the first key yields a second message that is distinct from the first message but shares one or more designated characteristics with the first message in a manner that prevents an
attacker from determining solely from the second message if decryption of the ciphertext has been successful or unsuccessful.
<br/><br/> 15.  An apparatus comprising: at least one processing device comprising a processor coupled to a memory;  wherein said at least one processing device is configured to obtain a first message and to encrypt the first message to produce a
ciphertext;  wherein encrypting the first message comprises mapping a first key to a first seed, mapping the first message to a second seed, determining an offset between the first and second seeds, and generating the ciphertext based on the determined
offset;  and wherein the first message is encrypted such that decryption of the ciphertext utilizing the first key yields the first message and decryption of the ciphertext utilizing a second key different than the first key yields a second message that
is distinct from the first message but shares one or more designated characteristics with the first message in a manner that prevents an attacker from determining solely from the second message if decryption of the ciphertext has been successful or
unsuccessful.
<br/><br/> 16.  The apparatus of claim 15 wherein the ciphertext is of the form (.delta.,x) where .delta.= .sup.-1(m)-f.sub.x(.kappa.) denotes the offset, m denotes the first message, .sup.-1(m) denotes a message-to-seed mapping, .kappa.  denotes the first
key, f.sub.x(.kappa.) denotes a key-to-seed mapping and x denotes a supplementary key utilized by the key-to-seed mapping.
<br/><br/> 17.  A method comprising: obtaining a ciphertext;  and decrypting the ciphertext to produce a first message;  wherein the first message results from decrypting the ciphertext using a first key;  wherein decrypting the ciphertext to produce the
first message comprises mapping the first key to a first seed, applying an offset of the ciphertext to the first seed to generate a second seed, and mapping the second seed to the first message;  wherein the ciphertext is configured such that decryption
of the ciphertext utilizing a second key different than the first key yields a second message that is distinct from the first message but shares one or more designated characteristics with the first message in a manner that prevents an attacker from
determining solely from the second message if decryption of the ciphertext has been successful or unsuccessful;  and wherein the obtaining and decrypting are performed by at least one processing device comprising a processor coupled to a memory.
<br/><br/> 18.  The method of claim 17 wherein decrypting the ciphertext to produce the first message comprises computing m=g(f.sub.x(.kappa.)+(.delta.) where m denotes the first message, .delta.  denotes the offset, g denotes a seed-to-message mapping,
.kappa.  denotes the first key, f.sub.x(.kappa.) denotes a key-to-seed mapping and x denotes a supplementary key utilized by the key-to-seed mapping.
<br/><br/> 19.  An article of manufacture comprising a non-transitory processor-readable storage medium having embodied therein one or more software programs, wherein the one or more software programs when executed by at least one processing device cause
said at least one processing device: to obtain a ciphertext;  and to decrypt the ciphertext to produce a first message;  wherein the first message results from decrypting the ciphertext using a first key;  wherein decrypting the ciphertext to produce the
first message comprises mapping the first key to a first seed, applying an offset of the ciphertext to the first seed to generate a second seed, and mapping the second seed to the first message;  and wherein the ciphertext is configured such that
decryption of the ciphertext utilizing a second key different than the first key yields a second message that is distinct from the first message but shares one or more designated characteristics with the first message in a manner that prevents an
attacker from determining solely from the second message if decryption of the ciphertext has been successful or unsuccessful.
<br/><br/> 20.  The article of manufacture of claim 19 wherein decrypting the ciphertext to produce the first message comprises computing m=g(f.sub.x(.kappa.)+.delta.) where m denotes the first message, .delta.  denotes the offset, g denotes a
seed-to-message mapping, .kappa.  denotes the first key, f.sub.x(.kappa.) denotes a key-to-seed mapping and x denotes a supplementary key utilized by the key-to-seed mapping. <hr/> <center><b><i>Description</i></b></center> <hr/> <br/><br/>FIELD
<br/><br/> The field relates generally to cryptography, and more particularly to techniques for encryption and decryption of messages.
<br/><br/>BACKGROUND
<br/><br/> Many real-world systems rely on passwords, biometrics or other low-entropy keys for user authentication.  In the case of passwords, the general user population produces passwords having an average entropy of about 20 bits.  Biometrics also
exhibit similarly low entropy.  For example, even a high-resolution fingerprint reader has a false acceptance rate on the order of 1:1,000,000, implying less than 20 bits of entropy.
<br/><br/> In typical online settings, an authentication server can supplement such low-entropy keys with contextual information to strengthen access-control decisions and can throttle guessing attempts by an adversary.  Thus, low-entropy keys often
provide adequate security in such settings.  However, low-entropy keys are also used to control access to protected resources in offline settings that do not include enhanced protections of the type described above.  For example, such keys may be used in
encryption applications such as encryption of password vaults, documents, signing keys and other types of information.  In the case of a password vault, the vault stores multiple passwords in encrypted form using a master password.  Compromise of the
master password gives the attacker immediate access to multiple valid passwords stored in the vault.  Similar security issues can arise in other encryption contexts.
<br/><br/> Accordingly, a need exists for encryption and decryption techniques that can provide improved security in a variety of different contexts, and particularly when utilizing low-entropy keys.
<br/><br/>SUMMARY
<br/><br/> Illustrative embodiments of the present invention provide techniques for encryption and decryption that exhibit enhanced security relative to conventional arrangements when utilizing passwords and other low-entropy keys.
<br/><br/> In one embodiment, a first message is obtained and encrypted to produce a ciphertext.  The first message is encrypted such that decryption of the ciphertext utilizing a first key yields the first message, and decryption of the ciphertext
utilizing a second key different than the first key yields a second message that is distinct from the first message but shares one or more designated characteristics with the first message.  Encrypting the first message may more particularly comprise
mapping the first key to a first seed, mapping the first message to a second seed, determining an offset between the first and second seeds, and generating the ciphertext based on the determined offset.  Such an arrangement prevents an attacker from
determining solely from the second message if decryption of the ciphertext has been successful or unsuccessful.  Other embodiments include decryption methods, apparatus for encryption and decryption, and associated articles of manufacture.
<br/><br/> The first and second keys may comprise respective valid and invalid low-entropy keys, such as respective valid and invalid passwords.
<br/><br/> Decryption of the ciphertext utilizing respective ones of a plurality of additional keys different than the first key illustratively yields respective additional messages that are distinct from the first message but share designated
characteristics with the first message in a manner that prevents an attacker from determining solely from a given one of the additional messages if decryption of the ciphertext has been successful or unsuccessful.
<br/><br/> Moreover, an increase in a maximum number of such additional messages does not require any increase in a size of the ciphertext.
<br/><br/> The ciphertext in some embodiments comprises an offset between a first seed associated with the first message and another seed generated by applying a key-to-seed mapping to the first key.  For example, the ciphertext may be of the form
(.delta.,x) where .delta.= .sup.-1(m)-f.sub.x(.kappa.) denotes the offset, m denotes the first message, .sup.-1(m) denotes a message-to-seed mapping, f.sub.x(.kappa.) denotes the key-to-seed mapping and x denotes a supplementary key utilized by the
key-to-seed mapping.  Other ciphertext formats may be used in other embodiments.
<br/><br/> One or more embodiments are configured such that the first message comprises a valid password vault comprising a plurality of passwords, the first key comprises a master password of the password vault and the second message comprises an invalid
password vault that is configured to appear valid to an attacker.
<br/><br/> Other embodiments can be configured such that the first message comprises a permutation utilized to map passwords to accounts in a password vault, the first key comprises a master password of the password vault and the second message comprises
an invalid permutation that is configured to appear valid to an attacker.
<br/><br/> In still other embodiments, the first message may comprise, for example, a template utilized to generate multiple invalid password vaults, or a key utilized to select a password from a password space.
<br/><br/> Embodiments of the invention can be implemented in a wide variety of different contexts involving encryption or decryption based on low-entropy keys.  Also, other embodiments can be configured to utilize other types of keys.  Accordingly, while
particularly useful in the context of low-entropy keys, the disclosed techniques can be adapted in a straightforward manner for use with other types of keys. <br/><br/>BRIEF DESCRIPTION OF THE DRAWINGS
<br/><br/> FIG. 1 is a block diagram of a communication system incorporating encryption and decryption functionality using low-entropy keys in an illustrative embodiment of the invention.
<br/><br/> FIGS. 2 and 3 illustrate respective encryption and decryption processes implemented in the communication system of FIG. 1.
<br/><br/> FIG. 4 shows exemplary key-to-seed and seed-to-message mappings in an illustrative embodiment.
<br/><br/>DETAILED DESCRIPTION
<br/><br/> Illustrative embodiments of the present invention will be described herein with reference to exemplary systems and associated processing devices.  It is to be appreciated, however, that the invention is not restricted to use with the particular
illustrative system and device configurations shown.  Accordingly, the term "communication system" as used herein is intended to be broadly construed, so as to encompass, for example, systems comprising only a single processing device, systems in which
multiple processing devices communicate with one another over a network or other connection, and numerous other system types and configurations.
<br/><br/> FIG. 1 shows a communication system 100 that incorporates encryption and decryption functionality using low-entropy keys such as passwords.  The system 100 comprises first and second devices 102-1 and 102-2 that are configured to communicate
with one another over a network 104.
<br/><br/> The first and second devices 102 may comprise user devices such as, for example, mobile telephones, laptop or tablet computers, desktop computers, gaming consoles or other types of user devices as well as various combinations of multiple
distinct devices.  Each such device may be associated with a corresponding user, where "user" as the term is applied herein should be generally construed so as to encompass, for example, a human user or an associated hardware or software entity. 
Numerous alternative arrangements are possible.
<br/><br/> The network 104 may comprise, for example, a global computer network such as the Internet, a wide area network (WAN), a local area network (LAN), a satellite network, a telephone or cable network, a cellular network, a wireless network such as
WiFi or WiMAX, or various portions or combinations of these and other types of networks.
<br/><br/> Each user device is configured to encrypt messages received from message sources to generate ciphertexts that are delivered to ciphertext destinations, and to decrypt ciphertexts received from ciphertext sources to generate messages for delivery
to message destinations.  The messages are also referred to herein as plaintexts, and may comprise any type of data or other information that it may be desirable to encrypt in a given encryption application.  For example, in some embodiments disclosed
herein, a message may comprise a password vault.  A wide variety of other types of messages may be encrypted and decrypted using the techniques disclosed herein.
<br/><br/> The user device 102-1 more particularly comprises message and ciphertext sources 106-1, message and ciphertext destinations 108-1, and an encryption and decryption module 110-1 that operates using at least one low-entropy key.  The user device
102-2 is similarly configured to comprise message and ciphertext sources 106-2, message and ciphertext destinations 108-2, and an encryption and decryption module 110-2 that operates using at least one low-entropy key.  The term "low-entropy key" as used
herein is intended to comprise a key having on the order of 20 bits or less of entropy, although other types of keys may be used in other embodiments.
<br/><br/> The encryption and decryption modules 110 are each configured to implement both encryption and decryption functionality, illustratively utilizing the respective encryption and decryption processes to be described below in conjunction with
respective FIGS. 2 and 3.  However, in other embodiments, a given device may be configured with only encryption functionality, or only decryption functionality.
<br/><br/> Also, the source for a given message to be encrypted does not necessarily reside on the device that encrypts that message, but may instead reside on another device.  Similarly, the source for a given ciphertext to be decrypted does not
necessarily reside on the device that decrypts that ciphertext, but may instead reside on another device.  Thus, for example, the first device 102-1 may serve as a source of ciphertexts to be decrypted by the second device 102-2, and vice versa. 
Similarly, the first device 102-1 may serve as a source of messages to be encrypted by the second device 102-2, and vice versa.
<br/><br/> The first and second devices 102 in the FIG. 1 embodiment are implemented as respective processing devices.  Each such processing device generally comprises at least one processor and an associated memory, and implements one or more functional
modules for controlling certain features of the system 100.
<br/><br/> The first device 102-1 comprises a processor 112-1 coupled to a memory 114-1 and a network interface 116-1.  Similarly, the second device 102-2 comprises a processor 112-2 coupled to a memory 114-2 and a network interface 116-2.
<br/><br/> Each of the processors 112 may comprise a microprocessor, a microcontroller, an application-specific integrated circuit (ASIC), a field-programmable gate array (FPGA) or other type of processing circuitry, as well as portions or combinations of
such circuitry elements.
<br/><br/> Each of the memories 114 may comprise random access memory (RAM), read-only memory (ROM) or other types of memory, in any combination.  The memories 114 and other memories disclosed herein may be viewed as examples of what are more generally
referred to as "processor-readable storage media" storing executable computer program code or other types of software programs.
<br/><br/> Articles of manufacture comprising such processor-readable storage media are considered embodiments of the present invention.  A given such article of manufacture may comprise, for example, a storage device such as a storage disk, a storage
array or an integrated circuit containing memory.  The term "article of manufacture" as used herein should be understood to exclude transitory, propagating signals.
<br/><br/> The network interfaces 116 allow their respective devices 102 to communicate over the network 104 with one another and possibly with other devices not explicitly shown, and may comprise one or more conventional transceivers.
<br/><br/> The encryption and decryption modules 110 of the devices 102 may be implemented at least in part in the form of software that is stored in respective ones of the memories 114 and executed by respective ones of the processors 112.
<br/><br/> It is to be appreciated that the particular set of elements shown in FIG. 1 for providing encryption and decryption functionality is presented by way of example, and in other embodiments additional or alternative elements may be used.  Thus,
another embodiment may include additional networks and additional sets of devices as well as other system components of a type commonly used in conjunction with encryption and decryption functionality.
<br/><br/> Examples of such conventional components and associated cryptographic processes are disclosed in A. J. Menezes et al., Handbook of Applied Cryptography, CRC Press, 1997, which is incorporated by reference herein.
<br/><br/> As mentioned previously, various elements of system 100 such as modules 110 associated with respective first and second devices 102 may be implemented at least in part in the form of software.  Such software is stored and executed utilizing
respective memory and processor elements of at least one processing device.  The system 100 may include additional or alternative processing platforms, as well as numerous distinct processing platforms in any combination, with each such platform
comprising one or more computers, storage devices or other types of processing devices.
<br/><br/> A processing platform utilized in one or more embodiments may include cloud infrastructure comprising virtual machines (VMs) and one or more associated hypervisors.  An example of a commercially available hypervisor platform that may be used to
implement portions of the system 100 is the VMware.RTM.  vSphere.TM.  which may have an associated virtual infrastructure management system such as the VMware.RTM.  vCenter.TM..  The underlying physical machines may comprise one or more distributed
processing platforms that include storage products, such as VNX and Symmetrix VMAX, both commercially available from EMC Corporation of Hopkinton, Mass.  A variety of other storage products may be utilized to implement at least a portion of the system
100.
<br/><br/> In the present embodiment, the modules 110 each implement a simple and efficient process for encrypting messages using low-entropy keys such as passwords.  The encryption process in this embodiment produces a ciphertext which, when decrypted
with any of a number of incorrect keys, yields plausible-looking but invalid messages.  The invalid message may be made to appear plausible, for example, by generating it from a message distribution statistically similar to that of the valid message. 
Consequently, an attacker cannot determine whether a given message obtained by decrypting the ciphertext is a valid message or an invalid message.
<br/><br/> This embodiment is an example of an arrangement in which a first message is encrypted such that decryption of the ciphertext utilizing a first key yields the first message and decryption of the ciphertext utilizing a second key different than
the first key yields a second message that is distinct from the first message.  Moreover, the second message shares one or more designated characteristics with the first message in a manner that prevents an attacker from determining solely from the
second message if decryption of the ciphertext has been successful or unsuccessful.  The one or more designated characteristics shared by the first and second messages may result from drawing the messages from similar distributions, or may be based on
other features, such as similarity in appearance, configuration, format or content.
<br/><br/> An important benefit of this encryption process is that it exhibits storage efficiency, in that the ciphertext size is constant in the number of invalid messages, and little larger in practice than a conventional ciphertext.  Accordingly, the
encryption process requires only constant storage for an essentially arbitrarily large set of invalid messages.  Such storage efficiency is particularly important to ensuring fast synchronization among devices, but also to protecting large messages
(e.g., e-mail archives).
<br/><br/> The encryption process can be used, for example, to protect password vaults, such that an attacker that guesses an incorrect master password still obtains valid-seeming vault contents, and therefore cannot determine the true contents through
offline attack alone.
<br/><br/> Another advantage of the encryption process in this context is that knowledge of the valid message allows a party to detect invalid messages without knowledge of any additional secrets.  For example, a service provider can with high probability
detect the submission of a password resulting from incorrect vault decryption, but need not share any secrets with the user apart from the password itself.
<br/><br/> The encryption process is simple to implement and efficient in terms of both storage and computation, and useful in a wide range of applications.
<br/><br/> In the present embodiment, the encryption process is a symmetric-key encryption process, but other embodiments include public-key variants.
<br/><br/> It is assumed that keys come from a space K, such as K={0,1}.sup.l, for security parameter l, i.e., l-bit strings, or K={0,1}*, i.e., bitstrings of arbitrary length, a possible representation of all passwords.
<br/><br/> The encryption process encrypts plaintexts from a message space M. For simplicity, it is assumed that M is of finite size, although generalization to a message space of infinite size is also possible.  There is a corresponding space of
ciphertexts C.
<br/><br/> In the present embodiment, the encryption is more particularly referred to as honey encryption (HE) and the invalid messages may be referred to as "honeywords," "honeytokens" or more generally "honeymessages." Associated with the encryption
process is a corresponding decryption process.
<br/><br/> This embodiment more particularly configures each of the modules 110 to utilize a pair of encryption and decryption functions (enc.sup.HE,dec.sup.HE): c.rarw.enc.sub..kappa..sup.HE(m) and m.rarw.dec.sub..kappa..sup.HE(c), where message
m.di-elect cons.M.orgate..perp.  and ciphertext c.di-elect cons.C.orgate..perp..  The special symbol .perp.  here indicates an encryption or decryption failure.  These functions are illustrated in more detail in FIGS. 2 and 3, respectively.
<br/><br/> An HE ciphertext may be decrypted not just using a unique correct key .kappa., but any of a variety of different, invalid keys from the key space K. Decryption with an invalid key .kappa.'.noteq..kappa.  outputs a plaintext m'.di-elect cons.M
such that m.noteq.m'.  Thus decryption failures may in some cases yield not the failure symbol .perp., but invalid plaintexts in the form of honeymessages.
<br/><br/> In some embodiments, the message space M comprises the space of bitstrings of some fixed length, although in other embodiments the message space M may assume a more specialized format.
<br/><br/> Additionally, HE may be configured to operate on messages from a specific, probabilistic source, such as messages generated by a population of users interacting with a software application.  A good HE implementation should output honeymessages
that are plausible source messages.  Accordingly, honeymessages should be generated by an algorithm or sampled from a probability distribution that accurately models source messages.  Thus, good functions enc.sup.HE and dec.sup.HE require a good choice
of message-generation function to output plausible messages under incorrect decryption keys.  We denote this function, whose use and construction we detail below, by g.
<br/><br/> For instance, an ordinary user rarely employs the English word "supercalifragilisticexpialidocious" in everyday communications.  An HE process for e-mail messages with a good message-generation function g would rarely output a honeymessage
(e.g., bogus e-mail message) containing this word.  A common word like "super," though, might appear relatively frequently in g's output honeymessages.
<br/><br/> While HE is itself a cryptographic primitive, approximating the distribution of source messages, i.e., crafting g, is often a statistical modeling problem.  HE may thus be viewed as an interface between cryptography and statistical approaches to
creating deceptive data.
<br/><br/> An exemplary construction of the functions (enc.sup.HE,dec.sup.HE) will now be described in greater detail.
<br/><br/> It was noted above that the HE process in the present embodiment relies on a message-generation algorithm g to generate messages pseudorandomly in M. This algorithm takes as input a seed from a space S. Thus it is a function of the form: g(s)=m,
for s.di-elect cons.S and m.di-elect cons.M.  We can also think of g as a function for sampling the message space M given a source of seeds.
<br/><br/> Example 1.  Consider an algorithm g for generation of a living person's age in the United States.  We might let the message space M be the set of values [0,120] and a seed take the form of a value (e.g., probability) s.di-elect cons.(0,1].
<br/><br/> One possible algorithm g(s) maps s uniformly over the range [1,120], i.e., output .left brkt-bot.s.times.121.right brkt-bot..  Of course, ages aren't distributed uniformly in the U.S.  population.  So g isn't a good approximation to the source
probability distribution d. As a refinement, g might draw on the distribution of ages as reported by the U.S.  census.  For example, according to the 2010 U.S.  census, 6.5% of U.S.  inhabitants are aged 30-34.  So g might map some interval of size 0.065
in s uniformly over the integer range [30,34], and other age ranges similarly.
<br/><br/> A good sampling algorithm g generates plausible-looking source messages.  More formally, the property we would like of g(s) for s.di-elect cons..sub.US selected uniformly at random is that it yields a message distribution close to message source
d.
<br/><br/> The exemplary constructions described below assume that the set of seeds S is an algebraic group.  We use `+` to denote the group operation on elements of S. It is also assumed that g is efficiently invertible.  As g may not be a bijection,
however, g.sup.-1(m) may be a set of seeds that map to m, rather than a unique seed s. We thus let .sup.-1(m) denote an efficient algorithm that selects a seed s.di-elect cons..sub.Ug.sup.-1(m), i.e., .sup.-1(m) makes a uniformly random selection.  Other
options can work too, e.g., picking the smallest-valued element from g.sup.-1(m) according to some ordering of M.
<br/><br/> In some cases, simplified HE embodiments are possible in which S=M. The message space M need not always have a convenient algebraic-group representation.
<br/><br/> In the constructions to be described, it may be helpful to consider g as sampling probability distributions, and thus for seeds to include reals in [0,1).  In practice, such reals may be expressed as fixed-precision floating point values.  A
simple additive group then is one with "wraparound" in that from the sum or difference of two such reals, only the mantissa is retained.
<br/><br/> HE also makes use of a key-to-seed mapping function f that maps a symmetric key .kappa.  to a seed s. Intuitively, f may be viewed as a way of "smoothing" the entropy in .kappa.  over the seed space S. The key-to-seed mapping function f takes a
supplementary key x, and thus has the form: f.sub.x(.kappa.).fwdarw.s, for .kappa..di-elect cons.K, x.di-elect cons.{tilde over (K)}, and s.di-elect cons.S.  Here the key space x.di-elect cons.{tilde over (K)} from which the supplementary key x is
selected may be a different key space than that from which the key .kappa.  is selected.  In our constructions, x.di-elect cons..sub.U{tilde over (K)} is selected independently for each encryption operation and appended to the resulting ciphertext,
although other arrangements may be used.
<br/><br/> One possible choice of f is a universal hash function.  Cryptographic alternatives are also convenient.  If seeds are short (e.g., of bit length at most l), then a simple way to construct f.sub.x(.kappa.) is to compute enc.sub.x(.kappa.) where
enc denotes a pseudorandom permutation (PRP), which may be implemented using a block cipher such as AES.  If seeds are long, x can be partitioned into multiple keys, each for a distinct PRP invocation.
<br/><br/> FIG. 2 shows the encryption function enc.sup.HE, more specifically denoted enc.sub..kappa..sup.HE(m).  It takes as inputs message m.di-elect cons.M, key .kappa..di-elect cons.K, and generates as an output ciphertext c=(.delta.,x).  More
particularly, if m.di-elect cons.M and .kappa..di-elect cons.K then x.sup.U.rarw.{tilde over (K)}, .delta..rarw.  .sup.-1(m)-f.sub.x(.kappa.) and (.delta.,x) is output.  Otherwise the failure indicator .perp.  is output.
<br/><br/> In this embodiment, a ciphertext may be viewed not as a string, but as a function c:K.fwdarw.M that maps keys to messages.  This mapping is constructed by composing the key-to-seed mapping f.sub.x with the seed-to-message mapping .
<br/><br/> To ensure correct decryption, it must be the case that c maps .kappa.  to m, i.e., c(.kappa.)=m. The two constituent mappings f.sub.x and , therefore, are likely with high probability to be misaligned, in the sense that
(f.sub.x(.kappa.)).noteq.m.
<br/><br/> To correct this misalignment, ciphertext c includes an offset .delta..  Specifically, .delta.=s-s.sub..kappa., where s.sub..kappa.=f.sub.x(.kappa.), the seed generated by .kappa.  under f.sub.x, and s= .sup.-1(m), a seed for m. The function c,
then is: c(.kappa.')={circumflex over (g)}(f.sub.x(.kappa.')+.delta.).  In the following description, we denote ciphertexts interchangeably by c or (.delta.,x).
<br/><br/> FIG. 3 shows the decryption function dec.sup.HE, more specifically denoted dec.sub..kappa..sup.HE(c).  The function takes as its inputs the ciphertext c=(.delta.,x) and the key .kappa..di-elect cons.K, and generates as its output the message
m.di-elect cons.M.  More particularly, if .kappa..di-elect cons.K, x.di-elect cons.K and .delta..di-elect cons.S, the function outputs g(f.sub.x(.kappa.)+.delta.), and otherwise outputs the failure indicator .perp..
<br/><br/> A ciphertext c=(.delta.,x) is decrypted with key .kappa.' by computing its corresponding seed s.sub..kappa.'=f.sub.x(.kappa.'), applying offset .delta.  to obtain s', and then generating message m'=g(s').
<br/><br/> Observe that g(f.sub.x(.kappa.)+.delta.)=g(s.sub..kappa.+(s-s.sub..kappa.))=g(s)=m. That is, c always decrypts correctly to m with key .kappa..
<br/><br/> Example 2.  Continuing Example 1, suppose that we wish to encrypt the age A=60 of a U.S.  inhabitant under a password .kappa.="Boomer!".
<br/><br/> Recall from Example 1 that a seed is a probability s.di-elect cons.[0,1).  So f maps passwords pseudorandomly into [0,1).  Suppose that f(Boomer!)=0.100.
<br/><br/> In Example 1, g maps a seed s uniformly onto ages in [0,120], i.e., g(s)=s/121.  We might obtain .sup.-1(A)=A/121=0.496.  So .delta.=0.496-0.100=0.396.
<br/><br/> Suppose that seed values in [0,1) are expressed with three-digit precision.  Then if f is well constructed and distributes passwords uniformly over S, for each of the 1000 seeds s.di-elect cons.S, there will be many passwords, even short ones,
that map onto s. So given a ciphertext .delta.  and no knowledge of a user's password, in the view of an adversary every age in [0,120] is a possible plaintext.
<br/><br/> FIG. 4 illustrates decryption of ciphertext c=(.delta.,x) with an HE process to yield corresponding, correct plaintext m. A correct key .kappa.  is mapped to seed s.sub..kappa.  by f.sub.x.  Applying offset .delta.  then yields seed s, which
maps under g to correct plaintext m. Under the same decryption process, an incorrect key .kappa.' yields a different, bogus plaintext message m'.
<br/><br/> Rather than treating g as a message generation function, we may take a complementary view of .sup.-1 as an invertible randomness extractor having g as its inverse.
<br/><br/> An extractor ext(m,I) takes as input a source value m drawn from some probability distribution d, and a short random string I. It outputs a value s.di-elect cons.S, for algebraic group S. The key property of a good extractor is that the output
s=ext(M;I) is close to uniformly distributed over S. An invertible extractor is one for which it is possible to reconstruct m from s and I.
<br/><br/> In the exemplary construction described above, the extractor ext= .sup.-1(m) selects a value uniformly at random from g.sup.-1(m) and thus implicitly uses a supplementary random string I to make this selection.  It should be noted, however, that
it isn't necessary to store I to compute g(s).
<br/><br/> For key .kappa., then, it is possible to treat f.sub.x(.kappa.) as an encryption pad and compute a ciphertext c=(.delta.,x) on m where .delta.=ext(m;I)-f.sub.x(.kappa.) = .sup.-1(m)-f.sub.x(.kappa.).
<br/><br/> Application of pad f.sub.x(.kappa.) may be viewed as a form of information-theoretically secure encryption.  Classical application of pads for encryption over bitstrings uses .sym., i.e., XOR, instead of `-`.  In fact, ext(m;I)-f.sub.x(.kappa.)
may itself be viewed as an invertible extractor with "seed" (I,x,.kappa.).
<br/><br/> Suppose that f.sub.x is collision-free, i.e., f.sub.x(.kappa.).noteq.f.sub.x(.kappa.') for .kappa..noteq..kappa.', and ext is an ideal extractor, i.e., its outputs for source distribution d are uniformly distributed over S. Then we have the
property H.sub..infin.[m|c]=H.sub..infin.[.kappa.], where H.sub..infin.(A)=-log(max.sub.a(pr[A=a])) denotes "guessing entropy." In other words, it is as hard to guess the plaintext m from the ciphertext c as it is to guess the key .kappa..  It should be
noted that ext need not be an ideal or even close-to-ideal extractor.
<br/><br/> As an information-theoretic process, HE in illustrative embodiments relies for security upon statistical concealment of m, rather than computational intractability assumptions.
<br/><br/> Some HE constructions may be configured such that the ciphertext c yields only some outputs in M as honeymessages, but not all.  Placing a bound n on the number of possible plaintexts is helpful when invalid plaintexts serve as honeytokens, but
these honeytokens can't be made implicit.  If n is small enough, a trusted entity can explicitly store and watch for these honeytokens.
<br/><br/> One example of a way to limit the number of honeymessages to some count n is to specify in the ciphertext c a set K={.kappa..sub.0, .  . . , .kappa..sub.n-1} of n possible keys.  The true key .kappa.  is placed in a random position j.di-elect
cons..sub.U.sub.n, i.e., .kappa..sub.j.rarw..kappa..  All other keys in K are selected uniformly at random from K.
<br/><br/> The function dec.sup.HE then outputs .perp.  for any key .kappa.'K.  With this construction, an adversary has probability 1/n of guessing the correct key in K.
<br/><br/> Explicit specification of a key set K in this way requires storage linear in n. A simple optimization can reduce the required storage to constant size.  Let z:K.times..sub.n.fwdarw.K be a pseudorandom function (PRF).  Select a random key
y.di-elect cons.K and let .GAMMA.=.kappa.-z.sub.y(i).
<br/><br/> Then define K={.kappa..sub.i=z.sub.y(i)-.GAMMA.}.sub.i=1.sup.n.
<br/><br/> Here, .GAMMA.  plays a role analogous to that of the offset .delta.  in the previously-described construction of FIGS. 2 and 3.
<br/><br/> Embodiments of the invention implemented in the context of password vaults will now be described in more detail.  It is to be appreciated, however, that other embodiments can be used in a wide variety of encryption and decryption contexts.
<br/><br/> Password vaults are popular software applications for storing and protecting users' often large collections of passwords.  Typically, a vault is itself encrypted under a password called a master password.  The benefit to the user in this
arrangement is that he or she need only remember this single secret to access all of his or her other passwords.  A drawback is that an attacker that obtains the vault and cracks the master password similarly learns all of the user's passwords.  This is
a real risk, as users often pick weak passwords, particularly ones, like master passwords, that they use often.  At the same time, vaults are increasingly stored en bloc in the cloud by services that support vault backup and synchronization.
<br/><br/> In the embodiments to be described, it is assumed that the password vault includes an additional protection on top of the master password, in that the true password vault is hidden within a set of decoy vaults containing similarly formatted
passwords.  An example of a conventional arrangement of this type is referred to as Kamouflage, and is described in H. Bojinov et al., "Kamouflage: loss-resistant password management," in ESORICS, pp.  286-302, 2010, which is incorporated by reference
herein.  An attacker that successfully cracks one or more of these vaults still faces the challenge of determining which is correct.  As all vaults are similarly formatted, this can be hard.  Kamouflage requires storage linear in the total number n of
vaults.
<br/><br/> An embodiment will now be described that uses HE to reduce storage to constant size, potentially enabling use of very large n and thus strong hiding of a user's password vault.  Such an embodiment can also achieve security and decryption speeds
roughly equivalent to those of Kamouflage for a given n.
<br/><br/> The Kamouflage system generates decoy passwords or honeywords from a password P in two stages.  First, the password P is parsed into a sequence of tokens T=t[1].parallel.  . . . .parallel.t[v].  We refer to the token sequence herein as a
password syntax.  The tokens in a syntax might be, for example, digit sequences, words, and strings of non-alphanumeric characters, respectively denoted d.sub.i, l.sub.i, and s.sub.i for length i. For example, the password gold5rings!! would be parsed as
l.sub.4.parallel.d.sub.1.parallel.l.sub.5.parallel.s.sub.2.  A honeyword is then generated by randomly replacing tokens with syntactically matching values from a predetermined lexicon, or list of possibilities, for each token type.  For example,
l.sub.4.parallel.d.sub.1.parallel.l.sub.5.parallel.s.sub.2 might yield honeywords such as: mice3blind:) tool1crate(# vote4goats@$
<br/><br/> Here, the words {"mice", "tool", "vote" } for instance, come from a lexicon lex(l.sub.4) of four-letter words for token l.sub.4.  Similarly, {`:)`, `(#`, `@$` } come from a lexicon lex(s.sub.2).
<br/><br/> A password vault is denoted as a collection of u passwords V=(MP=P.sub.0,P.sub.1, .  . . , P.sub.u-1), where MP is a master password used to encrypt the passwords in the vault.
<br/><br/> The Kamouflage system takes as input a valid user's password vault V and embeds it within a set of n-1 decoy vaults.  We refer to the n-1 decoy vaults as "honeyvaults" and the full set of n vaults, including the true vault V, as "sweetvaults."
<br/><br/> To create honeyvaults, the true vault V is parsed into a template T. Password P.sub.i is parsed into a syntax T.sub.i={t.sub.i[0].parallel.t.sub.i[1] .  . . .parallel.t.sub.i[v-1]}.  Here, for simplicity, we assume that every password has
exactly v tokens.  Token sequences may be padded out with special "null" tokens representing no character substitutions.  The result is a u.times.v matrix of tokens collectively comprising the template T. A honeyvault is constructed by randomly
instantiating tokens from the template T.
<br/><br/> Let V={V.sup.(j)}.sub.j=0.sup.n=1 denote the set of sweetvaults, where V.sup.(j)={MP.sup.(j)=P.sub.0.sup.(j), .  . . , P.sub.u-1.sup.(j)}.  The true vault V is placed in a randomly selected position k.di-elect cons..sub.U.sub.n; thus
V.sup.(k)=V. All n-1 other vaults are honeyvaults.
<br/><br/> Each vault is stored in encrypted form.  In particular, the set of passwords {P.sub.1.sup.(j), .  . . , P.sub.u-1.sup.(j)} is encrypted under MP.sup.(j)=P.sub.0.sup.(j).
<br/><br/> To decrypt a vault requires work n/2 on average over choices of k, as a master password MP must be tried against vaults in succession until the true vault V.sup.(k) is found.
<br/><br/> The Kamouflage system as described in the above-cited H. Bojinov et al. reference can include thousands of sweetvaults, but incurs noticeable performance degradation for n=10.sup.4 or greater.
<br/><br/> We now describe the first step of an exemplary process for encrypting vaults using HE.  This first step encrypts passwords.  It leaves the template T exposed; step two of the process achieves encryption of T.
<br/><br/> In what follows, T is slightly redefined to exclude the syntax of the master password; we now let T={T.sub.1, .  . . , T.sub.u-1}.  Given storage of the template T for V, it is possible to use HE to achieve an arbitrarily large number of
honeyvaults with constant storage.  It is also possible to avoid storing T explicitly.  In this setting, a honeyvault is a honeymessage and M is the set of all vaults that match T.
<br/><br/> In the present embodiment, the key-to-seed mapping function f(.kappa.) pseudorandomly generates seed s as a u.times.v array of values in [0,1].  Specifically, f(.kappa.) takes as input a key .kappa.=kd.sub..kappa.(MP), for some suitable choice
of key derivation function kd.sub..kappa..  Let w(i,a,.kappa.).fwdarw.[0,1] be a PRF.  Then f(.kappa.) outputs a seed s such that {s.sub.i[a]=w(i,a,.kappa.)}.sub.i.di-elect cons.[0,u-1],a.di-elect cons.[0,v-1].
<br/><br/> The seed-to-message mapping function g(s) fills in the template T to yield a vault V. Seed s specifies for each token t in T of a value or word to be filled in from its lexicon lex(t).  For token t.sub.i[a], seed value s.sub.i[a].di-elect
cons.[0,1] selects an entry from the lexicon lex(t.sub.i[a]) according to a probability distribution that estimates the frequencies of choices by a user population from the lexicon.  Note that since MP is furnished as input to f here, it is not generated
from T.
<br/><br/> Given this construction, any master password MP', whether or not correct, will generate a plaintext honeyvault matching template T. A correct master password MP will regenerate the original vault V.
<br/><br/> Step two of our process, encryption of T, requires a partitioning of the space of possible master passwords MP into E disjoint subsets referred to as equivalence classes.  An equivalence class encompasses passwords with identical syntax.  An
equivalence class thus serves conveniently as a compact representation of the valid and decoy passwords that decrypt or generate a given template T.
<br/><br/> For step two of the process, we assume that MP is partitioned into equivalence classes MP=MP.sub.1.orgate.  . . . , .orgate.MP.sub.E.  It is assumed that there is an efficient way to compute a password's partition membership, i.e., to find i
such that MP.di-elect cons.MP.sub.i.
<br/><br/> An exemplary approach to partitioning MP into equivalence classes is as follows.  First partition every lexicon lex(t) into disjoint subsets, i.e., let lex(t)=lex(t).sub.1.orgate.lex(t).sub.2 .  . . , .orgate.  . . . lex(t).sub.a.  Assume for
simplicity that a is identical for all lexica.  Then, for every password syntax T=t[1].parallel.  . . . .parallel.t[v], there correspond equivalence classes defined such that a class contains all passwords that: (1) match syntax T and (2) instantiate
each token t[i].di-elect cons.T from within a specific partition lex(t[i]).sub.j.sub.i in lexicon lex(t[i]).  In other words, passwords in the equivalence class instantiate tokens in T with choices from lex(t[1]).sub.j.sub.1.times.  . . .
.times.lex(t[v]).sub.j.sub.v for indices j.sub.1, .  . . , j.sub.v.di-elect cons.{1, .  . . , a}.
<br/><br/> Revealing the template T can be dangerous in the sense that it makes it easier for an adversary to guess passwords.  For example, if a password parses to d.sub.4, an attacker knows that the password lies in the relatively small space of
four-digit numbers.  Such knowledge can help an adversary perform password cracking and online guessing attacks against passwords.  Additionally, users often select master passwords of a format similar to their other passwords.  So revealing the format
of a vault can make the vault itself easier to crack.
<br/><br/> We can protect T by encrypting it using a conventional cipher using its equivalence class e as a key.  Specifically, we encrypt under a key .lamda.=kd(e) for a suitable key-derivation function kd.
<br/><br/> Let (enc,dec) denote a conventional encryption process, either symmetric or asymmetric, that outputs ciphertexts of uniform length.  And let c=enc.sup.HE(.kappa.,V) be the ciphertext yielded by applying HE to V as above.
<br/><br/> Then we construct a ciphertext of the form C=enc.sub..lamda.(M=(T,c)),
<br/><br/> Decrypting C with proffered master password MP' involves the following steps:
<br/><br/> 1.  Derive key .lamda.: Determine the partition index e such that MP'.di-elect cons.MP.sub.e and compute .lamda.=kd(e).
<br/><br/> 2.  Decrypt C: Compute M=(T,c)=dec.sub..lamda.[C].
<br/><br/> 3.  Decrypt c under HE to obtain vault V: Using T, compute V=dec.sub..kappa..sup.HE(c).
<br/><br/> This process requires storage only of the single ciphertext C. With regard to security, it is infeasible for an adversary to learn any information about V without guessing e. Suppose that n=|MP.sub.e|.  Given a source distribution d on
passwords, we might heuristically assume that the partitioning of MP assigns passwords of roughly equal weight in d to MP.sub.e.  In this case, a guessing attempt against C will succeed with probability at most n.times.pr.sub.d(MP).
<br/><br/> The probability of guessing the master password for a given sweetvault in Kamouflage is roughly pr.sub.d(MP).  The incremental cost, however, of cracking other sweetvaults once one has been cracked is relatively low in Kamouflage, due to the
fact that all master passwords have identical syntax.
<br/><br/> Accordingly, given a key-derivation function kd that slows decryption in our process by a factor of n, we achieve security roughly equivalent to that of Kamouflage, in the sense of resistance to discovery of the set of sweetvaults for V.
Decryption in our process, then, requires time equal to the worst-case time of Kamouflage and close to twice its expected decryption time.
<br/><br/> Additionally, our approach permits a service provider to detect compromise of a user's vault via implicit honeywords.
<br/><br/> In another embodiment, it is possible to protect T itself using HE, rather than ordinary encryption.  This approach could in principle achieve stronger encryption of V than Kamouflage, still with constant storage.
<br/><br/> Construction of an HE algorithm for templates in a user population, though, may be based on knowledge of the distribution d.sub.T of templates for vaults generated by the population.  In contrast to individual passwords, whose composition by
typical users is relatively well studied, the lack of public databases of full, leaked vaults means that there is little understanding of how users typically choose batches of passwords, as in vaults.
<br/><br/> In this case, in addition to the HE process (enc.sup.HE,dec.sup.HE) for encryption of V, another HE process, (enc.sup.HE2,dec.sup.HE2), is used for encryption of T.
<br/><br/> Construction of a good mapping g in this case is ideally based on an understanding of the source distribution d of vault templates T.
<br/><br/> On the other hand, a function g that doesn't model d perfectly, but outputs many plausible vaults, can still provide strong security.
<br/><br/> An exemplary function g for (enc.sup.HE2,dec.sup.HE2) for generating a template T' will now be described.  It aims to capture the similarities among the password choices of most users, including similarities between MP and other passwords.  The
idea is to generate a small set of password syntaxes by "perturbing" the syntax for MP.  The syntaxes in this small set are then assigned to random positions in T'.
<br/><br/> The function is illustratively configured as follows:
<br/><br/> Algorithm: g(s').fwdarw.T' 1.  Parse the master password MP, yielding syntax T=t[1].parallel.  . . . .parallel.t[v].  2.  Randomly pick a number U.di-elect cons..sub.d.sub.U of unique passwords, P.sub.1' .  . . , P.sub.U'.  3.  Perturb the
syntax for each password P.sub.i': Randomly pick a number of perturbations B.di-elect cons..sub.d.sub.B.di-elect cons..  Assign syntax T.sub.i'.rarw.T to P.sub.i'.  Apply B perturbations to T.sub.i'.  4.  Assign syntaxes to T: For each syntax
T.sub.i.di-elect cons.T, choose T'.di-elect cons..sub.U{T.sub.j'}.sub.j=1.sup.U, and set T.sub.i.rarw.T'.
<br/><br/> Realistic choices of distributions d.sub.U and d.sub.B may be derived from additional surveying of user password choices.
<br/><br/> Examples of perturbations that may be used include modifying a token by substituting a different token (possibly including the "null" token), e.g., changing a d.sub.2 (pair of digits) into an s.sub.4 (pair of special characters), and modifying
the length of a token, e.g., changing an l.sub.4 (four-letter word) into a d.sub.3 (three-letter word).  User modification to password syntax might be treated as a Markov model.
<br/><br/> A seed may comprise a fixed-sized array of probabilities.  A possible additive group is one that sums seeds (with "wraparound") in identical array positions.
<br/><br/> Service providers that store password vaults on behalf of their users can, in principle, protect these vaults by sending them only to a user's registered devices, relying on the master password to provide on-device confidentiality.  To prevent
offline cracking of vaults by an adversary that manages to associate a device falsely with a user's account and download his or her vault, the service may perform online checking of MP.
<br/><br/> Storage of h(MP), however, would expose MP to a hash-cracking attack and thus negate the value of HE on vaults in the case of provider compromise.  Instead, in our process involving ordinary encryption of T, the provider might instead store
h(.lamda.), a hash of the key .lamda.  representing MP's equivalence class e. To download V, then, an attacker must guess e. An attacker that compromises the provider must crack h(.lamda.) to learn e, a task as hard as obtaining e from the encrypted
vault C.
<br/><br/> An alternative or complement to the use of templates in applying HE to vaults is to permute the web sites or other account names associated with passwords.  We then encrypt using HE a permutation .pi.  mapping passwords to account names in the
vault.  One way to protect a vault is to encrypt passwords under an equivalence class e using ordinary encryption and .pi.  under the master password MP using HE.
<br/><br/> In some cases, users may produce vaults or passwords that stand out as much more probable than honeymessage alternatives.  For example, some users adopt the password composition formula R.parallel.X for website X, where R is a "root" password
employed across multiple sites.  In this case, an HE process on the permutation .pi.  would be ineffective, in that for any vault V* that contains a password of the form R.parallel.X' for website X, pr.sub.d(V*).apprxeq.0.  One way to address this issue
is simply to reject passwords of such form.  Another is for the vault to identify passwords of this form and to apply syntax-based HE to R, leaving X unchanged.
<br/><br/> Some password vaults generate strong, random passwords on request for users.  For such passwords, password syntax is just an artifact of the generation process, and doesn't reflect user password-selection behavior.  As such, syntax-based HE
isn't applicable.  Instead, a password may be specified in a password space P pseudorandomly by a key .sigma..di-elect cons..sub.U.SIGMA.={0,1}.sup.l using a PRF z(.sigma.).fwdarw.P.  Then HE may be applied straightforwardly to .sigma., and the password
reconstituted using z(.sigma.) upon vault reconstruction.
<br/><br/> As indicated above, other embodiments can be implemented outside of the password vault context.  For example, a number of tools are available to protect corporate data, including e-mail, documents, contacts and so forth, on personal devices
within compartments called "containers." It is a common policy to require users to encrypt containers under passwords to protect against compromise in case of device loss.  HE can provide additional protection in this context, although a challenge is
finding a good generation function for semantically complex content such as e-mail messages.  It is possible, though, to apply HE not to entire documents, but instead only to portions that are particularly sensitive and amenable to generation of
plausible decoys.  For example, HE might be applied to monetary amounts in spreadsheets, to e-mail addresses in contact lists, etc.
<br/><br/> The HE techniques disclosed herein can also be adapted for use in protecting symmetric keys.  Keys are typically l-bit random bitstrings; thus a natural choice is S=M={0,1}.sup.l and g(s)=s. HE can't be applied to private keys, of course, where
corresponding public keys are available.  Where they aren't, HE may be applied straightforwardly to protection of keys for discrete-log-based systems.  Protection of RSA private keys may be accomplished by applying HE to a pseudorandom seed used to
generate the private key.
<br/><br/> In other embodiments, the HE constructions described previously may be varied.  In one such variation, the generation function g can involve online resources.  These can be useful in creating plausible messages.  For example, a contact might be
generated from a numeric seed that specifies a social network identity (e.g., a <b><i>Facebook</i></b> numeric ID).  Online generation functions can also help throttle guessing attempts.  For example, a resource might be stored in an online account, with its URL and
password encrypted under HE.
<br/><br/> In another possible variant, incorrect decryption results in HE may be deployed as honeytokens and serve to detect compromises of HE ciphertexts.
<br/><br/> Consider, for example, the HE process for password vaults described above.  A service provider holding password P from the user's vault can of course compute the syntax of P. If the provider knows the structure of equivalence classes over a
user's vault, the provider can determine whether a submitted password P' represents a honeyword equivalent to P, i.e., represents the result of a decryption of V under an invalid master password.
<br/><br/> In principle, equivalence classes can be defined identically for all vaults, and thus published.  Consequently, service providers can detect possible honeyword submission without any special coordination with the user or password-vault service. 
Removing the need for such coordination provides a distinct advantage over Kamouflage, for which explicit transmission of honeywords to service providers is suggested as a system option.
<br/><br/> HE beneficially hides a true plaintext message m by yielding a honeymessage with high probability under decryption with any incorrect key .kappa.'.  The ability to decrypt for any key .kappa.', however, can be a drawback in settings where keys
derive from secrets manually entered (e.g., typed) by users.
<br/><br/> For example, suppose that a user applies HE to encrypt an address book with telephone numbers under a password.  If he or she enters the wrong password due to a typo or erroneous autocorrection, he or she will obtain valid-looking but wrong
telephone numbers and may not realize it.
<br/><br/> Using error-detecting codes, it is possible to achieve "typo safety," in which slight variants to .kappa., such as those introduced by typos, may be flagged and invalidated.  As a simple example, for password P, a check value h(P)mod 100 might
be stored alongside an HE ciphertext encrypted under P. 99% of incorrect passwords, then, may be detected at the time of entry.  Of course, in this case, an attacker too can rule out 99% of possible passwords as invalid.  In general, the stronger the
error-detecting code, the better the typo safety, but the smaller the space of honeymessages.
<br/><br/> More sophisticated codes, though, can detect the most common errors, such as mistyped characters and character transpositions.  For example, book serial numbers, known as ISBNs, famously include a mod-11 check digit that detects a single typo or
digit transposition.
<br/><br/> In the case of password vaults utilizing equivalence classes of the type described herein, there is a good alternative or complement to the checksum-based approach to typo safety.  We can construct equivalence classes such that the class of a
master password itself serves as an error-detection value (e.g., checksum).  That is, if master password MP belongs to a given equivalence class e, a mistyping MP'.noteq.MP with a different checksum will also yield a different equivalence class e' e, and
thus a decryption failure.
<br/><br/> The above-described equivalence class construction based on partitioning of lexica can detect typographical errors.  Take lex(d.sub.2), for example, the lexicon containing pairs of digits.  Adopting the ISBN checksum technique mentioned above,
for some prime q (e.g., q=11), one can place the value X.di-elect cons.lex(d.sub.2) in partition X mod q. X's partition, then, serves as a checksum, in that any single-digit error or digit transposition of X belongs to a different partition.
<br/><br/> As mentioned previously, HE in some embodiments may be viewed as a form of information-theoretic encryption, in that it relies fundamentally not on computational hardness assumptions, but an adversary's ability to verify use of a correct
decryption key.
<br/><br/> Low-entropy secrets such as passwords are likely to persist in computer systems for many years.  Their use for encryption leaves resources vulnerable to offline attack.  HE as described herein can offer valuable additional protection in such
scenarios.  It yields plausible looking plaintexts under decryption with invalid keys, so that offline decryption attempts alone are insufficient to discover the correct plaintext.
<br/><br/> It is possible to achieve protections similar to those of HE by explicitly encrypting decoy messages.  This approach results in storage overhead linear in the total number of messages n. HE, in contrast, achieves constant storage requirements
for increasing n, and generally little more storage than that required for ordinary encryption.  HE has additional benefits too, such as facilitating detection by service providers of stolen ciphertexts via implicit honeytokens.
<br/><br/> Moreover, due to its ability to support large numbers n of honeymessages, HE can provide strong security benefits even when only a small fraction of these messages are plausible.
<br/><br/> The particular encryption and decryption processing operations and other system functionality described in conjunction with the embodiments described in conjunction with FIGS. 2-4 and elsewhere herein are presented by way of illustrative example
only, and should not be construed as limiting the scope of the invention in any way.  Alternative embodiments can use other types of processing operations for implementing encryption and decryption functions using the techniques disclosed herein.
<br/><br/> Encryption and decryption functionality such as that described in conjunction with FIGS. 2-4 can be implemented at least in part in the form of one or more software programs stored in memory and executed by a processor of a processing device
such as a mobile telephone or computer.  As mentioned previously, a memory or other storage device having such program code embodied therein is an example of what is more generally referred to herein as a "processor-readable storage medium."
<br/><br/> It should again be emphasized that the above-described embodiments of the invention are presented for purposes of illustration only.  Many variations and other alternative embodiments may be used.  For example, the techniques are applicable to a
wide variety of other types of devices and systems that can benefit from enhanced security in encryption and decryption using low-entropy keys or other types of keys as disclosed herein.  Also, the particular configuration of messages, ciphertexts,
seeds, keys, key-to-seed mapping functions, seed-to-message mapping functions and other functions, and the associated encryption and decryption operations, can be varied in other embodiments.  Moreover, the various simplifying assumptions made above in
the course of describing the illustrative embodiments should also be viewed as exemplary rather than as requirements or limitations of the invention, and need not apply in other embodiments.  Numerous other alternative embodiments within the scope of the
appended claims will be readily apparent to those skilled in the art.
<br/><br/><center><b>* * * * *</b></center>
<hr/>
   <center>
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09325499&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D701%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D15%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>
   <table>
   <tbody><tr><td align="center"><a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D701%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D15%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209325499"><img alt="[View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9325499&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D701%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D15%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209325499">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
     <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=701&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=14&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=701&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=15&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=701&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=702&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=15&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

   <a href="#top"><img alt="[Top]" border="0" src="/netaicon/PTO/top.gif" valign="middle"/></a>
   </td></tr>
   </tbody></table>
   <a name="bottom"></a>
   <a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
   </center>

</coma></body></html>
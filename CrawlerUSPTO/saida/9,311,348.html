<html><head>
<base target="_top"/>
<title>United States Patent: 9311348</title></head>
<!---BUF1=9311348
BUF7=2016
BUF8=61397
BUF9=/1/
BUF51=9
---->
<body bgcolor="#FFFFFF">
<a name="top"></a>
<center>
<img alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" src="/netaicon/PTO/patfthdr.gif"/>
<br/>
<table>
<tbody><tr><td align="center">
<a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
<a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
<a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
</td></tr>
<tr><td align="center">
   <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=839&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=839&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=839&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=18&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=838&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=840&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

<a href="#bottom"><img alt="[Bottom]" border="0" src="/netaicon/PTO/bottom.gif" valign="middle"/></a>
</td></tr>
   <tr><td align="center">
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D839%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D17%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209311348"><img alt="[
View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9311348&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D839%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D17%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209311348">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09311348&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D839%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D17%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>

   </td></tr>
</tbody></table>
</center>
<table width="100%">
<tbody><tr><td align="left" width="50%"> </td>
<td align="right" valign="bottom" width="50%"><font size="-1">( <strong>839</strong></font> <font size="-2">of</font> <strong><font size="-1">7895</font></strong> <font size="-1">)</font></td></tr></tbody></table>
<hr/>
   <table width="100%">
   <tbody><tr>	<td align="left" width="50%"><b>United States Patent </b></td>
   <td align="right" width="50%"><b>9,311,348</b></td>
   </tr>
     <tr><td align="left" width="50%"><b>
         Smith
,   et al.</b>
     </td>
     <td align="right" width="50%"> <b>
     April 12, 2016
</b></td>
     </tr>
     </tbody></table>
       <hr/>
       <font size="+1">Method and system for implementing an array using different data
     structures
</font><br/>
       <br/><center><b>Abstract</b></center>
       <p> Disclosed are a method and system for implementing an array data type of
     a programming language using various data structures. The disclosed
     method includes a plurality of implementations in which the array data
     type may be implemented. The implementations provide an efficient way to
     retrieve elements from the array, especially in the order they are
     inserted into the array. The data structures also minimize the computing
     resources required to manage and access the array. The disclosed
     technique also selects one of the many implementations based on criteria
     such as access pattern or size of the array.
</p>
       <hr/>
<table width="100%"> <tbody><tr> <th align="left" scope="row" valign="top" width="10%">Inventors:</th> <td align="left" width="90%">
 <b>Smith; Edwin Thur Gideon</b> (Newton, MA)<b>, Adams; Keith</b> (San Carlos, CA)<b>, Evans; Jason Owen</b> (Palo Alto, CA) </td> </tr>
<tr><th align="left" scope="row" valign="top" width="10%">Applicant: </th><td align="left" width="90%"> <table> <tbody><tr> <th align="center" scope="column">Name</th> <th align="center" scope="column">City</th> <th align="center" scope="column">State</th> <th align="center" scope="column">Country</th> <th align="center" scope="column">Type</th> </tr> <tr> <td> <b><br/><b><i>Facebook,</i></b> Inc.</b> </td><td> <br/>Menlo Park </td><td align="center"> <br/>CA </td><td align="center"> <br/>US </td> <td align="left"> </td>
</tr> </tbody></table>
<!-- AANM>
~AANM <B><I>Facebook,</I></B> Inc.
~AACI Menlo Park
~AAST CA
~AACO US
</AANM -->
</td></tr>
<tr> <th align="left" scope="row" valign="top" width="10%">Assignee:</th>
<td align="left" width="90%">

<b><a href="#h2" name="h3"></a><a href="#h4"></a><b><i>Facebook,</i></b> Inc.</b>
 (Menlo Park, 
CA)
<br/>

</td>
</tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Family ID:
       </th><td align="left" width="90%">
       <b>50826550
</b></td></tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Appl. No.:
       </th><td align="left" width="90%">
       <b>14/713,561</b></td></tr>
       <tr><th align="left" scope="row" valign="top" width="10%">Filed:
       </th><td align="left" width="90%">
       <b>May 15, 2015</b></td></tr>
     </tbody></table>
<hr/> <center><b>Prior Publication Data</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Document Identifier</u></b></th><th align="center" scope="col"><b><u>Publication Date</u></b></th></tr><tr><td align="center"> </td><td align="center"> US 20150248445 A1</td><td align="center">Sep 3, 2015</td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table>
<hr/> <center><b>Related U.S. Patent Documents</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col" width="7%"></th><th scope="col"></th><th scope="col"></th> <th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Application Number</u></b></th><th align="center" scope="col"><b><u>Filing Date</u></b></th><th align="center" scope="col"><b><u>Patent Number</u></b></th><th align="center" scope="col"><b><u>Issue Date</u></b></th></tr><tr><td align="center"> </td><td align="center">13691622</td><td align="center">Nov 30, 2012</td><td align="center">9069807</td><td align="center"></td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table><td< td=""></td<><td< td=""></td<>     <hr/>
<p> <table width="100%"> <tbody><tr><td align="left" valign="top" width="30%"><b>Current U.S. Class:</b></td> <td align="right" valign="top" width="70%"><b>1/1</b> </td></tr> 
       <tr><td align="left" valign="top" width="30%"><b>Current CPC Class: </b></td>
       <td align="right" valign="top" width="70%">G06F 17/3033 (20130101); G06F 17/30126 (20130101); G06F 17/30312 (20130101); G06F 9/34 (20130101)</td></tr>
         <tr><td align="left" valign="top" width="30%"><b>Current International Class: </b></td>
         <td align="right" valign="top" width="70%">G06F 17/30 (20060101); G06F 9/34 (20060101)</td></tr>
       <tr><td align="left" valign="top" width="30%"><b>Field of Search: </b></td>
       <td align="right" valign="top" width="70%">
       
 ;707/803
       </td></tr>
     </tbody></table>
</p><hr/><center><b>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=PALL&amp;Query=ref/9311348">[Referenced By]</a></b></center>       <hr/>
       <center><b>U.S. Patent Documents</b></center>
<table width="100%"> <tbody><tr><th scope="col" width="33%"></th> <th scope="col" width="33%"></th> <th scope="col" width="34%"></th></tr> <tr> <td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6687815">6687815</a></td><td align="left">
February 2004</td><td align="left">
Dwyer et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6961733">6961733</a></td><td align="left">
November 2005</td><td align="left">
Mazzagatti</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F8484427">8484427</a></td><td align="left">
July 2013</td><td align="left">
Goldobin et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20020073068&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2002/0073068</a></td><td align="left">
June 2002</td><td align="left">
Guha</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20060156064&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2006/0156064</a></td><td align="left">
July 2006</td><td align="left">
Damani et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080307181&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0307181</a></td><td align="left">
December 2008</td><td align="left">
Kuszmaul et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20100217953&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2010/0217953</a></td><td align="left">
August 2010</td><td align="left">
Beaman et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110225391&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0225391</a></td><td align="left">
September 2011</td><td align="left">
Burroughs et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110276744&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0276744</a></td><td align="left">
November 2011</td><td align="left">
Sengupta et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20130268770&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2013/0268770</a></td><td align="left">
October 2013</td><td align="left">
Hunt et al.</td></tr><tr><td align="left">

</td>
</tr> </tbody></table>
<table width="90%">   <tbody><tr><td><align="left"><br/>Non-Final Office Action Mailed Dec. 26, 2014, U.S. Appl. No. 13/691,622 of Smith, Edwin T.G., et al., filed Nov. 30, 2012. cited by applicant
.<br/>Notice of Allowance Mailed Apr. 17, 2015, in U.S. Appl. No. 13/691,622 of Smith, Edwin T.G., et al., filed Nov. 30, 2012. cited by applicant. </align="left"></td></tr> </tbody></table><br/><center><b>Other References</b></center> <br/>
       <i>Primary Examiner:</i> Perveen; Rehana
<br/>
       <i>Assistant Examiner:</i> Bui; Tiffany Thuy
<br/>
       <i>Attorney, Agent or Firm:</i> <coma>Perkins Coie LLP
<br/>
       <hr/>
       <center><b><i>Parent Case Text</i></b></center>
       <hr/>
       <br/><br/>CROSS-REFERENCE
<br/><br/> This application is a continuation of U.S. patent application Ser. No.
     13/691,622, entitled "METHOD AND SYSTEM FOR IMPLEMENTING AN ARRAY USING
     DIFFERENT DATA STRUCTURES," filed on Nov. 30, 2012, which is incorporated
     herein by reference in its entirety.
         <hr/>
<center><b><i>Claims</i></b></center> <hr/> <br/><br/>What is claimed is: <br/><br/> 1.  A method, comprising: creating, in a memory of a computer system, a first data structure having multiple contiguous buckets of the memory, the buckets configured to store
multiple key-value pairs in the order in which the key-value pairs are inserted into an array;  and creating, in the memory of the computer system, a second data structure having multiple slots of the memory, a specified slot of the slots corresponding
to a specified key of the key-value pairs, the specified slot configured to store a specified pointer that points to a specified bucket of the first data structure storing a value of the specified key, the specified slot of the second data structure
determined as a function of the specified key stored in the first data structure, the first data structure and the second data structure being different data structures, wherein the first data structure and the second data structure together form a
combined data structure that represents the array, and wherein the combined data structure includes a first pointer to the first data structure and a second pointer to the second data structure.
<br/><br/> 2.  The method of claim 1 further comprising: obtaining, upon insertion of a first key-value pair into the array, a first bucket from the first data structure, the first bucket being contiguous in the memory to a previously filled bucket, and a
first slot from the second data structure, the first slot corresponding to a first key of the first key-value pair;  storing, in the first bucket, the first key-value pair;  and storing, in the first slot, a pointer that points to the first bucket.
<br/><br/> 3.  The method of claim 2, wherein the second data structure is a hashtable.
<br/><br/> 4.  The method of claim 3, wherein obtaining, from the second data structure, the first slot corresponding to the first key includes obtaining the first slot by using a hash function on the first key.
<br/><br/> 5.  The method of claim 1, wherein the specified pointer that points to the specified bucket of the first data structure is an offset of the specified bucket in the first data structure.
<br/><br/> 6.  The method of claim 1 further comprising: reading the buckets of the first data structure contiguously to obtain the key-value pairs in the order the key-value pairs are inserted into the array.
<br/><br/> 7.  The method of claim 1, wherein the first data structure and the second data structure are created in a single contiguous block of the memory.
<br/><br/> 8.  The method of claim 1, wherein at least one of the first data structure or the second data structure are created in separate blocks of the memory.
<br/><br/> 9.  A computer-readable storage device storing computer-readable instructions, the instructions comprising: instructions for creating, in a memory of a computer system, a first data structure having multiple slots of the memory, the slots
configured to store key-value pairs of an array, the slots including a specified slot storing a specified key-value pair of the key-value pairs;  and instructions for creating, in the memory of the computer system, a second data structure having multiple
contiguous buckets of the memory, the buckets configured to store pointers pointing to the slots storing the key-value pairs, a specified pointer of the pointers associated with the specified key-value pair, and the buckets further configured to store
the pointers in the order in which the key-value pairs with which the pointers are associated are inserted into the array, the specified slot of the first data structure determined as a function of a specified key of the specified key-value pair stored
in the second data structure, wherein the first data structure and the second data structure together form a combined data structure that represents the array, and wherein the combined data structure includes a first pointer to the first data structure
and a second pointer to the second data structure.
<br/><br/> 10.  The computer-readable storage device of claim 9 further comprising: instructions for obtaining, upon insertion of a first key-value pair into the array: a first slot from the first data structure corresponding to a first key of the first
key-value pair, and a first bucket from the second data structure to store a first pointer that points to the first slot, the first bucket being contiguous in the memory to a previously filled bucket;  instructions for storing, in the first slot, the
first key-value pair;  and instructions for storing, in the first bucket, the first pointer.
<br/><br/> 11.  The computer-readable storage device of claim 10, wherein the first data structure is a hashtable.
<br/><br/> 12.  The computer-readable storage device of claim 11, wherein the instructions for obtaining, from the first data structure, the first slot corresponding to the first key includes instructions for obtaining the first slot by using a hash
function on the first key.
<br/><br/> 13.  The computer-readable storage device of claim 9 further comprising: instructions for reading the buckets of the second data structure contiguously to obtain an ordered set of pointers;  and instructions for reading a set of the slots
pointed to by the ordered set of pointers to obtain the key-value pairs in the order in which the key-value pairs are inserted into the array.
<br/><br/> 14.  An apparatus, comprising: a hardware processor;  a data structure creation module configured to receive a request to create an array data structure for implementing an array of a programming language, the array data structure configured to
store multiple key-value pairs;  and an implementation selection module to select, based on a pre-defined selection criteria, one of multiple implementations of the array data structure to generate a selected implementation, the implementations including
a first implementation and a second implementation, the first implementation storing the key-value pairs in the order in which the key-value pairs are inserted into the array, the second implementation storing multiple pointers that point to the
key-value pairs in the order in which the key-value pairs are inserted into the array, wherein the data structure creation module is configured to create the array data structure based on the selected implementation, wherein the array data structure
created based on the selected implementation includes a first pointer to a first data structure and a second pointer to a second data structure, the first data structure and the second data structure together forming the array data structure, wherein the
first data structure stores the key-value value pairs and the second data structure stores pointers to the key-value pairs stored in the first data structure, wherein the second data structure stores the pointers in the order in which the key-value pairs
are inserted into the array or as a function of keys of the key-value pairs pointed to by the pointers.
<br/><br/> 15.  The apparatus of claim 14, wherein, in the first implementation, the data structure creation module is configured to: generate the first data structure having multiple contiguous buckets of a memory of a computer system, the buckets
configured to store the key-value pairs in the order in which the key-value pairs are inserted into the array, and generate the second data structure having multiple slots of the memory, the slots configured to store the pointers, a specified slot of the
slots corresponding to a specified key of the key-value pairs, the specified slot configured to store a specified pointer of the pointers that points to a specified bucket of the first data structure storing one of the key-value pairs having the
specified key, wherein the first data structure and the second data structure are different data structures.
<br/><br/> 16.  The apparatus of claim 14, wherein, in the second implementation, the data structure creation module is configured to: generate the first data structure having multiple slots of a memory of a computer system, the slots configured to store
the key-value pairs, a specified slot of the slots corresponding to a specified key of the key-value pairs, and generate the second data structure having multiple contiguous buckets of the memory, the buckets configured to store the pointers, the
pointers pointing to the slots storing the key-value pairs, a specified pointer of the pointers associated with a specified key-value pair of the key-value pairs, and the buckets further configured to store the pointers in the order in which the
key-value pairs are inserted into the array.
<br/><br/> 17.  The apparatus of claim 14, wherein the implementation selection module is configured to select the first implementation if at least one of (i) a frequency of fetching values of the key-value pairs in the order they are inserted exceeds a
first threshold, or (ii) if a size of the array is below a second threshold.
<br/><br/> 18.  The apparatus of claim 14, wherein the implementation selection module is configured to select the second implementation if at least one of (i) a frequency of fetching values of the key-value pairs in an order other than in which the
key-value pairs are inserted exceeds a first threshold, (ii) a size of the array exceeds a second threshold, (iii) a number of reads/writes performed on the array exceeds a third threshold, or (iv) a number of values read from or written into the array
exceeds a fourth threshold.
<br/><br/> 19.  The apparatus of claim 14, wherein the pre-defined selection criteria includes at least one of (i) an access pattern of the array, or (ii) a size of the array. <hr/> <center><b><i>Description</i></b></center> <hr/> <br/><br/>FIELD OF INVENTION
<br/><br/> This invention generally relates to data structures in computer programming languages.  More specifically, the invention relates to implementing an array data type using different data structures.
<br/><br/>BACKGROUND
<br/><br/> In certain programming languages, array data type is implemented using a hashtable.  The hashtable is a data structure having "n" number of "slots" of memory.  The array elements are stored as key-value pairs in the slots of the hashtable.  The
index of the array is stored as a key and the element at the index is stored as a value in the hashtable.  For example, in an array $arr=array([`a`]=1), the array element, "1" at an index "a" is stored as a key-value pair ("a,1") in the hashtable.  An
element of the array is stored in one of the slots of the hashtable.  The particular slot in which the element is stored is determined by hashing the index of the array to a particular slot.  The hashing function determines a slot number for a given
index.
<br/><br/> Prior array implementation techniques have limitations in the way the array elements are stored.  Certain implementation techniques do not inherently record or track the order in which the array elements are inserted into the array.  So,
applications that need to retrieve the elements in the order they were inserted into the array have to include their own logic in the application program to retrieve the elements in the order they were inserted.
<br/><br/> Certain prior techniques that support retrieving or tracking the elements in the order they are inserted use pointers.  Data is stored into a slot of the hashtable along with, for example, two pointers.  One pointer points to the next inserted
element and another one points to the previously inserted element.  The pointers are updated as and when the elements are added or deleted from the hashtable.  Storing pointers with every array element consumes significant memory.  Also, reading the
chain of pointers to retrieve the elements in the order they are inserted consumes significant processor time.
<br/><br/>SUMMARY
<br/><br/> The present teaching provides a variety of methods, systems and paradigms for implementing an array data type of a programming language using various data structures.  Certain disclosed techniques include a plurality of implementations in which
the array data type may be implemented.  The implementations provide an efficient way to retrieve elements of the array, especially in the order they are inserted into the array.  The data structures also minimize the computing resources required to
manage and access the array.  Other disclosed techniques also select one of the many implementations based on criteria including access pattern or size of the array.
<br/><br/> In an embodiment, the array is a data type in a dynamic programming language, such as Personal Home Page (PHP).  In other embodiments, the array could be part of other programming languages.  The array stores data as key-value pairs, where a
value is associated with a key of the key-value pair.  Also, the key acts as an index of the array.  In other embodiments, the array can store the data in other formats.
<br/><br/> In a first implementation, the array is represented using a combination of a first data structure and a second data structure.  The first data structure includes a plurality of contiguous memory buckets that store key-value pairs in the order in
which the key-value pairs are inserted into the array.  The second data structure includes a plurality of memory slots that store pointers that point to the buckets of the first data structure.  Each of the slots corresponds to a key of the key-value
pairs in the first data structure, and stores a pointer pointing to the bucket which has the value of the key.  The key-value pairs may be retrieved in the order they are inserted by iterating through the first data structure.  In an embodiment, the
first data structure is an ordered container having contiguous blocks of memory, and the second data structure is a hashtable.
<br/><br/> In a second implementation, the array is represented using a combination of a first data structure and a second data structure.  The first data structure includes a plurality of slots of the memory that store key-value pairs of the array.  Each
of the slots correspond to a key of the key-value pairs.  The second data structure includes a plurality of contiguous buckets of the memory that store pointers pointing to the slots containing key-value pairs.  Each of the pointers is associated with
one of the key-value pairs.  Further, the buckets store the pointers in the order in which the corresponding key-value pairs are inserted into the array.  The key value pairs may be retrieved in the order they were inserted by iterating through the
second data structure to obtain the pointers to the slots containing the key-value pairs and then obtaining the key-value pairs from the slots pointed to by the pointers.  In an embodiment, the first data structure is a hashtable and the second data
structure is an ordered container having contiguous blocks of memory.
<br/><br/> Some embodiments of the invention have other aspects, elements, features, and steps in addition to or in place of what is described above.  These potential additions and replacements are described throughout the rest of the specification.
<br/><br/>BRIEF DESCRIPTION OF THE DRAWINGS
<br/><br/> FIG. 1 is a distributed environment in which an embodiment of the invention may operate.
<br/><br/> FIGS. 2A-2C collectively illustrate example implementations of an array.
<br/><br/> FIG. 3 is a block diagram illustrating allocation of memory for an array data structure.
<br/><br/> FIG. 4 is a block diagram of a system for implementing an array using one of a plurality of implementations, according to an embodiment of the disclosed technique.
<br/><br/> FIG. 5 illustrates a process of implementing an array data structure for an array using a first implementation.
<br/><br/> FIG. 6 is a flow diagram of a process for writing a key-value pair of the array into the array data structure implemented using the first implementation.
<br/><br/> FIG. 7 is a flow diagram of a process for retrieving key-value pairs of the array in the order they are inserted, in the first implementation.
<br/><br/> FIG. 8 is a flow diagram of a process for retrieving key-value pairs of the array in a random order in the first implementation.
<br/><br/> FIG. 9 illustrates a process of implementing an array data structure for an array using a second implementation.
<br/><br/> FIG. 10 is a flow diagram of a process for writing a key-value pair of the array into the array data structure implemented using the second implementation.
<br/><br/> FIG. 11 is a flow diagram of a process for retrieving key-value pairs of the array in the order they are inserted, in the second implementation.
<br/><br/> FIG. 12 is a flow diagram of a process for retrieving key-value pairs of the array in a random order, in the second implementation.
<br/><br/> FIG. 13 is a flow diagram of a process for selecting one of a plurality of implementations to implement an array data structure for an array.
<br/><br/> FIG. 14 is a block diagram of an apparatus that may perform various operations, and store various information generated and/or used by such operations.
<br/><br/>DETAILED DESCRIPTION
<br/><br/> References in this description to "an embodiment", "one embodiment", or the like, mean that the particular feature, function, or characteristic being described is included in at least one embodiment of the present invention.  Occurrences of such
phrases in this specification do not necessarily all refer to the same embodiment, nor are they necessarily mutually exclusive.
<br/><br/> Disclosed are a method and system for implementing an array data structure of a programming language using a plurality of implementations.  The implementations provide an efficient way to retrieve elements from the array, especially to retrieve
them in the order they were inserted into the array.  The data structures also minimize the computing resources required to manage and access the array.  The disclosed technique also selects one of the many implementations based on criteria including
access pattern or size of the array.
<br/><br/> In an embodiment, the array is a data type in a dynamic programming language, such as Personal Home Page (PHP).  In other embodiments, the array could be part of other programming languages.  The array stores data as key-value pairs, where a
value is associated with a key of the key-value pair.  Also, the key acts as an index of the array.  In other embodiments, the array can store the data in other formats.
<br/><br/> In a first implementation, the array is represented using a combination of a first data structure and a second data structure.  The first data structure includes a plurality of contiguous memory buckets that store key-value pairs in the order in
which the key-value pairs are inserted into the array.  The second data structure includes a plurality of memory slots that store pointers that point to the buckets of the first data structure.  Each of the slots corresponds to a key of the key-value
pairs in the first data structure, and stores a pointer pointing to the bucket which has the value of the key.  The key-value pairs may be retrieved in the order they are inserted by iterating through the first data structure.  In an embodiment, the
first data structure is an ordered container having contiguous blocks of memory, and the second data structure is a hashtable.
<br/><br/> In a second implementation, the array is represented, again, using a combination of a first data structure and a second data structure.  The first data structure includes a plurality of slots of the memory that store key-value pairs of the
array.  Each of the slots correspond to a key of the key-value pairs.  The second data structure includes a plurality of contiguous buckets of the memory that store pointers pointing to the slots containing key-value pairs.  Each of the pointers is
associated with one of the key-value pairs.  Further, the buckets store the pointers in the order in which the corresponding key-value pairs are inserted into the array.  The key value pairs may be retrieved in the order they were inserted by iterating
through the second data structure to obtain the pointers to the slots containing the key-value pairs and then obtaining the key-value pairs from the slots pointed to by the pointers.  In an embodiment, the first data structure is a hashtable and the
second data structure is an ordered container having contiguous blocks of memory.
<br/><br/> FIG. 1 is a distributed environment 100 in which an embodiment of the invention may operate.  The environment 100 includes a processor 115, a memory 120, a compilation module 110 and a runtime module 130.  The compilation module 110 compiles
source code 105 of a program to an intermediate code 125, and the runtime module 130 executes the intermediate code 125.  The intermediate code 125 can be machine code or byte code, for example.
<br/><br/> The source code 105 can be written using a programming language, such as PHP.  In other embodiments, the source code 105 can be written using other programming languages.  The source code 105 includes programming language constructs such as
class, function, and data types such as array, etc. When the source code 105 is executed, the data types (and programming language constructs) are implemented, in the memory 120, using various data structures.  The data structure used to implement a data
type has a significant impact on the efficiency of the execution of the program.  Further, a usage pattern and a property of the data type have to be considered for implementing the data type using a particular data structure.  The array "arr" in the
source code 105 may be accessed in various ways.  For example, the array may be a read-only array, the values may be retrieved randomly, the values (or key-value pairs) may be retrieved in the order they were inserted, key-value pairs may be written into
the array, the array may grow in size during the lifetime of the program, etc. Accordingly, the data structure used to implement the array is selected based at least on some of the above mentioned factors.
<br/><br/> FIGS. 2A-2C illustrate example implementations of an array, according to an embodiment of the disclosed technique.  The example implementations includes a first implementation 225 of FIG. 2B and a second implementation 250 of FIG. 2C.  An array,
such as array 205 of FIG. 2A, can be implemented using one or both of the example implementations.  The example implementations may be implemented in an environment such as environment 100 of FIG. 1.  The array 205 can be part of a source code, such as
source code 105.
<br/><br/> The array data structure implemented using first implementation 225, includes a data structure 230 that contains a plurality (n+1) of slots of memory, and another data structure 235 that contains a plurality (m+1) of contiguous buckets of
memory.  The data structure 230 can be, for example, a hashtable, and data structure 235 can be, for example, contiguous blocks of memory.  (Henceforth, the data structure with a plurality of slots in the memory is referred to as "hashtable" and the data
structure with a plurality of contiguous buckets of memory is referred to as "ordered container.") In other embodiments, the data structures 230 and 235 can be created using other similar data structures.
<br/><br/> The buckets of the ordered container 235 store key-value pairs 210 of the array 205 in the order in which the key-value pairs 210 are inserted into the array 205.  In an embodiment, the key or value or both may be pre-defined or dynamically
computed.  The slots of the hashtable 230 store pointers that point to the buckets containing the key-value pairs 210.  Each of the slots in the hashtable 230 corresponds to one of the keys of the key-value pairs 210.  When a key-value pair is inserted
into the array 205, (a) a slot corresponding to the key is obtained from the hashtable 230, and (b) a bucket contiguous to the previously filled bucket is obtained from the ordered container 235.  The key-value pair is stored in the retrieved bucket, and
a pointer that points to the retrieved bucket is stored in the slot corresponding to the key.
<br/><br/> For example, consider that a key-value pair of "a, 1" ("a" being the key and "1" being the value) is inserted into the array 205.  Also, consider that the hashtable 230 and the ordered container 235 are null, or empty, that is, they do not
contain any entries.  When the key-value pair "a, 1" is inserted into the array 205, a bucket contiguous to previously filled bucket is obtained from the ordered container 235.  Since there are no key-value pairs in the ordered container 235, "bucket 0"
is retrieved.  A slot corresponding to the key "a" is obtained from the hashtable 230.  In an embodiment, the slot is obtained using a hash function, on the key "a", which evaluates the key to a number.  Consider that the hash function evaluates "a" to
"2." So, "slot 2" is obtained from the hashtable 230.  After obtaining the "bucket 0" and "slot 2", the key-value pair "a,1" is stored in "bucket 0" and pointer to the "bucket 0" is stored in "slot 2."
<br/><br/> Similarly, when a subsequent key-value pair such as "b, 2" is inserted into the array 205, a bucket contiguous to the previously filled bucket, that is, "bucket 1" (which is adjacent to the previously filled bucket "bucket 0") is obtained from
the ordered container 235, and a slot, "slot 0" which corresponds to the key "b" is obtained from the hash table 210.  The key-value pair "b, 2" is stored in "bucket 1" and a pointer to the "bucket 1" is stored in "slot 0." Accordingly, when subsequent
key-value pairs are inserted into the array 205, the key-value pairs 210 are stored in the ordered container 235 in the order they are inserted into the array 205.  In an embodiment, the slots of the hashtable 230 and the buckets of ordered container 235
may be allotted as and when the key-value pairs are added to the array.
<br/><br/> Having a separate data structure, such as the ordered container 235, to store the key-value pairs 210 in the order they are inserted into the array enables the applications to retrieve them in the order they are inserted more efficiently and
without having any additional logic.  In an embodiment, retrieving key-value pairs in the order they are inserted into an array from a data structure that stores them in the order they are inserted is more efficient than retrieving from the data
structures that do not store them in the order they are inserted.
<br/><br/> In the second implementation 250 of FIG. 2C, the key-value pairs 210 are stored in slots of hashtable 255, and pointers to the slots are stored in the ordered container 260.  One of the differences between the two example implementations is
that, the second implementation 250 stores the pointers in the order of the key-value pairs they point to are inserted into the array, whereas the first implementation 225 stores the key-value pairs in the order they were inserted into the array.
<br/><br/> Consider that the hashtable 255 and ordered container 260 have no entries.  When a key-value pair, such as "a, 1" is inserted into the array 205, a slot corresponding to the key "a" is obtained from the hashtable 255.  Consider that a hash
function evaluates "a" to "3." So, "slot 3" is obtained from the hashtable 255.  A bucket that is contiguous to the previously filled bucket, that is, "bucket 0" (since there are no entries in the ordered container 260) is obtained.  The key-value pair
"a, 1" is inserted into "slot 3" of the hashtable 255 and a pointer to "slot 3" is stored in the "bucket 0" of the ordered container 260.  Accordingly, when subsequent key-value pairs are added to the array 205, the key-value pairs are hashed into
corresponding slots of the hashtable 255, and pointers pointing to the key-value pairs are stored in the ordered container 260 in the order in which the key-value pairs are inserted into the array.
<br/><br/> The first implementation 225 and the second implementation 250 provide different benefits in different scenarios.  For example, in a scenario where the key-value pairs 210 are often retrieved in the order they are inserted, using the first
implementation 225 may be beneficial since the values may be obtained by iterating the ordered container 235.  However, if the values in the array 205 are accessed on a random basis, for example, by performing a look-up using a key, at least two reads
may be performed to retrieve the value.  That is, a first read to obtain the slot corresponding to the key and a second read to obtain the key-value pair from the bucket pointed to by the pointer in the slot.  Accordingly, first implementation may
consume more computing resources in scenarios where values are often retrieved on random basis than in the order they were inserted into the array 205.
<br/><br/> In the second implementation 250, a value of a key may obtained in a single read, for example, by performing a look-up in the hashtable 255 using the key.  Accordingly, the second implementation 250 provides a benefit over the first
implementation 225 in scenarios where the values are accessed randomly often.  However, in scenarios where the values are often retrieved in the order they are inserted, the second implementation 250 performs at least two reads--a first read to obtain
the pointer from the ordered store 260 and a second read to obtain the key-value pair from the slot pointed to by the pointer.  Accordingly, the second implementation 250 may not be as efficient compared to the first implementation 225 in scenarios where
the values are retrieved in the order they were inserted.
<br/><br/> FIG. 3 is a block diagram illustrating allocation of memory for an array data structure, according to an embodiment of the disclosed technique.  Memory environment 300 illustrates allocating memory for an array data structure implementing an
array, such as array 205 of FIG. 2.  In an embodiment, the memory may be similar to the memory 120 of environment 100 of FIG. 1.  In the first implementation 225, the array data structure for the array 205 "arr" is implemented using a combination of the
hashtable 230 and the ordered container 235.  The array data structure is allocated a block of memory.
<br/><br/> In a first configuration 305, the block allotted for the array data structure can contain both the hashtable 230 and the ordered container 235 in the same block.  The array data structure has a first pointer "pointer 1" that points to the
hashtable 230 in the block, and a second pointer "pointer 2" that points to the ordered container 235 in the block.  In an embodiment, the pointers stored in the slots of hashtable 230 can be an offset to a bucket the pointer points to.  The offset can
be represented using lesser number of bits than a pointer and thus, reduces the memory space consumed.
<br/><br/> In a second configuration 310, the block 315 allotted for the array data structure includes the hashtable 230 in the same block, but the ordered container 235 is allocated a different block 320.  The first pointer "pointer 1" points to the
hashtable 230 in the block 315, and a second pointer "pointer 2" points to the ordered container 235 in the block 320.  In an embodiment, the pointer stored in the slot of hashtable 230 can be an offset of a bucket the pointer points to.  The offset can
be represented using lesser number of bits than a pointer, which reduces the consumption of memory space.
<br/><br/> In a third configuration 325, the block 330 allotted for the array data structure includes the ordered container 235 in the same block, but the hashtable 230 is allocated a different block 335.  The first pointer "pointer 1" points to the
hashtable 230 in the block 335, and a second pointer "pointer 2" points to the ordered container 235 in the block 330.
<br/><br/> In a fourth configuration 340, both the hashtable 230 and the ordered container 235 are allocated different blocks and outside of the block 345 allotted for the array data structure.  The first pointer "pointer 1" points to the hashtable 230 in
the block 350, and a second pointer "pointer 2" points to the ordered container 235 in the block 355.
<br/><br/> In an embodiment, a particular configuration is chosen based on various factors including, architecture of a computer system the program is executing in, memory allocation techniques of the operating system of the computer system, a size of the
array 205, whether size of the array 205 changes or remains the same during the execution of the program, etc.
<br/><br/> FIG. 4 is a block diagram of a system 400 for implementing an array using one of a plurality of implementations, according to an embodiment of the disclosed technique.  The system 400 can be in an environment such as environment 100 of FIG. 1. 
The specific implementation can be similar to a first implementation 225 or a second implementation 250 of FIGS. 2B and 2C, respectively.  The system 400 includes a processor 405, a memory 410, array usage tracking module 415, an implementation selection
module 420, a data structure creation module 425, an array management module 430 and a storage system 435 that contains details regarding array usage pattern.  Each of the modules co-ordinate with the processor 405 to create and manage the array data
structure.  Of course, in some embodiments arrays could be implemented during execution according to an indicated implementation, depending on the desired application.
<br/><br/> The implementation selection module 415 selects at least one of the first implementation 225 and the second implementation 250 based on criteria including (i) array usage pattern, or (ii) size of an array.  The array tracking module 415 tracks
the array usage pattern or size of the array during the execution of a program containing the array.  The array tracking module 415 generates a report containing information regarding the usage of the array, and stores the report in the storage system
435, such as a database.  The array usage pattern that is tracked can include at least one of (i) whether the array elements are often read in random order, (ii) whether the array elements are often read in the order they are inserted into the array,
(iii) a number of elements/number of times an element is read from the array, (iv) whether the array is a read only array, (v) whether a size of the array changes (increases/decreases) during the lifetime of the array, etc.
<br/><br/> In an embodiment, the implementation selection module 415 selects the first implementation 225 if a frequency of reading the elements of the array in the order they are inserted exceeds a predefined threshold.  The implementation selection
module 415 selects the second implementation 250 if at least one of (i) a frequency of reading the elements of the array in a random order exceeds a predefined threshold, (ii) the number of elements or number of times an element is read from the array
exceeds a predefined threshold, or (iii) the size of the array increases beyond a predefined threshold etc.
<br/><br/> The memory allocation configuration for the array data structure can include one of the four memory allocation configurations of FIG. 3.  In an embodiment, the size of the array helps in determining a particular memory allocation configuration
for the array data structure.  For example, if the size of the array increases continuously, the second configuration 310 may be selected in case of the first implementation 225 or the third configuration 325 may be selected for second implementation
250.
<br/><br/> In an embodiment, the access pattern of the array and the size of the array can be tracked using a script that is executed along with the program containing the array.  The script can generate a report containing the details of the array access
pattern and the size of the array.  Further, the access pattern may be tracked for a predefined number of executions of the program to determine the access pattern of the array more accurately.
<br/><br/> After one of the first implementation 225 and the second implementation 250 is selected by the implementation selection module 420, the data structure creation module 425 creates the array data structure in the memory 410 based on the selected
implementation.  The array management module 430 provides or co-ordinates the read/write access to the array data structure in the memory 410.
<br/><br/> The array data structure created using either of the first implementation 225 or the second implementation 250 supports collision resolution.  A collision may result when two or more keys hash to a single slot in the hashtable.  The collision
resolution techniques determine a free slot in which the key-value pair may be stored.  The collision resolution techniques include chaining, and probing techniques such as linear probing, quadratic probing, cuckoo hashing, double hashing, etc.
<br/><br/> FIG. 5 illustrates a process 500 of implementing an array data structure for an array using a first implementation, according to an embodiment of the disclosed technique.  The process 500 may be executed in an system such as system 400 of FIG.
4.  The first implementation can be similar to the first implementation 225 of FIG. 2.  At step 505, the data structure creation module 425 creates a first data structure having a plurality of contiguous buckets of a memory (also referred to as "ordered
container").  The buckets in the ordered container are configured to store the key-value pairs of the array in the order the key-value pairs are inserted into the array.  For example, the first bucket contains the first key-value pair inserted into the
array, the second bucket contains the second key-value pair inserted into the array and so forth.
<br/><br/> At step 510, the data structure creation module 425 creates a second data structure having a plurality of slots of memory (also referred to as "hashtable").  Each of the slots corresponds to one of the keys of the key-value pairs in the ordered
container, and stores a pointer to the bucket that contains a value of the key to which the slot corresponds.  In an embodiment, a slot corresponding to a key may be determined using a hash function on the key.
<br/><br/> FIG. 6 is a flow diagram of a process 600 for writing a key-value pair of an array into the array data structure implemented using the first implementation, according to an embodiment of the disclosed technique.  The process 600 may be executed
in a system such as system 400 of FIG. 4, and using the array data structure created using process 500 of FIG. 5.  At step 605, upon insertion of a key-value pair into the array, the array management module 430 obtains a bucket from the ordered container
which is contiguous to the previously filled bucket.  At step 610, the array management module 430 obtains a slot from the hashtable which corresponds to the key of the key-value pair inserted into the array.  At step 615, the array management module 430
stores the key-value pair in the bucket.  At step 620, the array management module 430 stores a pointer that points to the bucket, in the slot.
<br/><br/> FIG. 7 is a flow diagram of a process 700 for retrieving key-value pairs of an array in the order they are inserted, in the first implementation, according to an embodiment of the disclosed technique.  The process 700 may be executed in a system
such as system 400 of FIG. 4, and using an array data structure created using process 500 of FIG. 5.  As described in FIG. 3, the array data structure includes both the ordered container and the hashtable.  The array data structure includes pointers to
the hashtable and the ordered container.
<br/><br/> At step 705, the array management module 430 obtains a pointer to the first bucket of the ordered container.  At step 710, the array management module 430 iterates over the non-empty contiguous buckets of the ordered container to retrieve the
key-value pairs in the order they are inserted.
<br/><br/> FIG. 8 is a flow diagram of a process 800 for retrieving key-value pairs of an array in a random order, in the first implementation, according to an embodiment of the disclosed technique.  The process 800 may be executed in a system such as
system 400 of FIG. 4, and using an array data structure created using process 500 of FIG. 5.  At step 805, the array management module 430 obtains a slot of the hashtable corresponding to a specified key for which the value has to be obtained.  In an
embodiment, the array management module 430 obtains the corresponding slot by using a hash function on the key.  At step 810, the array management module 430 obtains a pointer stored in the slot.  The pointer points to a bucket in the ordered container
which has the value (or key-value pair) of the key to which the slot corresponds.  At step 815, the array management module 430 reads the key-value pair from the bucket pointed to by the pointer.
<br/><br/> FIG. 9 illustrates a process 900 of implementing an array data structure for an array using a second implementation, according to an embodiment of the disclosed technique.  The process 900 may be executed in an system such as system 400 of FIG.
4.  The second implementation can be similar to the second implementation 250 of FIG. 2.  At step 905, the data structure creation module 425, creates a hashtable having a plurality of slots.  Each of the slots of the hashtable is configured to store one
of a plurality of key-value pairs of an array.  Each of the slots corresponds to one of the keys of the key-value pairs.  In an embodiment, a slot corresponding to a key may be determined using a hash function on the key.
<br/><br/> At step 910, the data structure creation module 425 creates an ordered container having a plurality of contiguous buckets of a memory.  Each of the buckets in the ordered container is configured to store a pointer that points to one of the slots
of the hashtable.  Further, the buckets are configured to store the pointers in the order in which a key-value pair pointed to by a pointer is inserted into the array.  For example, the first bucket contains a pointer to the slot containing the first
key-value pair inserted into the array, the second bucket contains a pointer to the slot containing the second key-value pair inserted into the array and so forth.
<br/><br/> FIG. 10 is a flow diagram of a process 1000 for writing a key-value pair of an array into the array implemented using the second implementation, according to an embodiment of the disclosed technique.  The process 1000 may be executed in a system
such as system 400 of FIG. 4, and using an array data structure created using process 900 of FIG. 9.  At step 1005, upon insertion of a key-value pair into the array, the array management module 430 obtains a slot from the hashtable of the array data
structure.  The slot corresponds to a key of the inserted key-value pair.  At step 1010, the array management module 430 obtains a bucket which is contiguous to a previously filled bucket from the ordered container.  At step 1015, the key-value pair is
stored in the slot of the hashtable.  At step 1020, a pointer to the slot is stored in the bucket of the ordered container.
<br/><br/> FIG. 11 is a flow diagram of a process 1100 for retrieving key-value pairs of an array in the order they are inserted, using the second implementation, according to an embodiment of the disclosed technique.  The process 1100 may be executed in a
system such as system 400 of FIG. 4, and using an array data structure created using process 900 of FIG. 9.  As described in FIG. 3, the array data structure includes pointers to the hashtable and the ordered container.
<br/><br/> At step 1105, the array management module 430 obtains a pointer to the first bucket (i=0) of the ordered container.  At step 1110, the array management module 430 retrieves a pointer stored in the i.sup.th bucket.  The pointer points to a slot
of the hashtable which contains i.sup.th key-value pair inserted into the array.  (For example, i=0 indicates the first key value pair inserted into the array, i=1 indicates the second value inserted into the array and so forth.) At step 1115, the array
management module 430 retrieves the key-value pair stored in the slot pointed to by the pointer.  At step 1120, the array management module 430 determines whether specified number of key-value pairs are retrieved.  Responsive to a determination that the
specified number of key-value pairs are retrieved, the process 1100 returns.  On the other hand, responsive to a determination that the specified number of key-value pairs are not retrieved, the control is transferred to step 1110, and the array
management module 430 iterates over remaining buckets of the ordered container until the specified number of key-value pairs are retrieved.  In an embodiment, all key-value pairs of the array may be retrieved.
<br/><br/> FIG. 12 is a flow diagram of a process 1200 for retrieving key-value pairs of an array in a random order, using the second implementation, according to an embodiment of the disclosed technique.  The process 1200 may be executed in a system such
as system 400 of FIG. 4, and using an array data structure creating using process 900 of FIG. 9.  At step 1205, the array management module 430 obtains a slot of the hashtable corresponding to a specified key for which the value has to be obtained.  In
an embodiment, the array management module 430 obtains the corresponding slot by using a hash function on the key.  At step 1210, the array management module 430 retrieves the key-value pair stored in the slot of the hashtable.
<br/><br/> FIG. 13 is a flow diagram of a process 1300 for selecting one of a plurality of implementations to implement a data structure of an array, according to an embodiment of the disclosed technique.  The process 1300 may be executed in a system such
as system 400 of FIG. 4.  At step 1305, the data structure creation module 425 receives a request to create an array data structure for an array of a program.  At step 1310, the array usage tracking module 415 retrieves predefined implementation
selection criteria for selecting an implementation from the storage system 435.  The predefined implementation selection criteria include at least one of (a) array usage pattern, or (b) the size of the array.  At determination step 1315, the
implementation module 420 determines whether a first implementation or a second implementation is suitable for the array based on the implementation selection criteria.  At step 1320, responsive to a determination that the first implementation is
suitable, the first implementation is selected.  On the other hand, responsive to a determination that the second implementation is suitable, at step 1325, the second implementation is selected.  At step 1330, the data structure creation module 425
creates the array data structure based on the selected implementation.
<br/><br/> FIG. 14 is a block diagram of an apparatus that may perform various operations, and store various information generated and/or used by such operations, according to an embodiment of the disclosed technique.  The apparatus can represent any
computer or processing system described herein.  The processing system 1400 is a hardware device on which any of the entities, components or services depicted in the examples of FIGS. 1-13 (and any other components described in this specification) can be
implemented, such as a compilation module, runtime module, memory, BLOB, implementation selection module, array usage tracking module, data structure creation module, storage system, etc. The processing system 1400 includes one or more processors 1405
and memory 1410 coupled to an interconnect 1415.  The interconnect 1415 is shown in FIG. 14 as an abstraction that represents any one or more separate physical buses, point to point connections, or both connected by appropriate bridges, adapters, or
controllers.  The interconnect 1415, therefore, may include, for example, a system bus, a Peripheral Component Interconnect (PCI) bus or PCI-Express bus, a HyperTransport or industry standard architecture (ISA) bus, a small computer system interface
(SCSI) bus, a universal serial bus (USB), IIC (I2C) bus, or an Institute of Electrical and Electronics Engineers (IEEE) standard 1394 bus, also called "Firewire".
<br/><br/> The processor(s) 1405 is/are the central processing unit (CPU) of the processing system 1400 and, thus, control the overall operation of the processing system 1400.  In certain embodiments, the processor(s) 1405 accomplish this by executing
software or firmware stored in memory 1410.  The processor(s) 1405 may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific
integrated circuits (ASICs), programmable logic devices (PLDs), trusted platform modules (TPMs), or the like, or a combination of such devices.
<br/><br/> The memory 1410 is or includes the main memory of the processing system 1400.  The memory 1410 represents any form of random access memory (RAM), read-only memory (ROM), flash memory, or the like, or a combination of such devices.  In use, the
memory 1410 may contain a code.  In one embodiment, the code includes a general programming module configured to recognize the general-purpose program received via the computer bus interface, and prepare the general-purpose program for execution at the
processor.  In another embodiment, the general programming module may be implemented using hardware circuitry such as ASICs, PLDs, or field-programmable gate arrays (FPGAs).
<br/><br/> Also connected to the processor(s) 1405 through the interconnect 1415 are a network adapter 1430, a storage device(s) 1420 and I/O device(s) 1425.  The network adapter 1430 provides the processing system 1400 with the ability to communicate with
remote devices, over a network and may be, for example, an Ethernet adapter or Fibre Channel adapter.  The network adapter 1430 may also provide the processing system 1400 with the ability to communicate with other computers within the cluster.  In some
embodiments, the processing system 1400 may use more than one network adapter to deal with the communications within and outside of the cluster separately.
<br/><br/> The I/O device(s) 1425 can include, for example, a keyboard, a mouse or other pointing device, disk drives, printers, a scanner, and other input and/or output devices, including a display device.  The display device can include, for example, a
cathode ray tube (CRT), liquid crystal display (LCD), or some other applicable known or convenient display device.
<br/><br/> The code stored in memory 1410 can be implemented as software and/or firmware to program the processor(s) 1405 to carry out actions described above.  In certain embodiments, such software or firmware may be initially provided to the processing
system 1400 by downloading it from a remote system through the processing system 1400 (e.g., via network adapter 1430).
<br/><br/> The techniques introduced herein can be implemented by, for example, programmable circuitry (e.g., one or more microprocessors) programmed with software and/or firmware, or entirely in special-purpose hardwired (non-programmable) circuitry, or
in a combination of such forms.  Special-purpose hardwired circuitry may be in the form of, for example, one or more ASICs, PLDs, FPGAs, etc.
<br/><br/> Software or firmware for use in implementing the techniques introduced here may be stored on a machine-readable storage medium and may be executed by one or more general-purpose or special-purpose programmable microprocessors.  A
"machine-readable storage medium", as the term is used herein, includes any mechanism that can store information in a form accessible by a machine.
<br/><br/> A machine can also be a server computer, a client computer, a personal computer (PC), a tablet PC, a laptop computer, a set-top box (STB), a personal digital assistant (PDA), a cellular telephone, an iPhone, a Blackberry, a processor, a
telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine.
<br/><br/> A machine-accessible storage medium or a storage device(s) 1420 includes, for example, recordable/non-recordable media (e.g., ROM; RAM; magnetic disk storage media; optical storage media; flash memory devices; etc.), etc., or any combination
thereof.  The storage medium typically may be non-transitory or include a non-transitory device.  In this context, a non-transitory storage medium may include a device that is tangible, meaning that the device has a concrete physical form, although the
device may change its physical state.  Thus, for example, non-transitory refers to a device remaining tangible despite this change in state.
<br/><br/> The term "logic", as used herein, can include, for example, programmable circuitry programmed with specific software and/or firmware, special-purpose hardwired circuitry, or a combination thereof.
<br/><br/><center><b>* * * * *</b></center>
<hr/>
   <center>
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09311348&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D839%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D17%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>
   <table>
   <tbody><tr><td align="center"><a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D839%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D17%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209311348"><img alt="[View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9311348&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D839%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D17%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209311348">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
     <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=839&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=839&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=839&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=18&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=838&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=840&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

   <a href="#top"><img alt="[Top]" border="0" src="/netaicon/PTO/top.gif" valign="middle"/></a>
   </td></tr>
   </tbody></table>
   <a name="bottom"></a>
   <a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
   </center>

</coma></body></html>
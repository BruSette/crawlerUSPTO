<html><head>
<base target="_top"/>
<title>United States Patent: 9356955</title></head>
<!---BUF1=9356955
BUF7=2016
BUF8=91528
BUF9=/1/
BUF51=9
---->
<body bgcolor="#FFFFFF">
<a name="top"></a>
<center>
<img alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" src="/netaicon/PTO/patfthdr.gif"/>
<br/>
<table>
<tbody><tr><td align="center">
<a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
<a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
<a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
</td></tr>
<tr><td align="center">
   <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=402&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=8&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=402&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=9&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=402&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=10&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=401&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=9&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=403&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=9&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

<a href="#bottom"><img alt="[Bottom]" border="0" src="/netaicon/PTO/bottom.gif" valign="middle"/></a>
</td></tr>
   <tr><td align="center">
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D402%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D9%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209356955"><img alt="[
View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9356955&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D402%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D9%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209356955">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09356955&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D402%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D9%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>

   </td></tr>
</tbody></table>
</center>
<table width="100%">
<tbody><tr><td align="left" width="50%"> </td>
<td align="right" valign="bottom" width="50%"><font size="-1">( <strong>402</strong></font> <font size="-2">of</font> <strong><font size="-1">7895</font></strong> <font size="-1">)</font></td></tr></tbody></table>
<hr/>
   <table width="100%">
   <tbody><tr>	<td align="left" width="50%"><b>United States Patent </b></td>
   <td align="right" width="50%"><b>9,356,955</b></td>
   </tr>
     <tr><td align="left" width="50%"><b>
         Belva
 </b>
     </td>
     <td align="right" width="50%"> <b>
     May 31, 2016
</b></td>
     </tr>
     </tbody></table>
       <hr/>
       <font size="+1">Methods for determining cross-site scripting and related vulnerabilities
     in applications
</font><br/>
       <br/><center><b>Abstract</b></center>
       <p> The invention provides computer-implemented methods and computer systems
     for testing applications such as web-based (HTTP) applications for
     cross-site scripting (XSS) and related security vulnerabilities and
     permits the discovery of previously unknown XSS and related
     vulnerabilities in applications without relying on known or previously
     generated static XSS signatures. The invention may be applied to any type
     of XSS or related vulnerability for any variation of application code.
</p>
       <hr/>
<table width="100%"> <tbody><tr> <th align="left" scope="row" valign="top" width="10%">Inventors:</th> <td align="left" width="90%">
 <b>Belva; Kenneth F.</b> (New York, NY) </td> </tr>
<tr><th align="left" scope="row" valign="top" width="10%">Applicant: </th><td align="left" width="90%"> <table> <tbody><tr> <th align="center" scope="column">Name</th> <th align="center" scope="column">City</th> <th align="center" scope="column">State</th> <th align="center" scope="column">Country</th> <th align="center" scope="column">Type</th> </tr> <tr> <td> <b><br/>Belva; Kenneth F.</b> </td><td> <br/>New York </td><td align="center"> <br/>NY </td><td align="center"> <br/>US </td> <td align="left"> </td>
</tr> </tbody></table>
<!-- AANM>
~AANM Belva; Kenneth F.
~AACI New York
~AAST NY
~AACO US
</AANM -->
</td></tr>
<tr> <th align="left" scope="row" valign="top" width="10%">Assignee:</th>
<td align="left" width="90%">

<b>Belva; Kenneth F.</b>
 (New York, 
NY)
<br/>

</td>
</tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Family ID:
       </th><td align="left" width="90%">
       <b>54070283
</b></td></tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Appl. No.:
       </th><td align="left" width="90%">
       <b>14/658,393</b></td></tr>
       <tr><th align="left" scope="row" valign="top" width="10%">Filed:
       </th><td align="left" width="90%">
       <b>March 16, 2015</b></td></tr>
     </tbody></table>
<hr/> <center><b>Prior Publication Data</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Document Identifier</u></b></th><th align="center" scope="col"><b><u>Publication Date</u></b></th></tr><tr><td align="center"> </td><td align="center"> US 20150264082 A1</td><td align="center">Sep 17, 2015</td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table>
<hr/> <center><b>Related U.S. Patent Documents</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col" width="7%"></th><th scope="col"></th><th scope="col"></th> <th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Application Number</u></b></th><th align="center" scope="col"><b><u>Filing Date</u></b></th><th align="center" scope="col"><b><u>Patent Number</u></b></th><th align="center" scope="col"><b><u>Issue Date</u></b></th></tr><tr><td align="center"> </td><td align="center">62126412</td><td align="center">Feb 27, 2015</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"> </td><td align="center">62029625</td><td align="center">Jul 28, 2014</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"> </td><td align="center">61953775</td><td align="center">Mar 15, 2014</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table><td< td=""></td<><td< td=""></td<><td< td=""></td<><td< td=""></td<>     <hr/>
<p> <table width="100%"> <tbody><tr><td align="left" valign="top" width="30%"><b>Current U.S. Class:</b></td> <td align="right" valign="top" width="70%"><b>1/1</b> </td></tr> 
       <tr><td align="left" valign="top" width="30%"><b>Current CPC Class: </b></td>
       <td align="right" valign="top" width="70%">H04L 63/1466 (20130101); H04L 63/1416 (20130101); H04L 67/02 (20130101); G06F 21/577 (20130101); G06F 2221/033 (20130101); H04L 63/1433 (20130101)</td></tr>
         <tr><td align="left" valign="top" width="30%"><b>Current International Class: </b></td>
         <td align="right" valign="top" width="70%">H04L 29/06 (20060101); G06F 21/57 (20130101); H04L 29/08 (20060101)</td></tr>
       <tr><td align="left" valign="top" width="30%"><b>Field of Search: </b></td>
       <td align="right" valign="top" width="70%">
       
 ;726/25
       </td></tr>
     </tbody></table>
</p><hr/><center><b>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=PALL&amp;Query=ref/9356955">[Referenced By]</a></b></center>       <hr/>
       <center><b>U.S. Patent Documents</b></center>
<table width="100%"> <tbody><tr><th scope="col" width="33%"></th> <th scope="col" width="33%"></th> <th scope="col" width="34%"></th></tr> <tr> <td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F8464318">8464318</a></td><td align="left">
June 2013</td><td align="left">
Hallak</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080034425&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0034425</a></td><td align="left">
February 2008</td><td align="left">
Overcash</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110219454&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0219454</a></td><td align="left">
September 2011</td><td align="left">
Lee</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110307389&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0307389</a></td><td align="left">
December 2011</td><td align="left">
Francia</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120011432&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0011432</a></td><td align="left">
January 2012</td><td align="left">
Strutton</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20130111594&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2013/0111594</a></td><td align="left">
May 2013</td><td align="left">
Amit</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20130262626&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2013/0262626</a></td><td align="left">
October 2013</td><td align="left">
Bozek</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20140297666&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2014/0297666</a></td><td align="left">
October 2014</td><td align="left">
Morris</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20140343976&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2014/0343976</a></td><td align="left">
November 2014</td><td align="left">
Ahluwalia</td></tr><tr><td align="left">

</td>
</tr> </tbody></table>
       <i>Primary Examiner:</i> Ho; Dao
<br/>
       <hr/>
       <center><b><i>Parent Case Text</i></b></center>
       <hr/>
       <br/><br/>CROSS-REFERENCE TO RELATED APPLICATIONS
<br/><br/> This application claims the benefit of U.S. provisional application Ser.
     Nos. 62/126,412 filed Feb. 27, 2015, 62/029,625 filed Jul. 28, 2014 and
     61/953,775 filed Mar. 15, 2014, each of which is hereby incorporated by
     reference in its entirety.
         <hr/>
<center><b><i>Claims</i></b></center> <hr/> <br/><br/>What is claimed is: <br/><br/> 1.  A computer-implemented method for testing an application for cross-site scripting vulnerabilities, comprising the steps of: under control of at least one processor, (a)
for at least one field, parameter or Uniform Resource Locator (URL) of the application, submitting a request in which the field, parameter or URL contains a test slug consisting of an encoded or non-encoded test character or a string of test characters
between two default slugs;  (b) determining when the application returns the test slug with the test character or string of test characters and whether any of the test characters in the test slug are transformed or not transformed in the returned test
slug;  (c) storing in non-transitory computer memory the result of the determinations made in step (b);  (d) repeating steps (a)-(c) for a plurality of different test characters or strings of test characters;  (e) generating at least one exploit by
automatically determining the sequence of characters needed to create syntactically executable correct code;  (f) storing the at least one exploit in non-transitory computer memory;  and (g) before steps (a)-(d), (i) for at least one field, parameter or
URL of the application, submitting a request in which the parameter, field or URL contains a default slug not having any special characters;  and (ii) determining when the application reflects the default slug without any transformation of characters in
response to the request, wherein when the application returns the default slug without any transformation of characters, the test slug used in step (a) consists of the encoded or non-encoded test character(s) sandwiched between two default slugs which
are the same or different.
<br/><br/> 2.  The computer-implemented method of claim 1, wherein the test character is a special character or at least one of the test characters of the string of test characters is a special character.
<br/><br/> 3.  A computer system configured to test an application for cross-site scripting vulnerabilities, comprising: at least one processor;  non-transitory processor-accessible memory;  and computer instructions stored in the non-transitory
processor-accessible memory, said computer instructions configured to direct the at least one processor to perform the steps of: (a) for at least one field, parameter or Uniform Resource Locator (URL) of the application, submitting a request in which the
field, parameter or URL contains a test slug consisting of an encoded or non-encoded test character or a string of test characters between two default slugs;  (b) determining when the application returns the test slug with the test character or string of
test characters and whether any of the test characters in the test slug are transformed or not transformed in the returned test slug;  (c) storing in the non-transitory processor-accessible memory the result of the determinations made in step (b);  (d)
repeating steps (a)-(c) for a plurality of different test characters or strings of test characters;  (e) generating at least one exploit by automatically determining the sequence of characters needed to create syntactically executable correct code;  (f)
storing the at least one exploit in the non-transitory processor-accessible memory;  and (g) before steps (a)-(d), (i) for at least one field, parameter or URL of the application, submitting a request in which the parameter, field or URL contains a
default slug not having any special characters;  and (ii) determining when the application reflects the default slug without any transformation of characters in response to the request, wherein when the application returns the default slug without any
transformation of characters, the test slug used in step (a) consists of the encoded or non-encoded test character(s) sandwiched between two default slugs which are the same or different.
<br/><br/> 4.  The computer system of claim 3, wherein the test character is a special character or at least one of the test characters of the string of test characters is a special character.
<br/><br/> 5.  The computer system of claim 3, further comprising: a communication module under control of the at least processor, the communications module configured to provide communication between the computer system and the application to be tested
for cross-site scripting vulnerabilities by the computer system.
<br/><br/> 6.  The computer system of claim 5, wherein the test character is a special character or at least one of the test characters of the string of test characters is a special character. <hr/> <center><b><i>Description</i></b></center> <hr/>
<br/><br/>FIELD OF THE INVENTION
<br/><br/> The invention relates to the field of testing applications for cross-site scripting vulnerabilities.
<br/><br/>BACKGROUND OF THE INVENTION
<br/><br/> Currently, cross-site scripting (XSS) detection tools and programs that check for XSS use signature (or "payload") based methods to determine if such vulnerabilities exist in the webpage of an application.  What this means is that the tool will
take a known signature/payload and use it to determine if XSS exists.  For example, &lt;scri-pt&gt;alert(10)&lt;/scri-pt&gt; is a known test payload for XSS.  Tools will append, replace or commingle this signature/payload to the parameter of a URL or in
the GET/POST and as such: h-t-t-p-://vulnsite.-com/vulnscript.php?vuln=&lt;script&gt;alert(10)&lt;/- script&gt;
<br/><br/> If the signature/payload is returned, the website source is then run through additional tests to determine if the application is deemed vulnerable.  The signature-based steps include: Step 1: Find GET/POST URLs with parameters; Step 2: Append,
replace or commingle parameters with signatures/payloads; Step 3: Make website request; Step 4: Run source code through browser rendering (e.g., with the Xenotix application) or analyze server response codes (e.g., with the wfuzz scanner) to determine if
site is vulnerable; and Step 5: Report Findings.
<br/><br/> A good example of this signature based method is found in the OWASP Xenotix XSS Exploit Framework.  The Xenotix project claims "to have the world's 2nd largest XSS Payloads of about 4800-plus distinctive XSS Payloads for effective XSS
vulnerability detection."
<br/><br/> A second example comes from the security company Edge Security which develops and maintains wfuzz, an open source scanner which includes XSS checks.  This tool also uses a signature/payload--they are called Injections in wfuzz--based method of
discovering XSS injections.
<br/><br/> However, there is a fundamental drawback to these conventional methods, namely, if the exact string does not work (reflect) in the test, the test will fail to detect the vulnerability in the website even though the vulnerability may,
nevertheless, exist.
<br/><br/> What is needed and provided by the present invention are new and improved methods for testing applications for XSS vulnerabilities that are neither based on nor limited by a compendium of XSS signature payloads.
<br/><br/>SUMMARY OF THE INVENTION
<br/><br/> One embodiment of the invention provides a computer-implemented method for testing an application, such as an interactive website, for cross-site scripting vulnerabilities that includes the steps of:
<br/><br/> (a) for at least one field/parameter/URL of the application, submitting a request in which the field/parameter/URL contains a test slug consisting of one or more test characters, which may, for example, include one or more encoded (such as
URL-encoded) or non-encoded (such as ASCII or HTML) special characters, between two default slugs each consisting of non-special characters;
<br/><br/> (b) determining if the application returns (such as reflects) the test slug with the test characters transformed or non-transformed (e.g., encoded or non-encoded) in response to the request;
<br/><br/> (c) recording in tangible computer memory the result of the determination made in step (b); and
<br/><br/> (d) repeating steps (a)-(c) for a plurality of test slugs including different test characters.
<br/><br/> The method may be performed with all character sets, character types and encoding types, for the test slug, without respect to any pre-designation of a character as a special character.
<br/><br/> The method may further include the steps of:
<br/><br/> before steps (a)-(d), for at least one field/parameter/URL of the application, submitting a request in which the field/parameter/URL contains a default slug not having any special characters; and
<br/><br/> determining if the application returns (such as reflects) the default slug in response to the request,
<br/><br/> wherein if the application returns the default slug, the test slug used in step (a) consists of the test character(s) sandwiched between two strings of non-special characters the two strings being the same or different.
<br/><br/> The process may be iterated for each field/parameter/URL/etc. detected in/provided by the application.  URLs and parameters not previously known may but discovered in the testing process may be included in the testing and analysis.  URLs and
parameters may, for example, be generated by a software component, be discovered through implementing certain conditions such as forcing errors in an application, and/or may be imported from other applications.  The method may culminate in the step of
preparing a report such as a spread sheet or document identifying vulnerabilities detected by the method, which report may be stored in a tangible computer memory of a computer system.
<br/><br/> A related embodiment of the invention provides a computer system configured to test an application for cross-site scripting and/or related vulnerabilities that includes:
<br/><br/> at least one processor;
<br/><br/> processor-accessible memory; and
<br/><br/> processor-executable computer instructions stored in the processor-accessible memory, said computer instructions configured to direct the processor to perform the steps any of the methods of the invention.
<br/><br/> The computer system may further a network communication modules such as an Internet communication module under control of the at least processor, for example for communicating over a network such as the Internet with remote applications that are
being tested according to the method(s) of the invention.  For testing of "local" applications, a communications module may not be required since the interaction between the application being tested and the testing system may be implemented/simulated
within the same computer system.
<br/><br/> Other objects and advantages of this invention will become apparent from the following description taken in conjunction with any accompanying drawings wherein are set forth, by way of illustration and example, certain embodiments of this
invention.  Any drawings contained herein constitute a part of this specification and include exemplary embodiments of the present invention and illustrate various objects and features thereof. <br/><br/>BRIEF DESCRIPTION OF THE DRAWINGS
<br/><br/> FIG. 1A illustrates a manner in which default slugs and test slugs may be employed according to the invention in a first scenario.
<br/><br/> FIG. 1B exemplifies a modification of the results obtained in the first scenario in which a submitted special character is not reflected but, instead, other characters are returned.
<br/><br/> FIG. 2A illustrates a manner in which default slugs and test slugs may be employed according to the invention in a second scenario.
<br/><br/> FIG. 2B exemplifies a modification of the results obtained in the second scenario in which two submitted special characters are not reflected but, instead, other characters are returned.
<br/><br/> FIG. 3A illustrates a manner in which default slugs and test slugs may be employed according to the invention in a third scenario.
<br/><br/> FIG. 3B exemplifies a modification of the results obtained in the third scenario in which a submitted special character is not reflected but, instead, other characters are returned.
<br/><br/> FIG. 4 shows sample processor-executable code (computer instructions, Python programming language) for generating a unique slug for each field found in an application.
<br/><br/> FIG. 5 shows a computer system embodiment of the invention configured to test remote target applications via a communications network.
<br/><br/> FIG. 6 shows an exemplary report showing the parsing and exploit generation results obtained by the computer code presented in the Computer Program Listing Appendix.
<br/><br/>DETAILED DESCRIPTION
<br/><br/> The present invention provides new methods and systems for detecting XSS vulnerabilities including but not limited to reflected, in-memory, stored and DOM-based XSS vulnerabilities.  Various embodiments of the invention use character
determination, source code context, source code parsing, source code interpretation and character determination based on parsing and analyzing syntax (of HTML, XML, JSON, etc.) to determine if an application is vulnerable rather than conventional testing
with signatures/payloads as in the above-described prior art methods.  The methods of the present invention may be employed across different technologies--such as, but not limited to, ActiveX, Java, VBScript, Flash--to test where cross-site scripting
attack vectors exist.  The methods of the present invention may be employed as an alternative to and/or in addition to prior methods for detecting XSS vulnerabilities.  Also provided by the invention are methods for creating exploits based on the results
of the XSS vulnerability testing.
<br/><br/> Various URLs and executable computer code are exemplified throughout this disclosure in explaining various aspects of the invention.  In order to comply with the regulations prohibiting presentation of active links and executable computer code
in patent specifications, the various URLs and code presented have been broken up in pertinent locations by the addition of hyphens.  Those skilled in the art will readily recognize that the text so-modified refers to the corresponding unmodified text
(without the hyphens).
<br/><br/> Overview of Application Testing Methods
<br/><br/> In order to find instances of XSS according to the invention, including without limitation Stored XSS, the methods and system of the invention track where the data goes into the application and where it comes out.  This may be done by creating a
unique slug (character string) for every field and submitting these slugs to the application.  In one case the slug is an MD5 check sum but it could be any unique string identifying the field.  If the application accepts the slug assigned to the field,
the slug will either come out immediately (Reflected XSS), stay in memory and be displayed on another page (InMemory XSS/ReflectedStored XSS, hereafter referred to as InMemory) or stored in the database and be subsequently displayed either on the current
page or a different page (Stored XSS), or in another process, such as email.  It is also possible for the slug to be referenced in the DOM when returned (DOM XSS).  It is possible for all of these conditions to occur separately, at once or in any
combination thereof.
<br/><br/> A spider (spidering application), one example of a software component, is not necessary if one is testing a specific page.  The more thorough the test is desired or necessary, the more spidering is necessary.  Spidering is the gathering of links
via HTML/AJAX/etc. and then calling each link to see what data is returned.  Entry points into the application (parameters of the application) may be found by spidering the website (HTML/AJAX/Etc.) in addition to known possible entry points such as HTTP
headers including cookies or entry points discovered dynamically.  In one method, fields may URL specific, not (global) by name.  That is, the field "p" is a different parameter for the two URLs below: h-t-t-p-://site.-com/1/?p=1 and
h-t-t-p-://site.-com/2/?p=1
<br/><br/> Spidering is just one technique that may be employed to obtain the urls and parameters of an application.  Obtaining (determining) these fields in an application may be also performed by other methods such as, but not limited to, by using a
piece of software known as a proxy in the art or "manually imported", e.g., by inspection, selection and copying of a URL.  The obtained URLs/field/parameters may be stored in tangible processor-accessible memory in a data structure such as a database
and retrieved as needed by a processor having access to the memory under the control of computer instructions (stored in tangible processor-accessible memory) that are configured to direct the processor to carry out the application testing method(s)
and/or XSS testing method(s) of the invention.  Spidering may be conducted as an unauthenticated, authenticated user or both.  If spidering is conducted as two or more different authenticated users, it may be determined if the data submitted by one user
is accessed by another user.  Spidering may be performed with different users (user profiles) with different access levels, for example in a process of privilege escalation, thereby testing for attacks from one level of access against a different level
of access or against the same level of access.  For example, in this manner, it can be determined if an attack by a lower level user can be run against a user at a higher level and vice versa.  If spidering is performed, spidering at different times in
the process may lead to different levels of validation for discovering data loading.  Spidering may be repeated at various points in the process of determining data entry points since the data loaded may create new URLs to discover.  The slugs may then
be submitted to those URLs (header, cookies, parameters, etc.), particular slugs being assigned to and submitted to their respective unique fields.  The resulting output can be immediately checked (or later checked) for reflected values.  Using the same
session, one may spider again for slugs that may be in memory but not stored.  Further, session information may then be cleared and spidering performed again to find the slugs stored in the application.  Any session or combination thereof may be used to
test for just Reflected or Stored XSS.
<br/><br/> One or more or all of the following spidering methods may be used: 1.  Spidering without authentication as same user (Reflected, DOM &amp; InMemory/Slugs); 2.  Spidering with authentication as same user (Reflected, DOM, InMemory &amp; Stored Slugs); and
3.  Spidering with authentication as more than 1 user (Reflected, DOM, InMemory &amp; Stored Slugs) Spidering may be performed with one, two or more user profiles at once.  It is not restricted to one or two at a time.
<br/><br/> For spidering without authentication as same user (Reflected, DOM &amp; InMemory Tokens), the method steps may, for example, include: 1.  Spider website to get URLs test; 2.  Perform data tracing and check each page return (Reflected &amp; DOM); and 3. 
Re-spider to find submitted tokens (InMemory of server).  If the spidering examines reflected XSS or DOM-based XSS then a session cookie (token) is optional but with if spidering examines in-memory situations, the same-session token must be used when
spidering.  (DOM refers to memory of the browser/client computer, in-memory refers to memory, such as session variables, and/or the way session data is handled by the server/target application system for a given state.)
<br/><br/> For spidering with authentication as same user (Reflected, DOM, InMemory &amp; Stored Slugs), the method steps may, for example, include: 1.  Authenticate and Save Cookie; 2.  Spider website to get URLs test; 3.  Perform data tracing and check each
page return (Reflected &amp; DOM); 4.  Re-spider to find and save submitted slugs (InMemory); 5.  Clear Cookies/Log out of application; 6.  Re-Authenticate and Save Cookie; and 7.  Re-Spider to find and save persistent/saved slugs (Stored).
<br/><br/> For spidering with authentication as more than one user (Reflected, DOM, InMemory &amp; Stored Slugs), the method steps may, for example, include: 1.  Authenticate and Save Cookie for User 1; 2.  Authenticate and Save Cookie for User 2; 3.  Spider
website to get URLs test as User 1; 4.  Spider website to get URLs test as User 2; 5.  Perform data tracing and check each page return as User 1 (Reflected &amp; DOM); 6.  Re-spider to find and save submitted slugs as User 1 (InMemory); 7.  Re-spider to find
and save submitted slugs as User 2 (InMemory); 8.  Clear Cookies/Log out of application as User 1; 9.  Clear Cookies/Log out of application as User 2; 10.  Re-Authenticate and Save Cookie as User 1; 11.  Re-Authenticate and Save Cookie as User 2; 12. 
Re-spider to find and save persistent/saved slugs as User 1 (Stored); and 13.  Re-spider to find and save persistent/saved slugs as User 2 (Stored).
<br/><br/> Various combinations of application parameters (URLs etc.) and their associated slugs may be generated by software components such as system plug-ins for attempted loading into the application to be tested.  The generation of application
parameters may include creating new combinations of parameters and associated values that may not be found by default on the website through techniques such as spidering.  In one method, all application parameter loading techniques use the same slug for
the field.  In another method, each loading technique uses a unique slug for that field and that load method.  The latter variation will help testing later on but is not a requirement.  These processes are not fuzzing in the traditional sense.  For
example, in traditional fuzzing, it is usually the value of the parameter that changes in order to find a vulnerability.  By contrast, in this step of the invention, the focus is on loading data into the application, and tracing it, to find potential XSS
entry points.  According to the present invention, one may change one or many values or none at all--and different combinations of parameters that differ in number and value from the originals may be used, for example, in an automated process, in order
to determine which data will be accepted by the application and be reflected, in-memory, stored or referenced in the DOM.  For example, one may submit: h-t-t-p-://site.-com/?parm1=[slug]&amp;parm2=[slug] h-t-t-p-://site.-com/?parm1=[slug]
h-t-t-p-://site.-com/?parm2=[slug] h-t-t-p-://site.-com/?parm1=[slug]&amp;parm2=[blank] h-t-t-p-://site.-com/?parm1=[blank]&amp;parm2=[slug] h-t-t-p-://site.-com/?parm1=[slug]&amp;parm2=[original data] h-t-t-p-://site.-com/?parm1=[original data]&amp;parm2=[slug] These
variations are not considered fuzzing in the art.  In addition, the application may alter the values of the parameters based on known accepted values in order to create conditions which trigger the application to accept the test slug or display XSS
behavior.  URLs may, for example, be generated, discovered or imported from other applications.  New URLs that may not be discoverable by spidering may be discoverable based on those tested, for example, by forcing an error to occur in the application. 
URL data may, for example, also be obtained from existing applications or user supplied data, such as zap, burp and URL lists.
<br/><br/> A URL may or may not have parameters.  Accordingly, slugs may also be placed in the URL itself rather than or in addition to being assigned to a parameter.  For example, a slug may be placed in a URL as shown below:
h-t-t-p-://vulnsite-.-com/[slug]/url1/ h-t-t-p-://vulnsite-.-com/[slug]/url2/?parm=1234
<br/><br/> Thus, default slugs may be loaded into a target application via parameters/fields/URLs, etc. and incidences in which the default slug has been returned (reflected, stored in-memory, in DOM etc.) may be detected and stored in the
processor-accessible memory of the testing system including, for example, the context in which (where) the returned default slug occurs and the syntax in which it occurs, i.e., what specific characters surround the returned default slug.  The computer
systems and computer-implemented methods of the invention may automatically parse out and store in computer memory the context and/or syntax information for the returned default slugs, for example, using one of the following methods:
<br/><br/> A first method including the following steps may be used: 1.  HTML with returned default slug is found 2.  The HTML and slug are used by the regex object/function to determine which characters are needed to pass through the filter to create
executable HTML code (i.e., what is missing) 3.  Regex is used to parse the HTML syntax and determine the characters needed and the order.  While different RegExs may be used in this case it may be: matches=re.findall(`&lt;.*?&gt;`, HTMLfull) where
HTMLfull is a variable.  4.  Finding/determining just the characters needed to be in front of the exploit, all characters in the HTML (including characters after exploit), and/or additional characters that may be added or needed to create syntactically
correct HTML (a putative exploit).  5.  (XSS Testing--see next section) The characters are then tested by loading test slugs that present the test characters between two default slugs.  Assuming the characters necessary to create executable code pass
through any filter and are returned, an exploit string can be dynamically built.  In this manner, the exploit string can be built based on characters that pass through the filter, not blindly.  A person skilled in the art will recognize that using RegEx
is one method to select characters and other techniques may also be used.
<br/><br/> A second method, including the following steps may be used: 1.  HTML with returned default slug is found 2.  Context is used to determine which exploit to run 3.  The HTML &amp; slug and/or exploit are used by the regex object/function to determine
which characters are needed to pass through the filter 4.  Regex is used to parse the HTML syntax and determine the characters needed and the order.  While different RegExs may be used in the case it's: matches=re.findall(`&lt;.*?&gt;`, HTMLfull) where
HTMLfull is a variable.  5.  Finding/determining just the characters needed to be in front of the exploit, all characters in the HTML (including characters after exploit), and/or additional characters that may be added or needed by the exploit 6.  (XSS
Testing--see next section) The characters may then tested by loading test slugs that present the test characters between two default slugs.  Assuming the characters necessary to create executable code pass through any filter and are returned, an exploit
string can be dynamically built.  In this manner, the exploit string can be built based on characters that pass through the filter, not blindly.  A person skilled in the art will recognize that using RegEx is one method to select characters and other
techniques may also be used.
<br/><br/> The Computer Program Listing Appendix presented at the end of this disclosure exemplifies computer code configured to parse out the syntax (such as special characters) surrounding a returned default slug and determine which characters may be
added in order to build an executable piece of code, i.e., an exploit.  In the exemplified computer code, different algorithms are used to build different exploit strings.  FIG. 6 shows an exemplary report showing the parsing and exploit generation
results obtained by the program.
<br/><br/> Overview of XSS Testing Method
<br/><br/> Once all default slugs are mapped--where they entered and exit the application--one can then start testing to see which characters (or other data such as strings and exploits) pass through the application filter.  The same method used to load
the default slug into the application may be used to test which different characters (and combinations thereof and subsequently created exploits based thereon) can pass the application's filter.  The method(s) and parameters used to load the slug into
the application (in the application testing steps) may be stored in computer accessible memory, for example, in a data structure, such as database, such as a relational database, so that a computer processor under direction of computer instructions
stored in tangible computer-accessible memory can retrieve that data, modify it to create tests slugs that include additional characters such as special characters and submit the modified slugs to the application being tested.  As explained in further
detail below, the test slugs for a field/parameter may consist of the character(s) to be tested in the middle of (sandwiched by) a first slug and a second slug, which slugs were found to be returned for the given field/parameter in the application
testing phase.  The first slug and second slug may be identical or non-identical strings.
<br/><br/> Since the test slugs created encompass unique strings, one can test not only which specific characters pass the filter but also what strings of characters pass the filter.  This aspect of the invention is advantageous for testing unique exploits
for a particular piece of browser-interpretable code such as HTML or a scripting language such as JavaScript, and VBscript or internal data structure such as for Document Object Model (DOM)-based XSS.
<br/><br/> One method that may be used to test for slugs and exploits is to use XPATH to parse the HTML looking for the specific test slugs (unique strings).  Other parsing methods, including known parsers and/or custom developed functions, may also be
used for a given type of data or code, such as HTML, XML, JSON.
<br/><br/> As the returned slugs are collected/discovered, the context of where the slug is returned (exists)--for example Script, Attribute, text, comments, etc.--is determined and recorded in memory This information may be used to optimize the XSS
testing since, at least in some cases, it can be used to minimize the number of characters or strings e.g., pieces of code such as HTML or scripting language--that need to tested instead of testing all of them.  In general, the context in which a
returned slug is seen including, for example, as observed via parsing and analyzing its occurrence in syntax situations (of HTML, XML, JSON, etc.) may be determined and recorded in memory.
<br/><br/> In one variation, the relevant pieces of code or data, such as HTML, XML, JavaScript, VBscript, JSON, DOM information etc., are recorded and/or saved, as the returned slugs are found, so that they can be provided in a report and/or referred to
later for example, in order to create and test exploits based on the information.  Once it is determined the where the test slug occurs in the code or data, the part containing the slug may be parsed to determine which characters pass through the
filter--for a given piece of the code or data.  It is also possible that unique strings--such as "script" or "&lt;script"--will be rejected even though each character can pass through the filter, and this determination may be made using the methods of
the invention.  As described in detail below, a method of building and testing unique XSS strings may be applied in these situations.
<br/><br/> Overview of Exploit Creation Methods
<br/><br/> Once the characters and/or strings that pass through the filter of the tested application are determined using the XSS testing methods of the invention, a determination of which exploits will work for the Javascript/Vbscript, piece of HTML, etc.
may be made based on that information.
<br/><br/> As explained in further detail below, variations of different exploits may be created based on the results obtained from the XSS character and string testing.  The methods of the invention are able to generate exploits de novo without any
guidance provided by knowledge of known exploits.  However, since the formats of many typical exploits are known in the art, this information may also be used, in addition or alternatively, as a foundation for generating the exploits.  In one variation,
this information can be stored/recorded ahead of time.  In another variation, the exploit must be created dynamically based on the specific way the application generates its output during the XSS testing.  The XSS testing method provides information that
is helpful for generating both exploit strings that are based on/resemble known exploits and those that are not.  While the method of the invention is able to (and may be used to) generate all exploits dynamically, it is sometimes helpful to store and/or
refer to known issues for optimization purposes.  Once a working exploit is created through these methods, it may be used in additional programs for testing and validation, which may include methods such as but not limited to in and out of band
callbacks, and processes such as but not limited to DOM abstraction.  In addition, the code may be analyzed in an in-sandbox and/or out-of-sandbox manner.
<br/><br/> Various aspects and embodiments of the invention are further described herein below.
<br/><br/> In one embodiment, the invention provides computer-implemented methods and computer systems for testing a target application for cross-site scripting and related vulnerabilities that includes any one of combination of or all of the following
component methods or computer system modules configured to perform the methods: 1.  Determining fields/parameters/URLs of target application; 2.  Slug assignment; 3.  XSS testing methods; 4.  Transformation/non-transformation determination; and 5. 
Exploit generation methods.  The methods of the invention may further include generating a vulnerability report based on the results of the testing and the computer systems of the invention may further include a report generation module for generating
such a report which may be output on one or more output devices such as a display, a printer or an email, web or file server.
<br/><br/> The following XSS test methods may be used according to the invention: 1.  Brute force (testing every possible character/string between default slugs); 2.  Character by context; 3.  Character by context and tag (external Javascript); and 4. 
Character by parsing and analyzing HTML/XML/JSON/etc syntax 5.  Character by context and syntax
<br/><br/> The invention may also include character transformation/non-transformation determination steps.  These methods determine how the characters, strings or exploits are transformed by the application that is tested.  For example, does the
application transform &gt; to &gt;.
<br/><br/> In one embodiment, the invention includes the steps of:
<br/><br/> 1.  Finding GET/POST URLs with parameters
<br/><br/> 2.  Replacing parameters with a Default Slug value (such as the regular character string 9b1e3f)
<br/><br/> 3.  Making a website request (with the parameter replaced with default slug 9b1e3f)
<br/><br/> 4.  Examining the returned Source code to determine if Default Slug was returned
<br/><br/> 5.  If the default slug was not returned, the parameter is not vulnerable to XSS
<br/><br/> 6.  If the slug is returned, determining the context and/or syntax of where the slug is returned, e.g., where and how in the source code it occurs
<br/><br/> 7.  From the context and/or syntax, determining the checks to be performed.
<br/><br/> 8.  Instead of checking signatures, testing if specific characters (the "test characters") such as special characters are able to get though the web application filter for the context where the slug is returned.
<br/><br/> 9.  Padding the test character(s) such as XSS special characters, between two default slug values (which could be already generated), for example, 9b1e3f;9b1e3f, to create a "new special character slug".
<br/><br/> 10.  Replacing the desired parameter to be tested with the new special character slug.
<br/><br/> 11.  Requesting webpages over and over with a new special character slug test for each special character (or combination thereof) to be tested.  Sometimes, the test may be optimized or streamlined by reducing the size of the set of special
characters (or combinations thereof) to be tested because certain characters are only needed or relevant in certain contexts but not others and/or syntax parsing reveals which select characters need to be tested.
<br/><br/> 12.  For each special character slug, examining the source to determine if the entire slug is returned (such as 9b1e3f;9b1e3f); if it is we know that we can get the special character (or combination thereof) through the filter, otherwise the
character is filtered.
<br/><br/> 13.  Based on the characters passed through the filter and the context of the slug, determining if the website is vulnerable to XSS or not and, importantly, characterizing the vulnerabilities that may be present.
<br/><br/> Further testing may be performed by parsing the source where the original slug returned and determining the exact characters needed to be returned by the test character-containing (such as special character-containing) slug.  If all the
characters needed are returned for a particular context/syntax it has been determined with near certainty that a vulnerability exists.
<br/><br/> Since the method provides a determination of which characters are needed to write an exploit to take advantage of the vulnerability, additional automated tests may be conducted--such as filter testing with additional slugged strings, automated
signature/payload/injection/exploit writing and running the source code through browser rendering--to further accurately determine the true risk that is present.  Sandboxing, may, for example, be used for validation.
<br/><br/> The method looks for and characterizes reflected values--that is, slug data that is submitted to an application and is returned back.  Accordingly, in one implementation, the method may begin by first determining if the application will return
back data submitted to it (e.g., in a webpage) in the first place.  If so, the location of where the data is returned in the webpage may be determined and recorded by the application (for example, recorded in a data structure such as a database in the
processor-accessible memory of the testing system).  In this manner the context of reflected data is determined.  Reflected data may occur in multiple spots at the same time and different further tests may need to be run for each context.  From this
context-based analysis, it is determined where the vulnerabilities may exist in the application and where to run tests specific to these contexts.  Each context has specific characters which if returned constitute the core logical component of the
vulnerability.  For example, if the reflected data winds up in the context of JavaScript tags, the application may be vulnerable if specific characters are passed through the filter and are returned to us.  Even within the context of the JavaScript tags,
we may find that certain characters are needed but not others.  These characters may be different than those needed if the reflected data is returned in the HTML component of a webpage.  In contrast to the present invention, signature-based methods are
severely limited because they cannot account for each situation in view of the high degree of variation that is possible.  The methods of the present invention inquire into vastly more, if not all, possibilities and, therefore, are more accurate. 
Furthermore, once it is determined according to the methods of the invention which characters will reflect (getting through a filter), the invention may include further steps of dynamically building and testing for all strings that will execute XSS and
bypass the filter.
<br/><br/> These context and/or syntax tests determine which special characters returned indicate a vulnerability.  Specific analysis of the context and/or HTML/XML/JSON/etc. syntax can determine which exact characters are needed to be returned to make the
site vulnerable to XSS.  By testing which characters are returned, it is determined which pass through the filter.  If the application returns certain special characters submitted within a specific context and/or HTML/XML/JSON/etc. syntax, one will know
there is a vulnerability in the application.  Using this method, it is not necessary to know ahead of time which signature to use because every vulnerability instance can be uniquely tested to determine if a XSS vulnerability exists in the application.
<br/><br/> Special characters may include those recognized in the art, such as those shown in Table 1.
<br/><br/> TABLE-US-00001 TABLE 1 URL- Special Encoded Known XSS Character Version Character Name Character? ~ %7E Tilde ! %21 Exclamation point @ %40 At sign # %23 Pound sign $ %24 Dollar sign % %25 Percent sign {circumflex over ( )} %5E Exponential sign
(hat) &amp; %26 Ampersand Yes * %2A Asterisk ( %28 Open parenthesis ) %29 Closed parenthesis _ %5F Underscore + %2B Plus sign ` %91 Single quote - %2D Minus sign = %3D Equal sign [ %5B Left bracket ] %5D Right bracket \ %5C Back slash { %7B Left brace } %7D
Right brace | %7C Vertical Bar ; %3B Semicolon : %3A Colon ` %27 Single quotation mark Yes " %22 Double quotation mark Yes , %2C Comma .  %2E Period / %2F Forward slash Yes &lt; %3C Less than sign Yes &gt; %3E Greater than sign Yes ? %3F Question mark
<br/><br/> The special characters indicated as known XSS characters in the table are those most commonly needed for XSS but they are not necessarily required.  Different contexts and/or HTML/XML/JSON/etc. syntax for the testing, such as different type of
fields and parameters, may call for different special characters or combinations thereof to be tested.  For example, in a normal case, one might need three characters such as &lt; &gt; " whereas in another context one may need different characters such
as " ) { and }.  Advantageously, the testing methods of the present invention illuminate which characters are associated with and give rise to vulnerabilities without predicating the analysis on assumptions.
<br/><br/> In one example of how the invention can provide particularized information about vulnerabilities and application filters, there may be cases in which &lt; is reflected and &gt; is reflected but &lt;script&gt; or &lt; followed by any character is
not reflected.  The invention characterizes these situations and further tests may be performed according to invention to determine the additional filters at work.
<br/><br/> Implementations with Encoded and Non-Encoded Characters
<br/><br/> The method of the invention may also test the application being evaluated for potential vulnerabilities to see if it automatically converts submitted three character codes for special characters ("encoded characters") into the special character
so that the special characters themselves (non-encoded) are reflected or the three character code is reflected.  For example, in a process embodying this aspect, a first step may include submitting as a field/parameter a string such as a default slug
with encoded regular (non-special) characters only (%39%62%31%65%33%66) and determining whether what may be reflected remains encoded or is converted to the non-encoded characters (9b1e3f).  If is found that the application, such as server application,
does not convert encoded special characters, the remaining steps of the process can proceed as described before by submitting padded slugs having non-encoded special characters and determining if and where they are reflected.  On the other hand, if it is
found that the application, such as server application, does convert encoded special characters to return the corresponding non-encoded characters, the process may proceed by submitting padded slugs having the encoded characters (such as 9b1e3f%279b1e3f
in which %27 is the URL encoding for the non-encoded single quotation mark character), with or without also separately submitting padded slugs having the non-encoded characters, and in each case determining if and where they are reflected.  While the
first step will help the application make decisions later on, it may be advantageous to test characters and strings as both the encoded and non-encoded independently of the first step.
<br/><br/> Use of Unique Slugs for Each Field/Parameter/URL
<br/><br/> In one variation of the invention, unique data slugs can be used to mark where the data enters (which field/parameter) in the application and where it leaves the application (outputted HTML, JavaScript, etc.).  Thus, a different unique slug may
be used for each field/parameter in an application being tested for vulnerabilities according to the invention.  These unique slugs may be strings that may be composed of characters (e.g., TESTSLUG), encoded data, hashes (e.g.,
d8e8fca2dc0f896fd7cb4cb0031ba249) or numbers (e.g., 9876543210).  The slug may be any length that causes a unique pattern that may be recognized by the testing application.  Examples of where the application could store the slug could be in memory,
defined data structure, on disc or in a database.  Thus, according to the invention, unique data slugs may be used for each different field/parameter presented by an application so that reflection(s) resulting from particular field/parameters can be
traced and tracked and correctly attributed.  This method, even employed alone without special characters (one embodiment of the invention), provides very valuable information.  All filters may be further tested up and down the stack--for example, the
application filter and the database filter--for specific characters such as the special characters, between two slugs.  In this manner, the returned slug behavior and XSS vulnerabilities associated with each data entry point can be individually
determined and a record made thereof.
<br/><br/> It should be understood that the invention may be employed in various different contexts and situations in which data (including slugs) can be "reflected/outputted" directly or indirectly and immediately or in a delayed fashion and, thus,
generally whenever data is submitted to an application and will be later outputted to another application (such as a web browser on a client device) either in modified or unmodified form.  For example, the invention may be employed in relation to script
tags, reference tags, direct html, DOM, CSS, stored data/stored XSS, in-memory xss, etc. It may, for example, be employed with Stored XSS (a/k/a Persistent or Type I), with Reflected XSS (a/k/a Non-Persistent or Type II) and with DOM-based XSS (a/k/a
Type-0).  It may also be employed in situations of InMemory XSS.  Thus, for example, in one scenario, the methods and systems of the invention may be employed to test for vulnerabilities in a situation in which a web browser of a user makes requests to a
web server which immediately returns data to the user's browser (and may not save any field/parameter data that may be received from the user (user device) and reflected back to the user).  The methods and system of the invention may also be used to test
whether malicious code can be inserted from a first user's data when they use their web browser (or web-enabled application generally) to enter data to be saved in a database for later download by themselves or by other web users, such as in the case of
updating profile data/fields on a social network profile page of the user, such as a <b><i>Facebook</i></b> profile page, which data is saved in a database by the social network to be later served to (downloaded by) users of the social network.  The methods and
systems of the invention may be also employed to test situations where the data submitted is inputted into the application and returns on a different page then where submitted due to it being stored in the memory of the server for the session (InMemory
XSS).  The methods and systems of invention may also be employed to test for DOM-based XSS vulnerabilities involving data that is not submitted to a server but remains in local/client/browser memory and is referenced in or by the DOM.
<br/><br/> FIG. 1A illustrates the manner in which default and test slugs may be employed in a first scenario, an HTML attribute tag, in which the href parameter of a link (note double quotation marks surrounding parameter) is first replaced by a default
slug 9b1e3f (which passes, i.e., is reflected), then by a sequence of padded test slugs containing the non-encoded special characters &lt; &gt; and / each of which passes (is reflected) in this example.  From such a test, it is determined that the
application is vulnerable with respect to the special characters &lt; &gt; and / for the context of the first scenario.  Finally, an example of "Attacker's Code" based on the test results and for which the application is susceptible is shown.  FIG. 1B
exemplifies a modification of the results obtained in the first scenario in which a submitted special character &gt; is not reflected but, instead, transformed into other characters (the HTML multi-character code therefore) are returned.
<br/><br/> FIG. 2A illustrates the manner in which default and test slugs may be employed in a second scenario, an HTML attribute tag that includes malformed HTML, i.e. single quotation marks surrounding the parameter rather than double quotes (as shown in
FIG. 1A), in which the href parameter of a link is first replaced by a default slug 9b1e3f (which passes, i.e., is reflected), then by a sequence of padded test slugs containing the non-encoded special characters &lt; &gt; and / each of which passes (is
reflected) in this example.  From such a test, it is determined that the application is vulnerable with respect to the special characters &lt; &gt; and / for the context of the first scenario.  Finally, an example of "Attacker's Code" based on the test
results and for which the application is susceptible is shown.  FIG. 2B exemplifies a modification of the results obtained in the second scenario in which two submitted special characters ` and &gt; are not reflected but, instead, other characters (the
HTML multi-character code therefor) are returned.
<br/><br/> FIG. 3A illustrates the manner in which default and test slugs may be employed in a third scenario, in the HTML body with the subject parameter bounded by &gt; and &lt; and being first replaced by a default slug 9b1e3f and then by a sequence of
padded test slugs containing the non-encoded special characters &lt; &gt; and / each of the padded test slugs passing (being reflected) in this example.  Finally, an example of "Attacker's Code" based on the test results and for which the application is
susceptible is shown.  FIG. 3B exemplifies a modification of the results obtained in the first scenario in which a submitted special character &gt; is not reflected but, instead, other characters (the HTML multi-character code therefor) are returned.
<br/><br/>EXAMPLES
<br/><br/>Generation, Assignment and Submission of Unique Slugs for Different Application Parameters/Fields
<br/><br/> The following three slug assignment methods may, for example, be used according to the invention: 1.  one field; 2.  algorithm-based (field same slug); and 3.  algorithm-based (same field name different slug by URL).
<br/><br/> One Field Slug Assignment
<br/><br/> The generation, assignment and submission of unique slugs to each of an application's parameters/fields may be performed according to the following seven step process, exemplified in the following examples:
<br/><br/> Step 1: Get URL.  Step 2: Get URL parameters and values Step 3: Save URL parameters and values Step 4: For each parameter, generate md5checksum or modified length md5checksum Step 5: Assign the md5checksum or modified length md5checksum to the
parameter Step 6: Save assignment Step 7: Load slug into application through different/variety of GET, POST, Cookie, HEADER methods (whatever entry point(s) is/are applicable).
<br/><br/> GET Method Example 1
<br/><br/> Step 1: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLtext=HTML2n- dtext&amp;HTMLtext=HTMLtext&amp;HTMLa ttDQ=HTMLattDQ&amp;HTMLattSQ=HTMLattSQ&amp;scriptattr=scriptattr&amp;scripttag=script- tag
<br/><br/> Steps 2 and 3:
<br/><br/> HTMLtext=HTML2ndtext
<br/><br/> Step 4:
<br/><br/> 2f6b4e8
<br/><br/> Steps 5 and 6: HTMLtext=2f6b4e8
<br/><br/> Step 7: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLattDQ=2f6b4- e8&amp;HTMLattSQ=HTMLattSQ&amp;HTMLt ext=HTML2ndtext&amp;scriptattr=scriptattr&amp;scripttag=scripttag
<br/><br/> GET Method Example 2
<br/><br/> Step 1: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLtext=HTML2n- dtext&amp;HTMLtext=HTMLtext&amp;HTMLa ttDQ=HTMLattDQ&amp;HTMLattSQ=HTMLattSQ&amp;scriptattr=scriptattr&amp;scripttag=script- tag
<br/><br/> Step 2 and 3: HTMLattSQ=HTMLattSQ
<br/><br/> Step 4: 78752ef
<br/><br/> Steps 5 and 6: HTMLattSQ=78752ef
<br/><br/> Step 7: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLattSQ=78752- ef&amp;HTMLattDQ=HTMLattDQ&amp;HTMLt ext=HTML2ndtext&amp;scriptattr=scriptattr&amp;scripttag=scripttag
<br/><br/> POST Method Example (Parameters are Parsed from HTML Form Tags)
<br/><br/> Step 1: h-t-t-p-://192.168.56.103/testScripts/reflect.php
<br/><br/> Steps 2 and 3: HTMLattSQ=HTMLattSQ
<br/><br/> Step 4: 78752ef
<br/><br/> Steps 5 and 6: HTMLattSQ=78752ef
<br/><br/> Step 7: h-t-t-p-://192.168.56.103/testScripts/reflect.php {u'post-data': {u'HTMLattDQ': u'', u'HTMLtext': u'', u'scripttag': u'', u'scriptattr': u'', u'HTMLattSQ': u'78752ef}}
<br/><br/> For the following original URL, examples are provided thereafter of URL-tested (URL-slugged versions) generated and submitted.
<br/><br/> Original URL: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLtext=HTML2ndtext&amp;HT- MLtext=HTMLtext&amp;HTMLa ttDQ=HTMLattDQ&amp;HTMLattSQ=HTMLattSQ&amp;scriptattr=scriptattr&amp;scripttag=script- tag
<br/><br/> URL Tested (URL-slugged) 1: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLattDQ=2f6b4e8&amp;HTMLa- ttSQ=HTMLattSQ&amp;HTMLt ext=HTML2ndtext&amp;scriptattr=scriptattr&amp;scripttag=scripttag
<br/><br/> URL Tested (URL-slugged) 2: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLattSQ=78752ef&amp;HTMLa- ttDQ=HTMLattDQ&amp;HTMLt ext=HTML2ndtext&amp;scriptattr=scriptattr&amp;scripttag=scripttag
<br/><br/> URL Tested (URL-slugged) 3: h-t-t-p-://192.168.56.103/testScripts/reflect.php?scriptattr=4a05a46&amp;HTML- attDQ=HTMLattDQ&amp;HTMLattS Q=HTMLattSQ&amp;HTMLtext=HTML2ndtext&amp;scripttag=scripttag
<br/><br/> URL Tested (URL-slugged) 4: h-t-t-p-://192.168.56.103/testScripts/reflect.php?scriptattr=4a05a46&amp;HTML- attDQ=HTMLattDQ&amp;HTMLattS Q=HTMLattSQ&amp;HTMLtext=HTML2ndtext&amp;scripttag=scripttag
<br/><br/> URL Tested (URL-slugged) 5: h-t-t-p-://192.168.56.103/testScripts/reflect.php?scripttag=eed97cd&amp;HTMLa- ttDQ=HTMLattDQ&amp;HTMLattS Q=HTMLattSQ&amp;HTMLtext=HTML2ndtext&amp;scriptattr=scriptattr
<br/><br/> The following example shows a URL that could be obtained by spidering, the associated POST URL and the data to submit to the POST URL.
<br/><br/> . . . URL Spidered: h-t-t-p-://192.168.56.103/testScripts/reflect.php?HTMLtext=HTML2ndtext&amp;HT- MLtext=HTMLtext&amp;HTMLa ttDQ=HTMLattDQ&amp;HTMLattSQ=HTMLattSQ&amp;scriptattr=scriptattr&amp;scripttag=script- tag
<br/><br/> . . . URL POSTed (form method): h-t-t-p-://192.168.56.103/testScripts/reflect.php
<br/><br/> . . . Data POSTed 1: {u'post-data': {u'HTMLattDQ': u'', u'HTMLtext': u'', u'scripttag': u'', u'scriptattr': u'', u'HTMLattSQ': u'78752ef}}
<br/><br/> . . . Data POSTed 2: {u'post-data': {u'HTMLattDQ': u'', u'HTMLtext': u'26292b5', u'scripttag': u'', u'scriptattr': u'', u'HTMLattSQ': u''}}
<br/><br/> . . . Data POSTed 3: {u'post-data': {u'HTMLattDQ': u'', u'HTMLtext': u'', u'scripttag': u'', u'scriptattr': u'4a05a46', u'HTMLattSQ': a''}}
<br/><br/> . . . Data POSTed 4: {u'post-data': {u'HTMLattDQ': u'', u'scripttag': u'eed97cd', u'HTMLtext': u'', u'scriptattr': u'', u'HTMLattSQ': u''}}
<br/><br/> . . . Data POSTed 5: {u'post-data': {u'HTMLattDQ': u'2f6b4e8', u'HTMLtext': u'', u'scripttag': u'', u'scriptattr': u'', u'HTMLattSQ': u''}}
<br/><br/> FIG. 4 shows exemplary notated computer code (JSON in Python programming language) for the generation of a unique slug for each parameter/field of a URL.  The code references a database in which all slugs are recorded and checks that there are
no duplicates assigned (so that the slug assigned to each field/parameter in the application will be unique).
<br/><br/> Algorithmic Slug Assignment (Field Same Slug)
<br/><br/> The generation, assignment and submission of unique slugs to each of an application's parameters/fields may be performed according to the following seven step process, exemplified in the following examples: Step 1: Get URL.  Step 2: Get URL
parameters and values Step 3: Save URL parameters and values Step 4: For each URL, generate the parameters to be submitted to application by application of algorithm (single, tree, alternating parameters, etc.) Step 5: For each parameter, generate
md5checksum or modified length md5checksum Step 6: Assign the md5checksum or modified length md5checksum to the parameter Step 7: Save assignment Step 8: Load slug into application through different/variety of GET, POST, Cookie, HEADER methods (whatever
entry point(s) is/are applicable).  The generation of the URL parameters and assignment of slug may, for example, happen at the same time (e.g., steps 4, 5 and 6).
<br/><br/> Algorithmic Slug Assignment (Same Field Name Different Slug by URL)
<br/><br/> The generation, assignment and submission of unique slugs to each of an application's parameters/fields/URLs may be performed according to the following seven step process, exemplified in the following examples: Step 1: Get URL.  Step 2: Get URL
parameters and values Step 3: Save URL parameters and values Step 4: For each URL, generate the parameters to be submitted to application by algorithm (single, tree, alternating parameters, etc.) Step 5: For each different URL parameter variation,
generate md5checksum or modified length md5checksum even if field has the same name Step 6: Assign the md5checksum or modified length md5checksum to the parameter Step 7: Save assignment Step 8: Load slug into application through different/variety of
GET, POST, Cookie, HEADER methods (whatever entry point(s) is/are applicable).  The generation of the URL parameters and assignment of slug may happen at the same time (e.g., steps 4, 5 and 6).
<br/><br/>EXAMPLE
<br/><br/>Transform Compare Method
<br/><br/> The following example illustrates the application of a method to determine how the application transforms characters from one input into a different output using a default slug 9876543210:
<br/><br/> 1.  Sandwich character, string or payload, (e.g. &lt;) between two slugs (9876543210&lt;9876543210) 2.  Submit data to the application 3.  Search for original submission (9876543210&lt;987654321) 4.  If not found search for slug: 9876543210 5. 
If slug found determine if there is a slug that soon follows it 6.  Parse/record/save entire character(s)/string between two slugs 7.  Alternatively, parse from start of one slug though the end of the second capturing the slug-transformation-slug and
then remove the two slugs on both sides; 6.  If so, note/record/save that the character transforms from &lt;into &gt; (9876543210&gt;9876543210)
<br/><br/> Generation of Exploits Based on XSS Testing Results
<br/><br/> The results of the XSS testing of an application may be used to generate exploits for which the application is vulnerable.  The slug may be used to parse or interpret the HTML or Javascript/VBscript in order to create new syntactically sound
HTML or JavaScript.  Various methods such as XPATH may be used to do so.  For example, where `A` represents the slug value: //*[@*[contains(.,`A`)] or text( )[contains(.,`A`)]] RegEx may also be used.  It is important to note that the slug allows the
application to break apart the code/data, such as HTML, Javascript, VBscript, etc., so that its components can be known.  Once the components of the code/data are known, this information can be used to write an exploit.
<br/><br/> The order of steps in the methods of the invention can have some flexibility.  In one method (not shown below), one can find the slug, determine the elements and test only for the characters needed to get an exploit to work.  For example, under
normal conditions, if one finds the string &lt;a href="[slug]"&gt;&lt;/a&gt; we know that if a double quotation mark (") does not pass through the filter (or is transformed into strings such as \" or &gt;) into the section of code that contains the slug,
the exploit will fail.  In this case, the HTML, script, etc may be analyzed first before the XSS test method is performed.
<br/><br/> Whole Payload Method of Exploit Generation
<br/><br/> A first method including the following steps may be used in the generation of an exploit and is exemplified with respect to HTML below: Step 1: Find Slug (e.g., MD5 CheckSum or part thereof) in HTML; Step 2: Use XSS Test Method to determine
characters that pass through filter; Step 3: Check if exploit string passes through filter; Step 4: Parse HTML to determine where Slug occurs; Step 5: Use characters found to make syntactically correct HTML and see if passes through filter; and Step 6:
Remove Slug and Save Exploit Store Signature XSS String: &lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt; in computer memory, and optionally a generate report including the exploit.
<br/><br/> Case 1 Example: md5sum=5a105e8b9d40e1329780d62ea2265d8a
<br/><br/> Step 1: &lt;a href="http://www.google.com"&gt;5a105e8b9d40e1329780d62ea2265d8a&lt;/a&gt;- ;
<br/><br/> Step 2: &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a&lt;- 5a105e8b9d40e1329780d62ea2265d8a&lt;/a&gt; &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a&gt;-
5a105e8b9d40e1329780d62ea2265d8a&lt;/a&gt; &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a/5a1- 05e8b9d40e1329780d62ea2265d8a&lt;/a&gt; &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a
(5a105e8b9d40e1329780d62ea2265d8a&lt;/a&gt; &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a'5a1- 05e8b9d40e1329780d62ea2265d8a&lt;/a&gt; &lt;a href="h-t-t-p://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a)
5a105e8b9d40e1329780d62ea2265d8a&lt;/a&gt;
<br/><br/> Step 3: &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a &lt;script&gt;alert(`xss`)&lt;/script&gt;5a105e8b9d40e1329780d62ea2265d8a- &lt;/a&gt;
<br/><br/> Step 4: (Part 1)&lt;a hre"h-t-t-p-://www.google.-com"&gt; (Part 2)&lt;/a&gt;
<br/><br/> Step 5: &lt;a href="h-t-t-p-://www.google.-com"&gt;5a105e8b9d40e1329780d62ea2265d8a&lt;- /a&gt;&lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt;5a105e8b9d40e1329780d62ea- 2265d8a&lt;a&gt;&lt;/a&gt;
<br/><br/> Step 6: &lt;a href="h-t-t-p-://www.google.-com"&gt;&lt;/a&gt;&lt;scri-pt&gt;alert(`xss`- )&lt;/scri-pt&gt;&lt;a&gt;&lt;/a&gt;
<br/><br/> Case 2 Example md5=ad0234829205b9033196ba818f7a872b
<br/><br/> Step 1: &lt;a href="ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt;
<br/><br/> Step 2: &lt;a href="ad0234829205b9033196ba818f7a872b"ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a href="ad0234829205b9033196ba818f7a872b&lt;ad0234829205b9033196ba818f7a872- b"&gt;Link Text&lt;/a&gt; &lt;a
href="ad0234829205b9033196ba818f7a872b&gt;ad0234829205b9033196ba818f7a872- b"&gt;Link Text&lt;/a&gt; &lt;a href="ad0234829205b9033196ba818f7a872b/ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a
href="ad0234829205b9033196ba818f7a872b(ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a href="ad0234829205b9033196ba818f7a872b)ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a
href="ad0234829205b9033196ba818f7a872b'ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt;
<br/><br/> Step 3: &lt;a href="ad0234829205b9033196ba818f7a872b&lt;scri-pt&gt;alert(`xss`)&lt;/scr- i-pt&gt;ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt;
<br/><br/> Step 4: (part 1) &lt;a href=" (part 2) "&gt;Link Text&lt;/a&gt; //"&gt;&lt;/a&gt;&lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt;&lt;a href="
<br/><br/> Step 5: &lt;a href="ad0234829205b9033196ba818f7a872b"&gt;&lt;/a&gt;&lt;scri-pt&gt;alert- (`xss`)&lt;/scri-pt&gt;&lt;a href="ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt;
<br/><br/> Step 6: &lt;a href=" "&gt;&lt;/a&gt;&lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt;&lt;a href=" "&gt;Link Text&lt;/a&gt;
<br/><br/> A variation of the first method including the following steps may also be used in the generation of an exploit and is exemplified with respect to HTML below: Step 1: Find Slug in HTML Step 2: Parse HTML to determine where CheckSum exists: syntax
check Step 3: Determine characters needed to pass through filter based on syntax of returned data (HTML/JSON/XML/etc.) Step 4: Use XSS Test Method to determine characters that pass through filter Step 5: If characters pass through filter, build exploit
string based on characters and context and then check if exploit string passes through filter Step 6: (optional) Exploit string can be out of band callback for extra validation Step 7: Remove MD5 Check Sum and Save Exploit
<br/><br/> Case 3 Example (Variation of First Exploit Generation Method) md5=ad0234829205b9033196ba818f7a872b
<br/><br/> Step 1: &lt;a href="ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt;
<br/><br/> Step 2: (part 1)&lt;a href=" (part 2) "&gt;Link Text&lt;/a&gt; "&gt;&lt;/a&gt;&lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt;&lt;a href="
<br/><br/> Step 3: &lt;a href="ad0234829205b9033196ba818f7a872b" ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt; &lt;a href="ad0234829205b9033196ba818f7a872b&lt;ad0234829205b9033196ba818f7a872- b"&gt;Link Text&lt;/a&gt; &lt;a
href="ad0234829205b9033196ba818f7a872b&gt;ad0234829205b9033196ba818f7a872- b"&gt;Link Text&lt;/a&gt; &lt;a href="ad0234829205b9033196ba818f7a872b/ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a
href="ad0234829205b9033196ba818f7a872b(ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a href="ad0234829205b9033196ba818f7a872b)ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt; &lt;a
href="ad0234829205b9033196ba818f7a872b'ad0234829205b9033196ba818f7a872b"&amp;- gt;Link Text&lt;/a&gt;
<br/><br/> Step 4: &lt;a href="ad0234829205b9033196ba818f7a872b&lt;scri-pt&gt;alert(`xss`)&lt;/scr- i-pt&gt;ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt;
<br/><br/> Step 5: &lt;a href="ad0234829205b9033196ba818f7a872b"&gt;&lt;/a&gt;&lt;scri-pt&gt;alert- (`xss`)&lt;/scri-pt&gt;&lt;a href=" ad0234829205b9033196ba818f7a872b"&gt;Link Text&lt;/a&gt;
<br/><br/> Step 6: &lt;a href=" "&gt;&lt;/a&gt;&lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt;&lt;a href=" "&gt;Link Text&lt;/a&gt;
<br/><br/> HTML/XML/JSON/Etc Syntax Method of Exploit Generation
<br/><br/> A method including the following steps may be used in the generation of an exploit and is exemplified with respect to HTML below:
<br/><br/> Step 1: Find Slug (e.g., MD5 CheckSum or part thereof) in HTML/Script/JSON/XML/etc. and use context/syntax to determine characters needed to test; Step 2: Use XSS Test Method to determine characters that pass through filter; Step 3: Build custom
exploit with syntactically correct HTML/XML/JSON/etc based on characters that pass through filter from XSS Test Method.  Here, build/generate an exploit means the application automatically determines the sequence of characters needed to create
syntactically correct code that will execute; Step 4: Check if syntactically correct exploit string passes through the target application's filter.  The correctness of the syntax can be checked, for example, by the call back method, out-of-band method
and/or in a sandbox method; Step 5: If the exploit is determined to pass through the application's filter, remove the default slug portion and save the validated exploit.  For example, store Signature XSS String:
&lt;scri-pt&gt;alert(`xss`)&lt;/scri-pt&gt; in computer memory and optionally generate report including the exploit(s).
<br/><br/> Method for Discovering the Size/Maximum Size of a Field
<br/><br/> There may be cases in which the size of the exploit or putative exploit must be determined.  This computer-implemented method allows the length of the field and or database field to be discovered so that the correct size exploit may be
determined and used.  The method may include the following steps: 1.  Select/generate a unique long slug.  (While this could be any length string one would like to test; ideally it is at least the length of the exploit.); 2.  Submit the long slug to
application; 3.  Check resulting output for the slug; 4.  If not found, check remove one character from the unique long slug and check again; 5.  Repeat checks until field is found; and 6.  Determine difference in size between the slug found in
application and one submitted to get length of field.  The determined field size may be used to optimize the exploit.  This method of determining field size may be used in addition to and/or in conjunction with any of the other embodiments of the
invention and variations thereof described herein.  Some fields have a fixed length and some do not have a fixed length.  For those that are fixed, the length may be determined.  Once it is determined that there is a stored field (by seeing a single test
slug reflect) then the size of the field can be determined in the process of character testing (one way).  Another way to determine field size is to start testing characters first after it has been found that the default slug has reflected and then add
characters to it and resubmit it until an upper limit is reached, i.e., until the string is no longer reflecting (not as complete but quicker than the first method).
<br/><br/> FIG. 5 shows a network-connected computer system embodiment 501 of the invention with various interacting target application computer systems shown.  Computer system 501 of the embodiment includes a processor 502 (i.e., computer processor),
processor-accessible memory 503, processor-executable computer instructions 504 stored in memory 503, at least one input device 505 such as a keyboard or microphone operably connected to the processor, at least one output device 506 under control of the
processor such as a display or a printer, and a network communications server 507 that permits data to be sent to and received from other computing devices and systems, for example, via the Internet, a cellular telephone network, a private data network
and/or a direct data transfer connection.  Memory 503 also includes one or more data structures, such as one or more relational databases, for storing data utilized by and generated by the system in the course of its operation.  Server 507 may also be
considered an output device.  The aforementioned components of system 501 are collectively mutually configured to provide the following functional modules of the system as directed by the processor under control of the computer instructions:
<br/><br/> (1) a Target Application Designation Module 508 which permits a user of the system to input, for example via input device 505 a target application, such as a web page for which XSS vulnerability testing is desired.  Target Application
Designation Module 508 may, for example, present a user interface such as a secure web page with which the user can input the designation(s);
<br/><br/> (2) Field/Parameter/URL Determination Module 509 that determines, for example, by spidering and/or by forcing errors, what the fields, parameters and/or URLs are for the target application.  At least some of this information may already exist,
for example, in a compiled form and be uploaded or otherwise entered and stored in memory 503;
<br/><br/> (3) a Default Slug Generation, Loading and Detection Module 510 that generates a default slug which is a string of characters, such as non-special characters, and submits (loads) the default slug to the application via the fields/parameters/URLs
etc. and determines (detects) where, if at all, and how the default slug is returned by the target application, i.e. a reflected slug, stored slug, in-memory slug and/or DOM, etc. This module may also be configured to detect and parse out the context
and/or syntax in/with which the returned slug appears, and store the results in the memory;
<br/><br/> (4) a Test Slug Generation and XSS Testing Module 511 that (i) generates test slugs consisting of two default slugs which are the same or different (that was/were determined by Module 510 to be reflected by the target application) surrounding a
test character or test string of multiple test characters, such as but not limited to a special character or a string of characters including one or more or all special characters, (ii) submits the generated test slugs in the target application fields,
parameters and/or URLs to the target application, (iii) determines if and where the test slugs are returned and whether any of the characters (which may or may not have passed through a filter if the application has a filter) in the test string of the
test slug are transformed in the returned test slug or not, and (iv) stores the results of the testing in memory 503.  For a given length or given lengths of the test slugs, Module 511 may be configured to generate and submit all possible test slugs to
the target application.
<br/><br/> (5) an Exploit Generation and Validation Module 512 configured to (i) build/generate custom exploits with syntactically correct HTML/XML/JSON/etc. based on characters that are returned by the application (which may or may not have passed through
a filter if the application has a filter) from XSS Testing by Module 511, (ii) determine if syntactically correct (executable) exploit string(s) passes through filter (the correctness of the syntax can be checked, for example, by the call back method,
out-of-band method and/or in a sandbox method), and (iii) if a validated exploit is determined, saving the exploit in memory 503; and
<br/><br/> (6) a Report Generation Module 513 configured to generate and output a vulnerability testing results report via output device 506 or electronically in a file via server 507 which report includes, for example, an identification of any fields,
parameters, URLs in which a test slug submission resulted in a reflection in which one or more test characters of the test slug were transformed, and identification of the corresponding character(s) and/or string of characters that experienced a
transformation, and a description of any exploit generated and validated (for a field, parameter, URL, etc.) by Module 512.
<br/><br/> As further shown in the FIG. 5, system 501 is operably connected for two-way communication to a communications network 520, such as the Internet, a cellular telephone network, a local area network, and/or a private communications network, via
server 507.  Target applications 531 and 532 to be tested by system 501 are provided by computer systems that are similarly operably connected for two-way communication to network 520.  For example, target applications 531 and 532 may be web pages served
by remote web servers in the normal course of their operation and system 501 may interrogate the target applications via their regular communication network connection(s).
<br/><br/> Advantageously, the methods of the invention may be directed to an entire target application, such as an entire web site, or to particular sub-applications such as login pages, shopping carts, forms, web pages, dynamic content, etc. Further, the
methods of the invention may be implemented in and with respect to different programming languages and with and upon different platforms.  The methods and systems of the invention are applicable to security issues and problems that occur in the context
of modern computing systems, especially with respect to computers communicating over a communications network such as the Internet.
<br/><br/> The examples above are simplified for the sake of illustration and do not showing testing of alphanumeric characters, e.g., A-Z and 0-9.  Such characters, like the special characters, may be tested according to the invention.  In addition, any
type of characters or subset of characters or combinations thereof may be tested according to the invention.  For example, any or all of special characters, alphanumeric characters, and non-printable characters may be tested for an application.  Also,
any character set, such as ASCII or Unicode, or combinations thereof may be tested.
<br/><br/> Reference is made throughout this disclosure to browser-interpretable (or -executable) code such as HTML and scripting language such as JavaScript, and VBscript and internal data structures (referenced data) such as Document Object Model (DOM). 
It should be understood that the invention is applicable to any type of browser-interpretable (or -executable) code, scripting language or internal data structure (referenced data) and that wherever in this application any of these categories or
particular examples thereof is referenced, the invention also provides corresponding embodiments for the remaining categories generally and for the particular examples within those categories that are disclosed herein.
<br/><br/> Some portions of this description describe the embodiments of the invention in terms of algorithms and symbolic representations of operations on information.  These algorithmic descriptions and representations are commonly used by those skilled
in the data processing arts to convey the substance of their work effectively to others skilled in the art.  These operations, while described functionally, computationally, or logically, are understood to be implemented by computer programs or
equivalent electrical circuits, microcode, or the like.  Furthermore, it has also proven convenient at times, to refer to these arrangements of operations as modules, without loss of generality.  The described operations and their associated modules may
be embodied in software, firmware, hardware, or any combinations thereof.
<br/><br/> Any of the steps, operations, or processes described herein may be performed or implemented with one or more hardware or software modules, alone or in combination with other devices.  In one embodiment, a software module is implemented with a
computer program product including a computer-readable medium containing computer program code, which can be executed by a computer processor for performing any or all of the steps, operations, or processes described.  As known in the art, various data
structures such as databases, for example, relational databases may be used to implement various aspects of the methods of the invention.
<br/><br/> Embodiments of the invention may also relate to computerized systems for performing the operations herein.  Such apparatuses include a processor, processor accessible tangible memory and computer instructions (computer program) stored in the
tangible processor accessible memory.  Furthermore, any computing systems referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.  It should also be
understood that various of the operations and aspects of embodiments of the invention may be performed by distributed apparatuses.
<br/><br/> The vulnerability detecting computer systems of the invention may interrogate subject systems/applications remotely via a communications connection, for example, via a communications network such as the Internet.  Thus, the computer systems of
the invention may include a communications network server/module that may, for example, include and/or be physically connected to a communication network infrastructure by one or more electrical wires, such as twisted wires, e.g., twisted, copper wire(s)
or coaxial cables such as copper or aluminum wire wrapped with an insulating and flexible material, and/or by one or more optical fibers such as by an optical fiber cable/bundle.
<br/><br/> Although the foregoing description is directed to the preferred embodiments of the invention, it is noted that other variations and modifications will be apparent to those skilled in the art, and may be made without departing from the spirit or
scope of the invention.  Moreover, features described in connection with one embodiment of the invention may be used in conjunction with other embodiments, even if not explicitly stated above.  In addition, methods including steps as described herein may
be performed in the step-wise order presented or in any operable order, all of which are intended to be within the scope of the invention.
<br/><br/> The following computer program listing exemplifies computer code configured to parse out the syntax (such as special characters) surrounding a returned default slug and determine which characters may be added (in the space occupied by the
returned default slug) in order to build a syntactically correct piece of executable code, i.e., an exploit.  By syntactically correct code, it is meant herein that the browser or similar subject application will be able to interpret the exploit and
execute it, not that perfect HTML, JavaScript, etc. is present, since browsers and like applications through normal function allow for deviations/errors in HTML/XML/JSON/etc. FIG. 6 shows an exemplary report showing the parsing and exploit generation
results obtained by the program.  Other computer code provided by the invention can be configured to direct the computer system of the invention to generate and submit (attempt to load) test slugs to the target application which consist of one or more
test characters or strings, which may include the required character(s) or strings in encoded or un-encoded form, but can be any characters or strings, sandwiched between two default slugs (which may be the same or different) and determine if the
application returns the test slug with the characters required to form executable code, i.e., an exploit.
<br/><br/><center><b>* * * * *</b></center>
<hr/>
   <center>
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09356955&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D402%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D9%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>
   <table>
   <tbody><tr><td align="center"><a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D402%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D9%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209356955"><img alt="[View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9356955&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D402%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D9%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209356955">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
     <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=402&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=8&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=402&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=9&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=402&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=10&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=401&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=9&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=403&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=9&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

   <a href="#top"><img alt="[Top]" border="0" src="/netaicon/PTO/top.gif" valign="middle"/></a>
   </td></tr>
   </tbody></table>
   <a name="bottom"></a>
   <a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
   </center>

</body></html>
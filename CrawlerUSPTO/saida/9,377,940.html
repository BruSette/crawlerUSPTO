<html><head>
<base target="_top"/>
<title>United States Patent: 9377940</title></head>
<!---BUF1=9377940
BUF7=2016
BUF8=46682
BUF9=/1/
BUF51=9
---->
<body bgcolor="#FFFFFF">
<a name="top"></a>
<center>
<img alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" src="/netaicon/PTO/patfthdr.gif"/>
<br/>
<table>
<tbody><tr><td align="center">
<a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
<a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
<a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
</td></tr>
<tr><td align="center">
   <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=198&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=3&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=198&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=4&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=198&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=5&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=197&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=4&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=199&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=4&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

<a href="#bottom"><img alt="[Bottom]" border="0" src="/netaicon/PTO/bottom.gif" valign="middle"/></a>
</td></tr>
   <tr><td align="center">
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D198%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D4%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209377940"><img alt="[
View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9377940&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D198%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D4%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209377940">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09377940&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D198%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D4%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>

   </td></tr>
</tbody></table>
</center>
<table width="100%">
<tbody><tr><td align="left" width="50%"> </td>
<td align="right" valign="bottom" width="50%"><font size="-1">( <strong>198</strong></font> <font size="-2">of</font> <strong><font size="-1">7895</font></strong> <font size="-1">)</font></td></tr></tbody></table>
<hr/>
   <table width="100%">
   <tbody><tr>	<td align="left" width="50%"><b>United States Patent </b></td>
   <td align="right" width="50%"><b>9,377,940</b></td>
   </tr>
     <tr><td align="left" width="50%"><b>
         McAllister
,   et al.</b>
     </td>
     <td align="right" width="50%"> <b>
     June 28, 2016
</b></td>
     </tr>
     </tbody></table>
       <hr/>
       <font size="+1">Predictive pre-decoding of encoded media item
</font><br/>
       <br/><center><b>Abstract</b></center>
       <p> Displaying a plurality of encoded media items on a device includes:
     detecting that a first scrolling action has been completed; determining a
     predicted next encoded media item to be displayed; obtaining the
     predicted next encoded media item from a first memory; pre-decoding the
     predicted next encoded media item to generate a pre-decoded media item;
     storing the pre-decoded media item in a second memory, the second memory
     having lower latency than the first memory; receiving an indication that
     a second scrolling action has begun; and in response to the second
     scrolling action, displaying the pre-decoded media item via a display
     interface.
</p>
       <hr/>
<table width="100%"> <tbody><tr> <th align="left" scope="row" valign="top" width="10%">Inventors:</th> <td align="left" width="90%">
 <b>McAllister; Philip</b> (San Francisco, CA)<b>, Sweeney; Shayne</b> (San Francisco, CA) </td> </tr>
<tr><th align="left" scope="row" valign="top" width="10%">Applicant: </th><td align="left" width="90%"> <table> <tbody><tr> <th align="center" scope="column">Name</th> <th align="center" scope="column">City</th> <th align="center" scope="column">State</th> <th align="center" scope="column">Country</th> <th align="center" scope="column">Type</th> </tr> <tr> <td> <b><br/><b><i>Facebook,</i></b> Inc.</b> </td><td> <br/>Menlo Park </td><td align="center"> <br/>CA </td><td align="center"> <br/>US </td> <td align="left"> </td>
</tr> </tbody></table>
<!-- AANM>
~AANM <B><I>Facebook,</I></B> Inc.
~AACI Menlo Park
~AAST CA
~AACO US
</AANM -->
</td></tr>
<tr> <th align="left" scope="row" valign="top" width="10%">Assignee:</th>
<td align="left" width="90%">

<b><a href="#h2" name="h3"></a><a href="#h4"></a><b><i>Facebook,</i></b> Inc.</b>
 (Menlo Park, 
CA)
<br/>

</td>
</tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Family ID:
       </th><td align="left" width="90%">
       <b>1000001937461
</b></td></tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Appl. No.:
       </th><td align="left" width="90%">
       <b>13/780,474</b></td></tr>
       <tr><th align="left" scope="row" valign="top" width="10%">Filed:
       </th><td align="left" width="90%">
       <b>February 28, 2013</b></td></tr>
     </tbody></table>
<hr/> <center><b>Prior Publication Data</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Document Identifier</u></b></th><th align="center" scope="col"><b><u>Publication Date</u></b></th></tr><tr><td align="center"> </td><td align="center"> US 20140245219 A1</td><td align="center">Aug 28, 2014</td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table>
     <hr/>
<p> <table width="100%"> <tbody><tr><td align="left" valign="top" width="30%"><b>Current U.S. Class:</b></td> <td align="right" valign="top" width="70%"><b>1/1</b> </td></tr> 
       <tr><td align="left" valign="top" width="30%"><b>Current CPC Class: </b></td>
       <td align="right" valign="top" width="70%">G06F 3/0485 (20130101); G06F 17/30244 (20130101)</td></tr>
         <tr><td align="left" valign="top" width="30%"><b>Current International Class: </b></td>
         <td align="right" valign="top" width="70%">G06F 3/0485 (20130101); G06F 17/30 (20060101)</td></tr>
       <tr><td align="left" valign="top" width="30%"><b>Field of Search: </b></td>
       <td align="right" valign="top" width="70%">
       
 ;715/784
       </td></tr>
     </tbody></table>
</p><hr/><center><b>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=PALL&amp;Query=ref/9377940">[Referenced By]</a></b></center>       <hr/>
       <center><b>U.S. Patent Documents</b></center>
<table width="100%"> <tbody><tr><th scope="col" width="33%"></th> <th scope="col" width="33%"></th> <th scope="col" width="34%"></th></tr> <tr> <td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5394523">5394523</a></td><td align="left">
February 1995</td><td align="left">
Harris</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5515081">5515081</a></td><td align="left">
May 1996</td><td align="left">
Vasilik</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5764238">5764238</a></td><td align="left">
June 1998</td><td align="left">
Lum et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5805133">5805133</a></td><td align="left">
September 1998</td><td align="left">
Priem et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6002401">6002401</a></td><td align="left">
December 1999</td><td align="left">
Baker</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6167404">6167404</a></td><td align="left">
December 2000</td><td align="left">
Morcos et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6263396">6263396</a></td><td align="left">
July 2001</td><td align="left">
Cottle et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6433885">6433885</a></td><td align="left">
August 2002</td><td align="left">
Verghese et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20020118890&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2002/0118890</a></td><td align="left">
August 2002</td><td align="left">
Rondinelli</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20040054894&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2004/0054894</a></td><td align="left">
March 2004</td><td align="left">
Lambert</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050001848&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2005/0001848</a></td><td align="left">
January 2005</td><td align="left">
Colavin</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050111556&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2005/0111556</a></td><td align="left">
May 2005</td><td align="left">
Endress et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20070027959&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2007/0027959</a></td><td align="left">
February 2007</td><td align="left">
Harris et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080092078&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0092078</a></td><td align="left">
April 2008</td><td align="left">
Takeshima et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080134079&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0134079</a></td><td align="left">
June 2008</td><td align="left">
Brunner et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080320396&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0320396</a></td><td align="left">
December 2008</td><td align="left">
Mizrachi</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20090161552&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2009/0161552</a></td><td align="left">
June 2009</td><td align="left">
Rible</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20100031186&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2010/0031186</a></td><td align="left">
February 2010</td><td align="left">
Tseng et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20100129053&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2010/0129053</a></td><td align="left">
May 2010</td><td align="left">
Ito</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110090253&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0090253</a></td><td align="left">
April 2011</td><td align="left">
Good</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110216981&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0216981</a></td><td align="left">
September 2011</td><td align="left">
Hiraga et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120235933&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0235933</a></td><td align="left">
September 2012</td><td align="left">
Yamamura et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120266068&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0266068</a></td><td align="left">
October 2012</td><td align="left">
Ryman et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120327097&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0327097</a></td><td align="left">
December 2012</td><td align="left">
Mostafa et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20130080968&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2013/0080968</a></td><td align="left">
March 2013</td><td align="left">
Hanson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20130339807&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2013/0339807</a></td><td align="left">
December 2013</td><td align="left">
Umeroglu et al.</td></tr><tr><td align="left">

</td>
</tr> </tbody></table>
<table width="90%">   <tbody><tr><td><align="left"><br/>Chen, W. Prefetching techniques to rebuild caches associated with bitmaps. Jun. 22, 2009. cited by examiner
.<br/>Bitmap Class. Android Developers. Aug. 5, 2009. cited by examiner. </align="left"></td></tr> </tbody></table><br/><center><b>Other References</b></center> <br/>
       <i>Primary Examiner:</i> Hailu; Tadeese
<br/>
       <i>Assistant Examiner:</i> Calderon, IV; Alvaro R
<br/>
       <i>Attorney, Agent or Firm:</i> <coma>Van Pelt, Yi &amp; James LLP
<br/>
         <hr/>
<center><b><i>Claims</i></b></center> <hr/> <br/><br/>What is claimed is: <br/><br/> 1.  A system, comprising: an input interface configured to detect that a first scrolling action has been completed;  one or more computer processors coupled to the input
interface, configured to: determine a predicted next encoded media item to be displayed;  obtain the predicted next encoded media item from a first memory;  pre-decode, using the one or more computer processors, the predicted next encoded media item to
generate a pre-decoded media item, the pre-decoding including: creating an object that does not initially include actual decoded data;  invoking a function call, wherein the function call: obtains a value of a single pixel associated with the object,
stores the obtained value of the single pixel in an application heap, the application heap being included in a second memory, and decodes data that is not in bitmap format to generate the actual decoded data that is in bitmap format;  store the
pre-decoded media item to the second memory, the second memory having lower latency than the first memory, and the second memory including the application heap and a system heap;  and receive an indication that a second scrolling action has begun;  and a
display interface coupled to the one or more computer processors, configured to display the pre-decoded media item in response to the second scrolling action.
<br/><br/> 2.  The system of claim 1, wherein the input interface and the display interface comprise a touch-sensitive screen.
<br/><br/> 3.  The system of claim 1, wherein to determine the predicted next encoded media item includes to: determine a last decoded media item that was last decoded in response to the first scrolling action;  detect a direction of the first scrolling
action;  and based on a location of the last decoded media item, identify a next media item in the direction of the first scrolling action as the predicted next encoded media item.
<br/><br/> 4.  The system of claim 1, wherein the predicted next encoded media item includes a Joint Photographic Experts Group (JPEG) file.
<br/><br/> 5.  The system of claim 1, wherein the pre-decoded media item includes a bitmap.
<br/><br/> 6.  The system of claim 1, wherein: the object includes a Bitmap object created based on the predicted next encoded media item;  and the function call includes a function call that generates an actual decoded bitmap image data for the Bitmap
object.
<br/><br/> 7.  The system of claim 6, wherein the actual decoded bitmap image data is stored on the second memory.
<br/><br/> 8.  The system of claim 1, wherein the predicted next encoded media item is one of M predicted next encoded media items that are determined.
<br/><br/> 9.  The system of claim 8, wherein M is determined based at least on a probability that a last decoded media item is evicted from the second memory.
<br/><br/> 10.  The system of claim 1, wherein the first memory from which the predicted next encoded media item is obtained and the second memory to which the pre-decoded media item is stored are located on one device.
<br/><br/> 11.  A method, comprising: detecting, via an input interface, that a first scrolling action has been completed;  determining a predicted next encoded media item to be displayed;  obtaining the predicted next encoded media item from a first
memory;  pre-decoding, using one or more computer processors, the predicted next encoded media item to generate a pre-decoded media item, the pre-decoding including: creating an object that does not initially include actual decoded data;  invoking a
function call, wherein the function call: obtains a value of a single pixel associated with the object, stores the obtained value of the single pixel in an application heap, the application heap being included in a second memory, and decodes data that is
not in bitmap format to generate the actual decoded data that is in bitmap format;  storing the pre-decoded media item in the second memory, the second memory having lower latency than the first memory, and the second memory including the application
heap and a system heap;  receiving an indication that a second scrolling action has begun;  and in response to the second scrolling action, displaying the pre-decoded media item via a display interface.
<br/><br/> 12.  The method of claim 11, wherein determining the predicted next encoded media item includes: determining a last decoded media item that was last decoded in response to the first scrolling action;  detecting a direction of the first scrolling
action;  and based on a location of the last decoded media item, identifying a next media item in the direction of the first scrolling action as the predicted next encoded media item.
<br/><br/> 13.  The method of claim 11, wherein the predicted next encoded media item includes a Joint Photographic Experts Group (JPEG) file.
<br/><br/> 14.  The method of claim 11, wherein the pre-decoded media item includes a bitmap.
<br/><br/> 15.  The method of claim 11, wherein: the object includes a Bitmap object based on the predicted next encoded media item;  and the function call includes a function call that generates an actual decoded bitmap image data for the Bitmap object.
<br/><br/> 16.  The method of claim 15, wherein the actual decoded bitmap image data is stored on the second memory.
<br/><br/> 17.  The method of claim 11, wherein the predicted next encoded media item is one of M predicted next encoded media items that are determined.
<br/><br/> 18.  The method of claim 17, wherein M is determined based at least on a probability that a last decoded media item is evicted from the second memory.
<br/><br/> 19.  The method of claim 11, wherein the first memory from which the predicted next encoded media item is obtained and the second memory to which the pre-decoded media item is stored are located on one device.
<br/><br/> 20.  A computer program product for displaying a plurality of encoded media items on a device, the computer program product being embodied in a tangible non-transitory computer readable storage medium and comprising computer instructions for:
detecting, via an input interface, that a first scrolling action has been completed;  determining a predicted next encoded media item to be displayed;  obtaining the predicted next encoded media item from a first memory;  pre-decoding, using one or more
computer processors, the predicted next encoded media item to generate a pre-decoded media item, the pre-decoding including: creating an object that does not initially include actual decoded data;  invoking a function call, wherein the function call:
obtains a value of a single pixel associated with the object, stores the obtained value of the single pixel in an application heap, the application heap being included in a second memory, and decodes data that is not in bitmap format to generate the
actual decoded data that is in bitmap format;  storing the pre-decoded media item in the second memory, the second memory having lower latency than the first memory, and the second memory including the application heap and a system heap;  receiving an
indication that a second scrolling action has begun;  and in response to the second scrolling action, displaying the pre-decoded media item via a display interface.
<br/><br/> 21.  The method of claim 11, wherein the decoded data is stored in the system heap included in the second memory. <hr/> <center><b><i>Description</i></b></center> <hr/> <br/><br/>BACKGROUND OF THE INVENTION
<br/><br/> Mobile devices such as smartphones have become ubiquitous.  Popular applications such as Instagram.TM.  allow users to share and view photos via their mobile devices.  Users often want to view a large number of photos on their devices quickly,
by scrolling through the images.  However, mobile devices currently tend to have limited amounts of memory, which can lead to performance issues.  When a user attempts to view tens or even hundreds of photos using a mobile device, the processing time
required can prevent photos from being displayed instantaneously.  For example, on Android.TM.  operating system-based smartphones, the operating system will only maintain a few most recently accessed images in memory, and evict older image bitmaps from
memory as a part of the memory management scheme.  The evicted bitmaps would need to be reprocessed and loaded back into memory when needed, resulting in a jittery display of images when the user scrolls through the images.  Better management and display
of images is needed to provide a more satisfying user experience when scrolling through photos. <br/><br/>BRIEF DESCRIPTION OF THE DRAWINGS
<br/><br/> Various embodiments of the invention are disclosed in the following detailed description and the accompanying drawings.
<br/><br/> FIG. 1 is a functional diagram illustrating a programmed computer system for displaying media items in accordance with some embodiments.
<br/><br/> FIG. 2 is a block diagram illustrating an embodiment of a memory subsystem of a system configured to display media items.
<br/><br/> FIG. 3 is an embodiment of a process for displaying a plurality of encoded media items on a device.
<br/><br/> FIG. 4 is a flowchart illustrating an embodiment of a process for determining the next encoded media item to be displayed.
<br/><br/> FIGS. 5A-5C are diagrams illustrating the determination of the predicted next encoded media item.
<br/><br/> FIG. 6 is a flowchart illustrating an embodiment of a process for pre-decoding the predicted next encoded media item.
<br/><br/> FIGS. 7A-7D illustrate example data structures that appear in different parts of the memory during the scrolling process.
<br/><br/>DETAILED DESCRIPTION
<br/><br/> The invention can be implemented in numerous ways, including as a process; an apparatus; a system; a composition of matter; a computer program product embodied on a computer readable storage medium; and/or a processor, such as a processor
configured to execute instructions stored on and/or provided by a memory coupled to the processor.  In this specification, these implementations, or any other form that the invention may take, may be referred to as techniques.  In general, the order of
the steps of disclosed processes may be altered within the scope of the invention.  Unless stated otherwise, a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is
temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task.  As used herein, the term `processor` refers to one or more devices, circuits, and/or processing cores configured to process
data, such as computer program instructions.
<br/><br/> A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention.  The invention is described in connection with such embodiments, but the
invention is not limited to any embodiment.  The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives, modifications and equivalents.  Numerous specific details are set forth in the following
description in order to provide a thorough understanding of the invention.  These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details.  For the purpose
of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.
<br/><br/> Displaying a plurality of encoded media items on a device is disclosed.  The encoded media items can be, for example, image files in Joint Photographic Experts Group (JPEG) or other compressed formats.  In some embodiments, the encoded media
items are decoded and displayed when the user makes a request for a scrolling action.  When the scrolling action stops, a predicted next encoded media item to be displayed is determined.  The predicted next encoded media item is fetched from a first
memory component such as a disk, a secure digital (SD) card, a flash drive, or the like.  The predicted next encoded media item is pre-decoded (e.g., from JPEG into bitmap), and the decoded media item is stored in a second memory component such as random
access memory (RAM).  When an indication that a second scrolling action has begun is received, the decoded media item is displayed.  Because the pre-decoded data is stored in the second, lower latency memory, displaying the decoded media item in response
to the second scrolling action does not incur significant processing overhead, and results in smooth display of the items and a pleasing user experience.
<br/><br/> FIG. 1 is a functional diagram illustrating a programmed computer system for displaying media items in accordance with some embodiments.  As will be apparent, other computer system architectures and configurations can be used to perform the
described media item display technique.  Computer system 100 can be a mobile device such as a smartphone, a portable device such as a tablet or laptop computer, a desktop system, or the like.  Computer system 100, which includes various subsystems as
described below, includes at least one microprocessor subsystem (also referred to as a processor or a central processing unit (CPU) 102).  For example, processor 102 can be implemented by a single-chip processor or by multiple processors.  In some
embodiments, processor 102 is a general purpose digital processor that controls the operation of the computer system 100.  In some embodiments, processor 102 also includes one or more coprocessors or special purpose processors (e.g., a graphics
processor, a network processor, etc.).  Using instructions retrieved from memory 110, processor 102 controls the reception and manipulation of input data received on an input device (e.g., image processing device 106, I/O device interface 104), and the
output and display of data on output devices (e.g., display 118).
<br/><br/> Processor 102 is coupled bi-directionally with memory 110, which can include, for example, one or more random access memories (RAM) and/or one or more read-only memories (ROM).  As is well known in the art, memory 110 can be used as a general
storage area, a temporary (e.g., scratch pad) memory, and/or a cache memory.  Memory 110 can also be used to store input data and processed data, as well as to store programming instructions and data, in the form of data objects and text objects, in
addition to other data and instructions for processes operating on processor 102.  Also as is well known in the art, memory 110 typically includes basic operating instructions, program code, data, and objects used by the processor 102 to perform its
functions (e.g., programmed instructions).  For example, memory 110 can include any suitable computer readable storage media described below, depending on whether, for example, data access needs to be bi-directional or uni-directional.  For example,
processor 102 can also directly and very rapidly retrieve and store frequently needed data in a cache memory included in memory 110.
<br/><br/> A removable mass storage device 112 provides additional data storage capacity for the computer system 100, and is optionally coupled either bi-directionally (read/write) or uni-directionally (read only) to processor 102.  A fixed mass storage
120 can also, for example, provide additional data storage capacity.  For example, storage devices 112 and/or 120 can include computer readable media such as magnetic tape, flash memory, PC-CARDS, portable mass storage devices such as hard drives (e.g.,
magnetic, optical, or solid state drives), holographic storage devices, and other storage devices.  Mass storages 112 and/or 120 generally store additional programming instructions, data, and the like that typically are not in active use by the processor
102.  It will be appreciated that the information retained within mass storages 112 and 120 can be incorporated, if needed, in standard fashion as part of memory 110 (e.g., RAM) as virtual memory.
<br/><br/> In addition to providing processor 102 access to storage subsystems, bus 114 can be used to provide access to other subsystems and devices as well.  As shown, these can include a display 118, a network interface 116, an input/output (I/O) device
interface 104, an image processing device 106, as well as other subsystems and devices.  For example, image processing device 106 can include a camera, a scanner, etc.; I/O device interface 104 can include a device interface for interacting with a
touchscreen (e.g., a capacitive touch sensitive screen that supports gesture interpretation), a microphone, a sound card, a speaker, a keyboard, a pointing device (e.g., a mouse, a stylus, a human finger), a Global Positioning System (GPS) receiver, an
accelerometer, and/or any other appropriate device interface for interacting with system 100.  Multiple I/O device interfaces can be used in conjunction with computer system 100.  The I/O device interface can include general and customized interfaces
that allow the processor 102 to send and, more typically, receive data from other devices such as keyboards, pointing devices, microphones, touchscreens, transducer card readers, tape readers, voice or handwriting recognizers, biometrics readers,
cameras, portable mass storage devices, and other computers.
<br/><br/> The network interface 116 allows processor 102 to be coupled to another computer, computer network, or telecommunications network using a network connection as shown.  For example, through the network interface 116, the processor 102 can receive
information (e.g., data objects or program instructions) from another network, or output information to another network in the course of performing method/process steps.  Information, often represented as a sequence of instructions to be executed on a
processor, can be received from and outputted to another network.  An interface card or similar device and appropriate software implemented by (e.g., executed/performed on) processor 102 can be used to connect the computer system 100 to an external
network and transfer data according to standard protocols.  For example, various process embodiments disclosed herein can be executed on processor 102, or can be performed across a network such as the Internet, intranet networks, or local area networks,
in conjunction with a remote processor that shares a portion of the processing.  Additional mass storage devices (not shown) can also be connected to processor 102 through network interface 116.
<br/><br/> In addition, various embodiments disclosed herein further relate to computer storage products with a computer readable medium that includes program code for performing various computer-implemented operations.  The computer readable medium
includes any data storage device that can store data which can thereafter be read by a computer system.  Examples of computer readable media include, but are not limited to: magnetic media such as disks and magnetic tape; optical media such as CD-ROM
disks; magneto-optical media such as optical disks; and specially configured hardware devices such as application-specific integrated circuits (ASICs), programmable logic devices (PLDs), and ROM and RAM devices.  Examples of program code include both
machine code as produced, for example, by a compiler, or files containing higher level code (e.g., script) that can be executed using an interpreter.
<br/><br/> The computer system shown in FIG. 1 is but an example of a computer system suitable for use with the various embodiments disclosed herein.  Other computer systems suitable for such use can include additional or fewer subsystems.  In some
computer systems, subsystems can share components (e.g., for touchscreen-based devices such as smart phones, tablets, etc., I/O device interface 104 and display 118 share the touch sensitive screen component, which both detects user inputs and displays
outputs to the user).  In addition, bus 114 is illustrative of any interconnection scheme serving to link the subsystems.  Other computer architectures having different configurations of subsystems can also be utilized.
<br/><br/> FIG. 2 is a block diagram illustrating an embodiment of a memory subsystem of a system configured to display media items.  In some embodiments, memory subsystem 200 can be used to implement memory 110 and/or fixed mass storage device 120 of
system 100.  In this example, an Android.TM.-based memory layout is described, although similar layout is applicable to other operating systems.  The system includes a first memory 202 and a second memory 204.  First memory 202 can be implemented using a
disk such as a secure digital (SD) disk, a flash drive, etc., and second memory 204 can be implemented using random access memory (RAM).  The first memory typically has higher latency than the second memory.  Since higher latency memory tends to be less
expensive than lower latency memory, the amount of space available on first memory 202 is typically greater than the amount of space available on second memory 204.
<br/><br/> In the example shown, encoded media items (e.g., images) 210 are stored on first memory 202.  These media items may be downloaded from a server or other designated storage location.  The media items can be encoded in a variety of formats for
purposes of compression, security, etc. For example, the media items can be in a compressed format such as Joint Photographic Experts Group (JPEG) files.  In some embodiments, a set of media items (referred to as a feed) to be downloaded are specified
using JavaScript Object Notation (JSON).  The JSON file lists the items in the order they are stored on the server, with universal resource locators (URLs) linked to the locations of the items.  When the user wishes to view a feed on his device, the
image viewing application sends a request to the server, which sends the JSON file to the application.  The application creates queues to retrieve the encoded media items from the locations listed in the URLs, and stores them on the first memory.
<br/><br/> Second memory 204 is divided into an application heap 206 (e.g., Java heap in Android.RTM.-based devices) and a system heap 208 (e.g., native heap in Android.RTM.-based devices).  In some embodiments, the operating system heap provides
facilities for managing the second memory.  For example, for Android.TM.  enabled devices, Anonymous Shared Memory (ashmem) and related application programming interfaces (APIs) are used by the operating system to manage shared memory on the system heap.
<br/><br/> When the application needs to display a media item, an API call is made.  The API call is allowed to access application heap 206.  If the decoded form of the media item (e.g., the bitmap image data 212) is already available in system heap 208,
it is copied from system heap 208 into application heap 206 and displayed according to the API call.  If, however, the decoded form is not yet available in system heap 208, the corresponding encoded media item (e.g., the JPEG file) is retrieved from
first memory 202, decoded and stored in system heap 208, transferred to application heap 206, and displayed.  Since the size of the system heap tends to be small and can only store a small number of bitmaps in its cache, the operating system can evict
any bitmap that has not been recently used from system heap 208 to make room for new bitmaps.  If an evicted bitmap is needed again, its corresponding JPEG file would need to be reloaded from first memory 202 and decompressed again.  Thus, when the user
is scrolling through the images, there can be a time lag in displaying the images due to the time required for loading and decompression, causing the user to be unable to view the image instantaneously.  The delayed display of the image (also referred to
as stutter) results in a poor user experience.
<br/><br/> To improve the user experience of scrolling and viewing media items, an image "warming" technique is employed where a prediction of which media item will be displayed next is made, and the predicted item is pre-decoded so that it is available in
the system heap before the user requests it.  FIG. 3 is an embodiment of a process for displaying a plurality of encoded media items on a device.  Process 300 can be implemented on a device such as device 100.  Preferably, process 300 is performed by the
User Interface (UI) thread to ensure that decoding and displaying of the next media item is completed before other actions are allowed to proceed.
<br/><br/> At 302, it is detected that a first scrolling action has been completed.  In some embodiments, the user performs a scrolling action by swiping a finger across the touch sensitive screen.  The UI thread detects that the scrolling action has been
completed when it is detected that the user's finger is lifted from the screen.  Images are displayed based on the sequence in which they are stored at the original storage location (e.g., the server).  Standard APIs control which images are displayed in
response to the first scrolling action according to the distance and speed of the swipe.  For example, when the user scrolls down, the images are displayed in the same order as they are stored; when the user scrolls up, the images are displayed in the
reverse order as they are stored.  The user may also scroll diagonally to navigate a two-dimensional layout of the images.
<br/><br/> At 304, a predicted next encoded media item to be displayed is determined.  In some embodiments, the prediction depends on the direction of the first scrolling action.  Based on the current position (i.e., the position of the media item at which
scrolling stopped), the next media item in the direction of the first scrolling action is the predicted next item to be displayed.
<br/><br/> At 306, the predicted next encoded media item is obtained from a first memory.  For example, referring to FIG. 2, the JPEG image that corresponds to the predicted next encoded media item is obtained from memory 202.  In cases where multiple
predicted next encoded media items are determined, these items are obtained from the first memory.
<br/><br/> At 308, the predicted next encoded media item is pre-decoded (i.e., decoded before any request to display the item is received) to generate a pre-decoded media item.  For example, the retrieved JPEG image is uncompressed into a bitmap image.
<br/><br/> At 310, the pre-decoded media item is stored in a second memory.  For example, referring to FIG. 2, the bitmap image is stored in memory 204.
<br/><br/> At 312, an indication that a second scrolling action has begun is received.  In some embodiments, the indication corresponds to an event that is initiated upon the start of the second scrolling action.
<br/><br/> At 314, it is determined if the next item to be displayed in response to the second scrolling action matches the predicted next item.  If so, at 316, the pre-decoded media item that is stored in the second memory is retrieved and displayed in
response to the second scrolling action; otherwise, at 318, the next item to be displayed (which is not necessarily pre-decoded) in response to the second scrolling action is determined and displayed.
<br/><br/> Although the above process describes predicting a single next item, in some embodiments, multiple predicted next encoded media items to be displayed are determined, retrieved, decoded, and displayed.
<br/><br/> FIG. 4 is a flowchart illustrating an embodiment of a process for determining the next encoded media item to be displayed.  In some embodiments, process 400 is used to implement 304 or 318 of process 300.
<br/><br/> At 402, the position of the last media item that was decoded and displayed in response to the first scrolling action is determined.
<br/><br/> It is assumed that when a user scrolls to view the media items, he will often scroll in the same direction as he has been.  At 404, based on the position of the last decoded item and the display layout, and following the direction of the first
scrolling action, the position(s) of the next M media item(s) is (are) determined.  Assume that the position of the last media item is N, then the positions of the next M media items are N+1, .  . . , N+M.  The value of M is an integer greater or equal
to 1.  The next M media items can be the predicted next encoded media items (if 400 is used to implement step 304) or the next M media items to be displayed (if 400 is used to implement step 418).
<br/><br/> The value of M is configurable.  In some embodiments, the value of M is determined empirically or based on system memory availability in some embodiments.  While a high M is desirable for buffering a greater number of bitmap images in memory
cache and minimizing delays in displaying the images, too high an M can cause recently displayed media items to be evicted from memory cache, leading to display stutter should the user reverse scrolling direction.  Thus, in some embodiments, the value of
M is chosen such that the probability of the last decoded and displayed image to be evicted from memory cache (or equivalently, the probability of encountering display stutter when scrolling direction is reversed) is below some threshold.  In the
following discussion, it is assumed that M=1, although other values of M can be used.
<br/><br/> Process 400 is further explained in connection with FIGS. 5A-5C.  FIGS. 5A-5C are diagrams illustrating the determination of the predicted next encoded media item.  In this example, images are sequentially numbered in the same order in which
they are stored at the server.  In FIG. 5A, images 2, 3, and 4 are displayed on screen 500 in a column, and images 1 and 5 are currently not displayed (but shown in dashed boxes to indicate their relative positions).  If the direction of the first
scrolling action is up, as illustrated by arrow 502, then, in step 402, the location of the last item that was decoded in response to the first scrolling action is determined to be 4.  In step 404, based on the position of the last decoded item and the
vertical display layout, and following the direction of the first scrolling action, the position of the predicted next encoded media item is image 5.  If the direction of the first scrolling action is down, as illustrated by arrow 504, the predicted next
encoded media item is image 1.  In FIG. 5B, images 2, 3, and 4 are displayed on screen 500 in a row.  Similarly, the direction of the first scrolling action is to the left, as illustrated by arrow 506, the predicted next encoded media item is image 5. 
If the direction of the first scrolling action is to the right, as illustrated by arrow 508, the predicted next encoded media item is image 1.
<br/><br/> Other display schemes are possible and the determination of the last item that was decoded and displayed can depend on the direction of the user scrolling action.  For example, the images can also be displayed in a two-dimensional grid as shown
in FIG. 5C.  In this example, images 7-9, 12-14, and 17-19 are currently displayed on screen 500 while the rest of the images (represented using dashed boxes) are not displayed.  A mapping of specific image positions and the direction of the user
scrolling action is used to determine which image is deemed to be the last decoded item.  For example, if the user scrolls in the direction according to arrow 510, the last item that was decoded is deemed to be image 9 and the predicted next encoded
media item is image 5.  If the user scrolls in the opposite direction as arrow 510, the last item that was decoded is deemed to be item 17 and the predicted next encoded media item is image 21.
<br/><br/> FIG. 6 is a flowchart illustrating an embodiment of a process for pre-decoding the predicted next encoded media item.  In some embodiments, process 600 is used to implement step 308 of process 300.
<br/><br/> If it is assumed that M=1, then at 602, it is determined whether the predicted next encoded media item has already been decoded.  In some embodiments, the determination is made by checking whether a Bitmap object associated with the predicted
next encoded media item already exists in the system heap.  If decoding has taken place (e.g., the user has already scrolled through/viewed the predicted next encoded media item), there is no need to decode the item again and the process proceeds to step
606.
<br/><br/> If decoding has not taken place, the predicted next encoded media item is decoded.  Specifically, at 604, a Bitmap object corresponding to the predicted next encoded media item is created based on the Bitmap class provided by the programming
framework for the device (e.g., Java.RTM.  for Android.RTM.).  The Bitmap class provides various attributes and methods associated with the behaviors and states of a Bitmap object.  According to existing APIs and the Bitmap class definition provided by
Android.RTM.  platform, when a Bitmap object is created, it is stored in a system heap and is managed by ashmem.  The Bitmap object includes the actual decoded bitmap image data as one of its attributes.  However, there is no guarantee that the actual
bitmap image data is inflated within the Bitmap object (i.e., no guarantee that the actual bitmap data has been generated and is stored in cache memory on the system heap), only that when the actual bitmap image data is needed (e.g., as requested by
another API call), it will be made available.  In other words, the Bitmap class does not necessarily decode the JPEG files into actual bitmap image data as soon as the Bitmap object is created, but may perform the decoding process and generate the actual
bitmap image data later on an as-needed basis.  This artifact of Bitmap implementation can result in stutter when the predicted next encoded media item needs to be displayed, since some time is needed to generate the actual bitmap image data.  To address
this issue, at 606, a function call is invoked to ensure that the actual decoded bitmap image data is generated and stored in cache.  Any function call that generates the actual decoded bitmap image data can be used, including those for which the
generation of the actual decoded bitmap image data is incidental to the functions' main purpose.  For example, a function call to obtain the entire decoded bitmap can be used; however, the return value (e.g., the entire bitmap) is returned to the
application heap, and would occupy valuable application heap space before the bitmap is needed.  Thus, preferably, the function call should return a minimal amount of data.  An example of such a function call is Bitmap.GetPixel, which requests the value
of a single pixel in the Bitmap object by decoding the actual bitmap image data and loading it into cache memory in the system heap.  When another function call is invoked for displaying the bitmap image in response to a second scrolling action, there is
a cache hit and the bitmap image data is provided to the function call without delay.  The result of the function call is returned to the application heap, which has very limited memory.  By getting the value of just one pixel, a minimal amount of space
is taken up in the application heap.
<br/><br/> Process 600 is further explained in connection with FIGS. 7A-7D.  FIGS. 7A-7D illustrate example data structures that appear in different parts of the memory during the scrolling process.  The memory layout is similar to what is shown in FIG. 2. Initially, as shown in FIG. 7A, encoded media items, specifically JPEG files numbered 1-5, are downloaded from the server onto first memory 202.  The number of files is for purposes of illustration only and a different number of files can be present in
other embodiments.  Once the user begins the first scrolling action, Bitmap objects are created in second memory 204, specifically in system heap 208.  In this example, as shown in FIG. 7B, Bitmap objects corresponding to JPEG files 1-4 are created.  It
is determined that item 4 is the last decoded item in response to the scrolling action.  In this example, the system heap only has enough space to store three decoded bitmap images.  Thus, only Bitmap objects 2-4 have corresponding decoded bitmap image
data in the system heap, and the bitmap image data corresponding to Bitmap object 1 has been evicted and no longer exists in the system heap.  FIG. 7C shows that upon determining that item 5 is the predicted next encoded media item to be displayed, and
that item 5 has not yet been decoded (step 602), a Bitmap object corresponding to item 5 is created in system heap 208 (step 604).  At this point, JPEG file 5 has not yet been decoded and the actual decoded bitmap image data is not yet available in the
system heap.  Next, a GetPixel call is made on Bitmap object 5 (step 606).  As shown in FIG. 7D, at this point, JPEG file 5 is decoded, and the corresponding actual decoded bitmap image data is created in system cache.  The decoded bitmap image data for
Bitmap object 2, however, is evicted from memory to make room for the bitmap of Bitmap object 5.
<br/><br/> Predictive pre-decoding of encoded media items has been disclosed.  Although the embodiments described above use JPEG files for purposes of illustration, the technique is also applicable to other encoded media item types.  For example, the
encoded media items can include compressed video files (e.g., Moving Picture Experts Group (MPEG) files) for which selected frames are used to represent the media items and displayed to the user.
<br/><br/> Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding, the invention is not limited to the details provided.  There are many alternative ways of implementing the invention.  The disclosed
embodiments are illustrative and not restrictive.
<br/><br/><center><b>* * * * *</b></center>
<hr/>
   <center>
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09377940&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D198%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D4%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>
   <table>
   <tbody><tr><td align="center"><a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D198%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D4%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209377940"><img alt="[View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9377940&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D198%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D4%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209377940">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
     <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=198&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=3&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=198&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=4&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=198&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=5&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=197&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=4&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=199&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=4&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

   <a href="#top"><img alt="[Top]" border="0" src="/netaicon/PTO/top.gif" valign="middle"/></a>
   </td></tr>
   </tbody></table>
   <a name="bottom"></a>
   <a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
   </center>

</coma></body></html>
<html><head>
<base target="_top"/>
<title>United States Patent: 9292594</title></head>
<!---BUF1=9292594
BUF7=2016
BUF8=174558
BUF9=/1/
BUF51=9
---->
<body bgcolor="#FFFFFF">
<a name="top"></a>
<center>
<img alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" src="/netaicon/PTO/patfthdr.gif"/>
<br/>
<table>
<tbody><tr><td align="center">
<a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
<a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
<a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
</td></tr>
<tr><td align="center">
   <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1005&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=20&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1005&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=21&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1005&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=22&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1004&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=21&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1006&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=21&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

<a href="#bottom"><img alt="[Bottom]" border="0" src="/netaicon/PTO/bottom.gif" valign="middle"/></a>
</td></tr>
   <tr><td align="center">
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1005%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D21%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209292594"><img alt="[
View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9292594&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1005%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D21%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209292594">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09292594&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D1005%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D21%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>

   </td></tr>
</tbody></table>
</center>
<table width="100%">
<tbody><tr><td align="left" width="50%"> </td>
<td align="right" valign="bottom" width="50%"><font size="-1">( <strong>1005</strong></font> <font size="-2">of</font> <strong><font size="-1">7895</font></strong> <font size="-1">)</font></td></tr></tbody></table>
<hr/>
   <table width="100%">
   <tbody><tr>	<td align="left" width="50%"><b>United States Patent </b></td>
   <td align="right" width="50%"><b>9,292,594</b></td>
   </tr>
     <tr><td align="left" width="50%"><b>
         Isaacson
,   et al.</b>
     </td>
     <td align="right" width="50%"> <b>
     March 22, 2016
</b></td>
     </tr>
     </tbody></table>
       <hr/>
       <font size="+1">Harvesting relevancy data, including dynamic relevancy agent based on
     underlying grouped and differentiated files
</font><br/>
       <br/><center><b>Abstract</b></center>
       <p> Methods and apparatus teach a digital spectrum of a file representing
     underlying original data. The digital spectrum is used to map a file's
     position. This position relative to another file's position reveals
     closest neighbors. When multiple such neighbors are grouped together they
     can be used to indicate relevance in current data under consideration on
     a same or different computing device. Also, relevance can be found
     without traditional notions of needing structured data or users
     initiating searching for relevance or by examining
     metadata/administrative information associated with the files. A dynamic
     relevancy agent is configured for installation on the same or different
     computing device to monitor events regarding the current data and to
     initiate the examination of relevancy. It also presents to a user
     suggestions of data closest to the current data. Various triggering
     events to undertake a relevancy examination are also described as are
     predetermined criteria to define relative closeness.
</p>
       <hr/>
<table width="100%"> <tbody><tr> <th align="left" scope="row" valign="top" width="10%">Inventors:</th> <td align="left" width="90%">
 <b>Isaacson; Scott A.</b> (Woodland Hills, UT)<b>, Muir; Kenneth W.</b> (Bountiful, UT) </td> </tr>
<tr><th align="left" scope="row" valign="top" width="10%">Applicant: </th><td align="left" width="90%"> <table> <tbody><tr> <th align="center" scope="column">Name</th> <th align="center" scope="column">City</th> <th align="center" scope="column">State</th> <th align="center" scope="column">Country</th> <th align="center" scope="column">Type</th> </tr> <tr> <td> <b><br/>Isaacson; Scott A.
<br/>Muir; Kenneth W.</b> </td><td> <br/>Woodland Hills
<br/>Bountiful </td><td align="center"> <br/>UT
<br/>UT </td><td align="center"> <br/>US
<br/>US </td> <td align="left"> </td> </tr> </tbody></table>
<!-- AANM>
~AANM Isaacson; Scott A.
~AACI Woodland Hills
~AAST UT
~AACO US
~AANM Muir; Kenneth W.
~AACI Bountiful
~AAST UT
~AACO US
</AANM -->
</td></tr>
<tr> <th align="left" scope="row" valign="top" width="10%">Assignee:</th>
<td align="left" width="90%">

<b>Novell, Inc.</b>
 (Provo, 
UT)
<br/>

</td>
</tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Family ID:
       </th><td align="left" width="90%">
       <b>44514429
</b></td></tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Appl. No.:
       </th><td align="left" width="90%">
       <b>12/720,897</b></td></tr>
       <tr><th align="left" scope="row" valign="top" width="10%">Filed:
       </th><td align="left" width="90%">
       <b>March 10, 2010</b></td></tr>
     </tbody></table>
<hr/> <center><b>Prior Publication Data</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Document Identifier</u></b></th><th align="center" scope="col"><b><u>Publication Date</u></b></th></tr><tr><td align="center"> </td><td align="center"> US 20110225154 A1</td><td align="center">Sep 15, 2011</td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table>
     <hr/>
<p> <table width="100%"> <tbody><tr><td align="left" valign="top" width="30%"><b>Current U.S. Class:</b></td> <td align="right" valign="top" width="70%"><b>1/1</b> </td></tr> 
       <tr><td align="left" valign="top" width="30%"><b>Current CPC Class: </b></td>
       <td align="right" valign="top" width="70%">G06F 17/30625 (20130101); G06F 17/30598 (20130101)</td></tr>
         <tr><td align="left" valign="top" width="30%"><b>Current International Class: </b></td>
         <td align="right" valign="top" width="70%">G06F 17/30 (20060101)</td></tr>
       <tr><td align="left" valign="top" width="30%"><b>Field of Search: </b></td>
       <td align="right" valign="top" width="70%">
       



 ;707/736,758,780 ;1/1
       </td></tr>
     </tbody></table>
</p><hr/><center><b>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=PALL&amp;Query=ref/9292594">[Referenced By]</a></b></center>       <hr/>
       <center><b>U.S. Patent Documents</b></center>
<table width="100%"> <tbody><tr><th scope="col" width="33%"></th> <th scope="col" width="33%"></th> <th scope="col" width="34%"></th></tr> <tr> <td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5561421">5561421</a></td><td align="left">
October 1996</td><td align="left">
Smith et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6667700">6667700</a></td><td align="left">
December 2003</td><td align="left">
McCanne et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6906645">6906645</a></td><td align="left">
June 2005</td><td align="left">
Jones et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F7026960">7026960</a></td><td align="left">
April 2006</td><td align="left">
Lee et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F7026962">7026962</a></td><td align="left">
April 2006</td><td align="left">
Emami et al.</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F7031910">7031910</a></td><td align="left">
April 2006</td><td align="left">
Eisele</td></tr><tr><td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F7417568">7417568</a></td><td align="left">
August 2008</td><td align="left">
Fallon et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20020113818&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2002/0113818</a></td><td align="left">
August 2002</td><td align="left">
Tsuda</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20020167429&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2002/0167429</a></td><td align="left">
November 2002</td><td align="left">
Kim</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030078899&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2003/0078899</a></td><td align="left">
April 2003</td><td align="left">
Shanahan</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030149727&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2003/0149727</a></td><td align="left">
August 2003</td><td align="left">
Jaschek et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030220922&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2003/0220922</a></td><td align="left">
November 2003</td><td align="left">
Yamamoto et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20050008227&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2005/0008227</a></td><td align="left">
January 2005</td><td align="left">
Duan et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20060285760&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2006/0285760</a></td><td align="left">
December 2006</td><td align="left">
Malvar</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20070043718&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2007/0043718</a></td><td align="left">
February 2007</td><td align="left">
Arellanes et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20070168320&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2007/0168320</a></td><td align="left">
July 2007</td><td align="left">
Borthakur et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080126858&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0126858</a></td><td align="left">
May 2008</td><td align="left">
Barras</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080147646&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0147646</a></td><td align="left">
June 2008</td><td align="left">
Jaschek et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080154928&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0154928</a></td><td align="left">
June 2008</td><td align="left">
Bashyam et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080243518&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0243518</a></td><td align="left">
October 2008</td><td align="left">
Oraevsky et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20090018801&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2009/0018801</a></td><td align="left">
January 2009</td><td align="left">
Gladkova et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20090018996&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2009/0018996</a></td><td align="left">
January 2009</td><td align="left">
Hunt et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20090083232&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2009/0083232</a></td><td align="left">
March 2009</td><td align="left">
Ives et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20090144561&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2009/0144561</a></td><td align="left">
June 2009</td><td align="left">
Davidson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110016098&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0016098</a></td><td align="left">
January 2011</td><td align="left">
Teerlink</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110016101&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0016101</a></td><td align="left">
January 2011</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110016124&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0016124</a></td><td align="left">
January 2011</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110016135&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0016135</a></td><td align="left">
January 2011</td><td align="left">
Teerlink</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110016136&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0016136</a></td><td align="left">
January 2011</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110016138&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0016138</a></td><td align="left">
January 2011</td><td align="left">
Teerlink</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20110252063&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2011/0252063</a></td><td align="left">
October 2011</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120179680&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0179680</a></td><td align="left">
July 2012</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120197895&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0197895</a></td><td align="left">
August 2012</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20120290574&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2012/0290574</a></td><td align="left">
November 2012</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20150058304&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2015/0058304</a></td><td align="left">
February 2015</td><td align="left">
Isaacson et al.</td></tr><tr><td align="left">

</td>
</tr> </tbody></table>
<table width="90%">   <tbody><tr><td><align="left"><br/>http.//www.cs cmu.edu/.about.gbd/papers/davis05fog.pdf "Clearing the FOG: Fuzzy, Overlapping Groups for Social Networks": George B. Davis and Kathleen M.
Carley Undated 45 Pages. cited by applicant
.<br/>http://figment.csee.usf.edu/.about.sfefilat/data/papers/TuAT1.4pdf "Beyond Partitions: Allowing Overlapping Groups in Pairwise Clustering", Andrea Torsello, Samuel Rota Bul'o, and Marcello Pelillo Copyright 2008 4 Pages. cited by applicant
.<br/>http://www.nature.com/nature/journal/v435/n7043/extref/nature03607-s1.pdf "Uncovering the overlapping community structure of complex networks in nature and society", Gergely Palla, Imre Derenyi, Illes Farkas &amp; Tamas Vicsek Undated 12 Pages. cited by
applicant
.<br/>http://74.125.47.132/search?q=cacno http://fuzzy inu clu di/download/ddfm ppl "Date driven Fuzzy Modeling" U Kaymak Oct. 1, 2001 49 Pages. cited by applicant
.<br/>http://sequitur.info/jair/ "Identifying Hierarchical Structure in Sequences: A Linear-Time Algorithm", Craig G. Nevill-Manning and Ian H. Witten Printed Oct. 27, 2008 16 Pages. cited by applicant
.<br/>http://en.wikipedia.org/wiki/Sequitur.sub.--algorithm "Sequitur algorithm" Last modified on Oct. 2, 2008 2 Pages. cited by applicant
.<br/>http://arxiv.org/ftp/arxiv/papers/0801/0801.4024.pdf "Set-based Complexity and Biological Information", David J. Galas, Matti Nykter, Gregory W. Carter,Nathan D. Price and Ilya Shmulevich Jan. 11, 2009 30 Pages. cited by applicant
.<br/>Agent-based reduction of information density (ARID) demonstration International Conference of Autonomous Agents, Proceedings of the 6th international joint conference on Autonomous agents and multiagent systems, Stephen O'Hara, Nathan Dwyer Year of
Publivation: 2007 Abstract printed from Portal.com Feb. 1, 2010 2 Pages. cited by applicant
.<br/>Artificial Intelligence in Engineering, vol. 12, Issues 1-2, Jan.-Apr. 1998, pp. 99-105, Recognizing patterns in information retrieval: a memory-based classifier for inferring relevancy, Hrishikesh Aradhye and A. Sharif Heger Abstract printed from
ScienceDirect.com Feb. 1, 2010 2 Pages. cited by applicant
.<br/>"European Application Serial No. 11157556.9, Extended Search Report mailed Jan. 24, 2012", 8 pgs. cited by applicant
.<br/>"European Application Serial No. 11157556.9--Office Action Received", 5 pgs. cited by applicant
.<br/>"European Application Serial No. 11157556.9, Summons to Attend Oral Proceedings mailed May 18, 2015", 7 pgs. cited by applicant
.<br/>Cherniavsky, Neva, "Grammar-based compression of DNA sequences", [Online]. Retrieved from the Internet: &lt;URL: http://www.cs.washington.edu/homes/mchermia/dnasequitur/quals.pdf&gt;, (2004), 14 pgs. cited by applicant
.<br/>Torsello, Andrea, et al., "Beyond Partitions: Allowing Overlapping Groups in Pairwise Clustering", (2008), 4 pgs. cited by applicant. </align="left"></td></tr> </tbody></table><br/><center><b>Other References</b></center> <br/>
       <i>Primary Examiner:</i> Truong; Dennis
<br/>
       <i>Attorney, Agent or Firm:</i> <coma>Schwegman Lundberg &amp; Woessner, P.A.
<br/>
         <hr/>
<center><b><i>Claims</i></b></center> <hr/> <br/><br/>The invention claimed is: <br/><br/> 1.  In a computing system environment, a method of finding relevancy data available on one or more computing devices, comprising: monitoring computing events on the one
or more computing devices relative to current data;  triggering an evaluation of the current data against original data earlier grouped together on the one or more computing devices according to relatedness of the original data based on the monitored
events, the evaluation processing ordered symbol frequency vectors and ordered bit vectors for the current data and the original data to determine relatedness, and at least one vector contains one coordinate position for a set of symbols defined in a
symbol dictionary for the original data, and wherein each symbol frequency vector includes a count for a number of times each particular symbol occurs within a given file's symbol dictionary, and wherein each bit vector includes a single bit representing
each unique symbol within a given file's symbol dictionary, and wherein triggering further includes determining a common file of members grouped together in response to the evaluation;  adding semantic meaning and metadata to the grouped to tether data
by harvesting unions of the members that share the common file;  and suggesting offerings that some other body of data exists that may be of interest to the current data based on the added semantic meaning and the metadata, and presenting the suggested
offerings in a separate user interface for a user to explore when the user choses to do so.
<br/><br/> 2.  The method of claim 1, further including configuring an agent on the one or more computing devices to undertake the evaluation.
<br/><br/> 3.  The method of claim 1, wherein the triggering the evaluation occurs without the user request to find the relevancy data.
<br/><br/> 4.  The method of claim 1, further including presenting to the user of the one or more computing devices a suggestion of the original data most related to the current data.
<br/><br/> 5.  The method of claim 1, further including defining a mapping space for the current and original data, wherein the evaluation includes determining a distance between the current and original data as oriented in said mapping space.
<br/><br/> 6.  The method of claim 1, further including establishing a predetermined criterion of data closeness for the evaluation.
<br/><br/> 7.  A computer program product available on a non-transitory computer readable medium for loading on a computing device in a computing system environment, the computer program product configured for finding relevancy data available on a same or
different said computing device, comprising executable instructions for configuring an agent to operate on a processor of the computing device to monitor computing events on the same or different said computing device relative to current data;  and to
evaluate upon a triggering event the current data against original data earlier grouped together on the same or different said computing device according to relatedness of the original data, the evaluation processes ordered symbol frequency vectors and
ordered bit vectors for the current data and the original data to determine relatedness and at least one vector contains one coordinate position for a set of symbols defined in a symbol dictionary for the original data, and wherein each symbol frequency
vector includes a count for a number of times each particular symbol occurs within a given file's symbol dictionary, and wherein each bit vector includes a single bit representing each unique symbol within a given file's symbol dictionary, and wherein
the evaluation further includes determining a common file of members grouped together in response to the evaluation;  to add semantic meaning and metadata to the grouped together data by harvesting unions of the members that share the common file to
suggest offerings that some other body of data exists that may of interests to the current data based on the semantic meaning and the metadata data, and the suggested offerings presented in a separate user interface for a user to explore when the user
choses to do so.
<br/><br/> 8.  The computer program product of claim 7, further including executable instructions for presenting to the user of the same or different said computing device a suggestion of data closest to the current data.
<br/><br/> 9.  The computer program product of claim 8, further including executable instructions for said evaluating the current data against the original data in an N dimensional mapping space defined by a total number of different pluralities of
symbols, the pluralities of symbols representing an underlying data stream of original bits in the original data.
<br/><br/> 10.  The computer program product of claim 7, further including executable instructions for configuring the triggering event to occur on the same or different said computing device without any input of the user indicating a desire to receive the
relevancy data.
<br/><br/> 11.  The computer program product of claim 7, further including executable instructions for monitoring computing events on the same or different said computing device for the agent to determine an occurrence of the triggering event.
<br/><br/> 12.  The computer program product of claim 8, further including executable instructions for receiving an input from the user to examine the suggested said data closest to the current data and retaining the current data to improve future
suggestions regarding future data upon a second triggering event to evaluate the future data against the original data and the current data.
<br/><br/> 13.  The computer program product of claim 7, further including executable instructions for defining a predetermined criterion of data closeness.
<br/><br/> 14.  In a computing system environment, a method of finding relevancy data available on one or more computing devices, comprising: configuring an agent on the one or more computing devices;  grouping files of original data stored on the one or
more computing devices, each file having a plurality of symbols representing an underlying data stream of original bits of data;  upon a trigger event, the configured agent determining which said groupings of files are most relevant to current data under
consideration on the one or more computing devices the agent using ordered symbol frequency vectors and ordered bit vectors for the current data and the files to determine relatedness and at least one vector contains one coordinate position for a set of
symbols defined in a symbol dictionary for the files, and wherein each symbol frequency vector includes a count for a number of times each particular symbol occurs within a given file's symbol dictionary, and wherein each bit vector includes a single bit
representing each unique symbol within a given file's symbol dictionary, wherein determining further includes determining a common file of members grouped together in response to the determination of relatedness;  adding semantic meaning and metadata to
the groupings of files by harvesting unions of the members that share the common file;  and suggesting offerings that some other body of data exists that may be of interest to the current data based on the semantic meaning and the metadata, and
presenting the suggested offerings in a separate user interface for a user to explore when the user choses to do so.
<br/><br/> 15.  The method of claim 14, wherein the determining which said groupings of files are said most relevant to the current data under consideration further includes avoiding examining any history of the user.
<br/><br/> 16.  The method of claim 14, further including presenting to the user of the one or more computing devices a suggestion of data closest to the current data.
<br/><br/> 17.  The method of claim 16, further including defining a mapping space by a total number of different said plurality of symbols, wherein the suggestion of said data closest to the current data further includes determining a distance between
said closest data and the current data as oriented in said mapping space.
<br/><br/> 18.  The method of claim 14, wherein the trigger event is exclusively initiated by the configured agent to find the relevancy data without any input of the user of the one or more computing devices indicating a desire to receive the relevancy
data.
<br/><br/> 19.  The method of claim 14, further including monitoring computing events on the one or more computing devices by the configured agent to determine occurrence of the trigger event.
<br/><br/> 20.  The method of claim 14, wherein the determining which said groupings of files are said most relevant to the current data under consideration further includes establishing a predetermined criteria of data closeness. <hr/>
<center><b><i>Description</i></b></center> <hr/> <br/><br/>FIELD OF THE INVENTION
<br/><br/> The present invention relates generally to compression/decompression of data.  More particularly, it relates to defining a digital spectrum of a data file in order to determine properties that can be compared to other files.  In this manner,
file similarity, file adjacency and file grouping, to name a few, can be determined.  Once sorted, these underlying files create bodies of data that can be examined for relevance regarding current data under consideration.  Computing agents, computing
configurations, and computer program products are still other features.
<br/><br/>BACKGROUND OF THE INVENTION
<br/><br/> Recent data suggests that nearly eighty-five percent of all digital data is found in unstructured files and it is growing annually at around sixty percent.  One reason for the growth is that regulatory compliance acts, statutes, etc., (e.g.,
Sarbanes-Oxley, HIPAA, PCI) force companies to keep file data in an accessible state for extended periods of time.  However, block level operations in computers are too lowly to apply any meaningful interpretation of this stored data beyond taking
snapshots and block de-duplication.  While other business intelligence products have been introduced to provide capabilities greater than block-level operations, they have been generally limited to structured database analysis.  They are much less
meaningful when acting upon data stored in unstructured environments.
<br/><br/> Unfortunately, entities the world over have paid enormous sums of money to create and store their data, but cannot find much of it later in instances where it is haphazardly arranged or arranged less than intuitively.  Not only would locating
this information bring back value, but being able to observe patterns in it might also prove valuable despites its usefulness being presently unknown.  However, entities cannot expend so much time and effort in finding this data that it outweighs its
usefulness.  Notwithstanding this, there are still other scenarios, such as government compliance, litigation, audits, etc., that dictate certain data/information be found and produced, regardless of its cost in time, money and effort.  Thus, a clear
need is identified in the art to better find, organize and identify digital data, especially data left in unstructured states.
<br/><br/> In search engine technology, large amounts of unrelated and unstructured digital data can be quickly gathered.  However, most engines do little to organize the data other than give a hierarchical presentation.  Also, when the engine finds
duplicate versions of data, it offers few to no options on eliminating the replication or migrating/relocating redundancies.  Thus, a further need in the art exists to overcome the drawbacks of search engines.
<br/><br/> When it comes to large amounts of data, whether structured or not, compression techniques have been devised to preserve storage capacity, reduce bandwidth during transmission, etc. With modern compression algorithms, however, they simply exist
to scrunch large blocks of data into smaller blocks according to their advertised compression ratios.  As is known, some do it without data loss (lossless) while others do it "lossy." None do it, unfortunately, with a view toward recognizing similarities
in the data itself.
<br/><br/> From biology, it is known that highly similar species have highly similar DNA strings.  In the computing context, consider two word processing files relating to stored baseball statistics.  In a first file, words might appear for a baseball
batter, such as "batting average," "on base percentage." and "slugging percentage," while a second file might have words for a baseball pitcher, such as "strikeouts," "walks." and "earned runs." Conversely, a third file wholly unrelated to baseball,
statistics or sports, may have words such as "environmental protection." "furniture," or whatever comes to mind.  It would be exceptionally useful if, during times of compression, or upon later manipulation by an algorithm if "mapping" could recognize
the similarity in subject matter in the first two files, although not exact to one another, and provide options to a user.  Appreciating that the "words" in the example files are represented in the computing context as binary bits (1's or 0's), which
occurs by converting the English alphabet into a series of 1's and 0's through application of ASCII encoding techniques, it would be further useful if the compression algorithm could first recognize the similarity in subject matter of the first two files
at the level of raw bit data.  The reason for this is that not all files have words and instead might represent pictures (e.g., .jpeg) or spread sheets of numbers.
<br/><br/> Appreciating that certain products already exist in the above-identified market space, clarity on the need in the art is as follows.  One, present day "keyword matching" is limited to select set of words that have been pulled from a document
into an index for matching to the same exact words elsewhere.  Two, "Grep" is a modern day technique that searches one or more input files for lines containing an identical match to a specified pattern.  Three.  "Beyond Compare," and similar algorithms,
are line-by-line comparisons of multiple documents that highlight differences between them.  Four, block level data de-duplication has no application in compliance contexts, data relocation, or business intelligence.
<br/><br/> In modern day "relevancy" systems, most, if not all, utilize explicit user interaction to harvest relevancy data.  For example:
<br/><br/> Amazon.com: Users purchase books or other products and Amazon suggests other books and products that the user might find interesting based on books/products that were purchased by others who bought the same exact book/product.  However, Amazon's
relevancy engine would not work if people did not buy books/products at the Amazon website.  Also, the more that people make purchases, especially books at the same time, the more data points Amazon has to find relevant data.  Conversely, if no one has
ever made an exactly similar purchase, Amazon has no mechanism to make suggestions to other people other than by way of keyword associations.
<br/><br/> Netflix.com: Users rent movies, and place others in waiting queues, and Netflix suggests other movies that the user might find interesting.  Similar to Amazon, however, this approach relies on others watching or selecting those same exact
movies.  The same is true at Fandango.com, whereby Fandango suggests movies to users based on same ticket purchases by other users.
<br/><br/> Online store web analytics: Users browse through online web stores or online catalogs and web analytic software determines a length of stay on a page, how many times the page or site is revisited, what else occurred during visitation, etc. In
turn, new merchandise, package deals, coupons, etc. are suggested for purchase/downloading by the user.
<br/><br/> Social Networking sites, e.g., <b><i>Facebook,</i></b> LinkedIn, Plaxo, etc.: These all suggest "friends" that users might want to "connect with" based on meta data and other associations with connections to common friends and their connections/friends, and
so on.  Similarly, websites such as Flickr, YouTube, pandora.com, etc., offer relevancy services, but they are all founded on structured data as well as input form other users.
<br/><br/> At Hunch.com, Hunch offers the tagline: "Hunch helps you make decisions and gets smarter the more you use it." In other words, Hunch develops more knowledge the more it is trained, either explicitly or by people using its services, which is
recorded.  This is then harvested for finding relevant data.
<br/><br/> In ISBN 10: 0-596-52932-5| ISBN 13: 9780596529321 "Programming Collective Intelligence." Toby Segaran, O'Reilly, basic algorithms are used to "demonstrate[ ] how you can build web applications to mine the enormous amount of data created by
people on the Internet.  With the sophisticated algorithms in this book, you can write smart programs to access interesting datasets from other web sites, collect data from users of your own applications, and analyze and understand the data once you've
found it."
<br/><br/> While no shortage exists in the art directed to finding relevant data, or not, based on user's actions, there is a dearth of knowledge when users involve themselves with unstructured data, a lack of history or other record keeping, and user
collaboration, to name a few, especially in real time.  As such, a need exists to find relevancy information when no action has occurred by an individual or collaborative team to explicitly or implicitly start the process of finding it.  Above and
beyond, the need further extends to finding this information in unstructured data where no database, no meta data, etc., exists, as well as finding it in traditionally structured data (e.g., the foregoing movie example with a database storing movie meta
data such as type, genre, rating, content, keywords, actors, directors, etc. as well as the number of users who have rented the movie, and indicia of those users).
<br/><br/> On a grander scale, the need extends even further to serve advanced notions of identifying new business intelligence, conducting operations on completely haphazard data, and organizing it, providing new useful options to users, providing new
user views, providing new encryption products, and identifying highly similar data, to name a few.  As a byproduct, solving this need will create new opportunities in minimizing transmission bandwidth and storage capacity, among other things.  Naturally,
any improvements along such lines should contemplate good engineering practices, such as stability, ease of implementation, unobtrusiveness, etc.
<br/><br/>SUMMARY OF THE INVENTION
<br/><br/> The foregoing and other problems are solved by applying the principles and teachings associated with harvesting relevancy data, including agents, based on underlying files that are earlier grouped and differentiated according to relatedness. 
Broadly, embodiments of the invention identify self-organizing, emergent patterns in data sets without any keyword, semantic, or meta-data processing.  This information is then used to indicate relevance in current data under consideration.  Ultimately,
a new paradigm emerges where users generate content, either individually or collaboratively, and relevant information becomes presented to them without requests or actions to produce or find it.  It even occurs in sources of unstructured data.
<br/><br/> In representative embodiments, methods and apparatus teach a digital spectrum of a file representing underlying original data.  The digital spectrum is used to map a file's position.  This position relative to another file's position reveals
closest neighbors.  When multiple such neighbors are grouped together they can be used to indicate relevance in current data under consideration on a same or different computing device.  Also, relevance can be found without traditional notions of users
initiating searching for relevance or by examining metadata or other administrative information associated with the files.  A dynamic relevancy agent is configured for installation on the same or different computing device to monitor events regarding the
current data and to initiate the examination of relevancy.  It also presents to a user suggestions of data closest to the current data.  Various triggering events to undertake a relevancy examination are also described as are predetermined criteria to
define relative closeness.
<br/><br/> In a computing context, original files are stored on computing devices.  As representatively encoded, they have pluralities of symbols representing an underlying data stream of original bits of data.  The original files are examined for
relationships between each of the files and grouped accordingly.  The current data is evaluated against these groupings.
<br/><br/> In certain embodiments, the relationships between files are defined according to distances in a multi-dimensional space.  The space size is defined as a function of numbers of symbols in the files.  In turn, the number of occurrences of each
symbol in each file is compared to like symbols in other files.  The differences in occurrences are then squared, added together, and a square root taken.
<br/><br/> Executable instructions loaded on one or more computing devices for undertaking the foregoing are also contemplated as are computer program products available as a download or on a computer readable medium.  The computer program products are
also available for installation on a network appliance or an individual computing device.
<br/><br/> These and other embodiments of the present invention will be set forth in the description which follows, and in part will become apparent to those of ordinary skill in the art by reference to the following description of the invention and
referenced drawings or by practice of the invention.  The claims, however, indicate the particularities of the invention. <br/><br/>BRIEF DESCRIPTION OF THE DRAWINGS
<br/><br/> The accompanying drawings incorporated in and forming a part of the specification, illustrate several aspects of the present invention, and together with the description serve to explain the principles of the invention.  In the drawings:
<br/><br/> FIG. 1 is a table in accordance with the present invention showing terminology;
<br/><br/> FIG. 2 a table in accordance with the present invention showing a tuple array and tuple nomenclature;
<br/><br/> FIG. 3 is a table in accordance with the present invention showing the counting of tuples in a data stream;
<br/><br/> FIG. 4 is a table in accordance with the present invention showing the Count from FIG. 3 in array form;
<br/><br/> FIG. 5 is Pythagorean's Theorem for use in resolving ties in the counts of highest occurring tuples;
<br/><br/> FIG. 6 is a table in accordance with the present invention showing a representative resolution of a tie in the counts of three highest occurring tuples using Pythagorean's Theorem;
<br/><br/> FIG. 7 is a table in accordance with the present invention showing an alternative resolution of a tie in the counts of highest occurring tuples;
<br/><br/> FIG. 8 is an initial dictionary in accordance with the present invention for the data stream of FIG. 9;
<br/><br/> FIGS. 8-60 are iterative data streams and tables in accordance with the present invention depicting dictionaries, arrays, tuple counts, encoding, and the like illustrative of multiple passes through the compression algorithm;
<br/><br/> FIG. 61 is a chart in accordance with the present invention showing compression optimization;
<br/><br/> FIG. 62 is a table in accordance with the present invention showing compression statistics;
<br/><br/> FIGS. 63-69 are diagrams and tables in accordance with the present invention relating to storage of a compressed file;
<br/><br/> FIGS. 70-82b are data streams, tree diagrams and tables in accordance with the present invention relating to decompression of a compressed file;
<br/><br/> FIG. 83 is a diagram in accordance with the present invention showing a representative computing device for practicing features of the invention;
<br/><br/> FIGS. 84-93 are diagrams in accordance with a "fast approximation" embodiment of the invention that utilizes key information of an earlier compressed file for a file under present consideration having patterns substantially similar to the
earlier compressed file;
<br/><br/> FIGS. 94-98A-B are representative terminology and diagrams in accordance with the present invention showing a "digital spectrum" embodiment of an encoded file, including grouping of files; and
<br/><br/> FIGS. 99-101 are flow charts and diagrams in accordance with the present invention showing the harvesting of relevancy data, including a dynamic relevancy agent.
<br/><br/>DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS
<br/><br/> In the following detailed description of the illustrated embodiments, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration, specific embodiments in which the invention may be
practiced.  These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and like numerals represent like details in the various figures.  Also, it is to be understood that other embodiments may be
utilized and that process, mechanical, electrical, arrangement, software and/or other changes may be made without departing from the scope of the present invention.  In accordance with the present invention, methods and apparatus are hereinafter
described for harvesting relevancy data, including relevancy agents in a computing environment.  Before then, however, optimizing data compression of digital data is described.
<br/><br/> In a representative embodiment, compression occurs by finding highly occurring patterns in data streams, and replacing them with newly defined symbols that require less space to store than the original patterns.  The goal is to eliminate as much
redundancy from the digital data as possible.  The end result has been shown by the inventor to achieve greater compression ratios on certain tested files than algorithms heretofore known.
<br/><br/> In information theory, it is well understood that collections of data contain significant amounts of redundant information.  Some redundancies are easily recognized, while others are difficult to observe.  A familiar example of redundancy in the
English language is the ordered pair of letters QU.  When Q appears in written text, the reader anticipates and expects the letter U to follow, such as in the words queen, quick, acquit, and square.  The letter U is mostly redundant information when it
follows Q. Replacing a recurring pattern of adjacent characters with a single symbol can reduce the amount of space that it takes to store that information.  For example, the ordered pair of letters QU can be replaced with a single memorable symbol when
the text is stored.  For this example, the small Greek letter alpha (.alpha.) is selected as the symbol, but any could be chosen that does not otherwise appear in the text under consideration.  The resultant compressed text is one letter shorter for each
occurrence of QU that is replaced with the single symbol (.alpha.), e.g. ".alpha.een." ".alpha.ick." "ac.alpha.it," and "s.alpha.are." Such is also stored with a definition of the symbol alpha (.alpha.) in order to enable the original data to be
restored.  Later, the compressed text can be expanded by replacing the symbol with the original letters QU.  There is no information loss.  Also, this process can be repeated many times over to achieve further compression.
<br/><br/>DEFINITIONS
<br/><br/> With reference to FIG. 1, a table 10 is used to define terminology used in the below compression method and procedure.
<br/><br/> Discussion
<br/><br/> Redundancy is the superfluous repetition of information.  As demonstrated in the QU example above, adjacent characters in written text often form expected patterns that are easily detected.  In contrast, digital data is stored as a series of
bits where each bit can have only one of two values: off (represented as a zero (0)) and on (represented as a one (1)).  Redundancies in digital data, such as long sequences of zeros or ones, are easily seen with the human eye.  However, patterns are not
obvious in highly complex digital data.  The invention's methods and procedures identify these redundancies in stored information so that even highly complex data can be compressed.  In turn, the techniques can be used to reduce, optimize, or eliminate
redundancy by substituting the redundant information with symbols that take less space to store than the original information.  When it is used to eliminate redundancy, the method might originally return compressed data that is larger than the original. 
This can occur because information about the symbols and how the symbols are encoded for storage must also be stored so that the data can be decompressed later.  For example, compression of the word "queen" above resulted in the compressed word
".alpha.een." But a dictionary having the relationship QU=.alpha.  also needed to be stored with the word ".alpha.een, which makes a "first pass" through the compression technique increase in size, not decrease.  Eventually, however, further "passes"
will stop increasing and decrease so rapidly, despite the presence of an ever-growing dictionary size, that compression ratios will be shown to greatly advance the state of the art.  By automating the techniques with computer processors and computing
software, compression will also occur exceptionally rapidly.  In addition, the techniques herein will be shown to losslessly compress the data.
<br/><br/> The Compression Procedure
<br/><br/> The following compression method iteratively substitutes symbols for highly occurring tuples in a data stream.  An example of this process is provided later in the document.
<br/><br/> Prerequisites
<br/><br/> The compression procedure will be performed on digital data.  Each stored bit has a value of binary 0 or binary 1.  This series of bits is referred to as the original digital data.
<br/><br/> Preparing the Data
<br/><br/> The original digital data is examined at the bit level.  The series of bits is conceptually converted to a stream of characters, referred to as the data stream that represents the original data.  The symbols 0 and 1 are used to represent the
respective raw bit values in the new data stream.  These symbols are considered to be atomic because all subsequently defined symbols represent tuples that are based on 0 and 1.
<br/><br/> A dictionary is used to document the alphabet of symbols that are used in the data stream.  Initially, the alphabet consists solely of the symbols 0 and 1.
<br/><br/> Compressing the Data Stream
<br/><br/> The following tasks are performed iteratively on the data stream: Identifying all possible tuples that can occur for the set of characters that are in the current data stream.  Determining which of the possible tuples occurs most frequently in
the current data stream.  In the case of a tie, use the most complex tuple.  (Complexity is discussed below.) Creating a new symbol for the most highly occurring tuple, and add it to the dictionary.  Replacing all occurrences of the most highly occurring
tuple with the new symbol.  Encoding the symbols in the data stream by using an encoding scheme, such as a path-weighted Huffman coding scheme.  Calculating the compressed file size.  Determining whether the compression goal has been achieved.  Repeating
for as long as necessary to achieve optimal compression.  That is, if a stream of data were compressed so completely that it was represented by a single bit, it and its complementary dictionary would be larger than the original representation of the
stream of data absent the compression.  (For example, in the QU example above, if ".alpha." represented the entire word "queen," the word "queen" could be reduced to one symbol, e.g., ".alpha.." However, this one symbol and its dictionary (reciting
"queen=.alpha." is larger than the original content "queen.") Thus, optimal compression herein recognizes a point of marginal return whereby the dictionary grows too large relative to the amount of compression being achieved by the technique.  Each of
these steps is described in more detail below.  Identifying all Possible Tuples
<br/><br/> From FIG. 1, a "tuple" is an ordered pair of adjoining characters in a data stream.  To identify all possible tuples in a given data stream, the characters in the current alphabet are systematically combined to form ordered pairs of symbols. 
The left symbol in the pair is referred to as the "first" character, while the right symbol is referred to as the "last" character.  In a larger context, the tuples represent the "patterns" examined in a data stream that will yield further advantage in
the art.
<br/><br/> In the following example and with any data stream of digital data that can be compressed according to the techniques herein, two symbols (0 and 1) occur in the alphabet and are possibly the only symbols in the entire data stream.  By examining
them as "tuples," the combination of the 0 and 1 as ordered pairs of adjoining characters reveals only four possible outcomes, i.e., a tuple represented by "00," a tuple represented by "01," a tuple represented by "10," and a tuple represented by "11."
<br/><br/> With reference to FIG. 2, these four possibilities are seen in table 12.  In detail, the table shows the tuple array for characters 0 and 1.  In the cell for column 0 and row 0, the tuple is the ordered pair of 0 followed by 0.  The shorthand
notation of the tuple in the first cell is "0&gt;0".  In the cell for column 0 and row 1, the tuple is 0 followed by 1, or "0&gt;1".  In the cell for column 1 and row 0, the tuple is "1&gt;0".  In the cell for column 1 and row 1, the tuple is "1&gt;1".
<br/><br/> Determining the Most Highly Occurring Tuple
<br/><br/> With FIG. 2 in mind, it is determined which tuple in a bit stream is the most highly occurring.  To do this, simple counting occurs.  It reveals how many times each of the possible tuples actually occurs.  Each pair of adjoining characters is
compared to the possible tuples and the count is recorded for the matched tuple.
<br/><br/> The process begins by examining the adjacent characters in position one and two of the data stream.  Together, the pair of characters forms a tuple.  Advance by one character in the stream and examine the characters in positions two and three. 
By incrementing through the data stream one character at a time, every combination of two adjacent characters in the data stream is examined and tallied against one of the tuples.
<br/><br/> Sequences of repeated symbols create a special case that must be considered when tallying tuples.  That is, when a symbol is repeated three or more times, skilled artisans might identify instances of a tuple that cannot exist because the symbols
in the tuple belong to other instances of the same tuple.  The number of actual tuples in this case is the number of times the symbol repeats divided by two.
<br/><br/> For example, consider the data stream 14 in table 16 (FIG. 3) having 10 characters shown as "0110000101." Upon examining the first two characters 01, a tuple is recognized in the form 0 followed by 1 (0&gt;1).  Then, increment forward one
character and consider the second and third characters 11, which forms the tuple of 1 followed by 1 (1&gt;1).  As progression occurs through the data stream, 9 possible tuple combinations are found: 0&gt;1, 1&gt;1, 1&gt;0, 0&gt;0, 0&gt;0, 0&gt;0, 0&gt;1,
1&gt;0, and 0&gt;1 (element 15, FIG. 3).  In the sequence of four sequential zeros (at the fourth through seventh character positions in the data stream "0110000101"), three instances of a 0 followed by a 0 (or 0&gt;0) are identified as possible tuples. 
It is observed that the second instance of the 0&gt;0 tuple (element 17, FIG. 3) cannot be formed because the symbols are used in the 0&gt;0 tuple before and after it, by prescribed rule.  Thus, there are only two possible instances in the COUNT 18, FIG.
3, of the 0&gt;0 tuple, not 3.  In turn, the most highly occurring tuple counted in this data stream is 0&gt;1, which occurs 3 times (element 19, FIG. 3).  Similarly, tuple 1&gt;1 occurs once (element 20, FIG. 3), while tuple 1&gt;0 occurs twice (element
21, FIG. 3).
<br/><br/> After the entire data stream has been examined, the final counts for each tuple are compared to determine which tuple occurs most frequently.  In tabular form, the 0 followed by a 1 (tuple 0&gt;1) occurs the most and is referenced at element 19
in table 22, FIG. 4.
<br/><br/> In the situation of a tie between two or more tuples, skilled artisans must choose between one of the tuples.  For this, experimentation has revealed that choosing the tuple that contains the most complex characters usually results in the most
efficient compression.  If all tuples are equally complex, skilled artisans can choose any one of the tied tuples and define it as the most highly occurring.
<br/><br/> The complexity of a tuple is determined by imagining that the symbols form the sides of a right triangle, and the complexity is a measure of the length of the hypotenuse of that triangle.  Of course, the hypotenuse is related to the sum of the
squares of the sides, as defined by the Pythagorean Theorem, FIG. 5.
<br/><br/> The tuple with the longest hypotenuse is considered the most complex tuple, and is the winner in the situation of a tie between the highest numbers of occurring tuples.  The reason for this is that less-complex tuples in the situation of a tie
are most likely to be resolved in subsequent passes in the decreasing order of their hypotenuse length.  Should a tie in hypotenuse length occur, or a tie in complexity, evidence appears to suggest it does not make a difference which tuple is chosen as
the most highly occurring.
<br/><br/> For example, suppose that tuples 3&gt;7, 4&gt;4 and 1&gt;5 each occur 356 times when counted (in a same pass).  To determine the complexity of each tuple, use the tuple symbols as the two sides of a right triangle and calculate the hypotenuse,
FIG. 6.  In the instance of 3&gt;7, the side of the hypotenuse is the square root of (three squared (9) plus seven squared (49)), or the square root of 58, or 7.6.  In the instance of 4&gt;4, the side of the hypotenuse is the square root of (four squared
(16) plus four squared (16), of the square root of 32, or 5.7.  Similar, 1&gt;5 calculates as a hypotenuse of 5.1 as seen in table 23 in the Figure.  Since the tuple with the largest hypotenuse is the most complex.  3&gt;7's hypotenuse of 7.6 is
considered more complex than either of the tuples 4&gt;4 or 1&gt;5.
<br/><br/> Skilled artisans can also use the tuple array to visualize the hypotenuse by drawing lines in the columns and rows from the array origin to the tuple entry in the array, as shown in table 24 in FIG. 7.  As seen, the longest hypotenuse is labeled
25, so the 3&gt;7 tuple wins the tie, and is designated as the most highly occurring tuple.  Hereafter, a new symbol is created to replace the highest occurring tuple (whether occurring the most outright by count or by tie resolution), as seen below. 
However, based on the complexity rule, it is highly likely that the next passes will replace tuple 4&gt;4 and then tuple 1&gt;5.
<br/><br/> Creating a Symbol for the Most Highly Occurring Tuple
<br/><br/> As before, a symbol stands for the two adjacent characters that form the tuple and skilled artisans select any new symbol they want provided it is not possibly found in the data stream elsewhere.  Also, since the symbol and its definition are
added to the alphabet, e.g., if ".alpha.=QU," a dictionary grows by one new symbol in each pass through the data, as will be seen.  A good example of a new symbol for use in the invention is a numerical character, sequentially selected, because numbers
provide an unlimited source of unique symbols.  In addition, reaching an optimized compression goal might take thousands (or even tens of thousands) of passes through the data stream and redundant symbols must be avoided relative to previous passes and
future passes.
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> Upon examining the data stream to find all occurrences of the highest occurring tuple, skilled artisans simply substitute the newly defined or newly created symbol for each occurrence of that tuple.  Intuitively, substituting a single symbol for
two characters compresses the data stream by one character for each occurrence of the tuple that is replaced.
<br/><br/> Encoding the Alphabet
<br/><br/> To accomplish this, counting occurs for how many times that each of the symbols in the current alphabet occurs in the data stream.  They then use the symbol count to apply an encoding scheme, such as a path-weighted Huffman coding scheme, to the
alphabet.  Huffman trees should be within the purview of the artisan's skill set.
<br/><br/> The encoding assigns bits to each symbol in the current alphabet that actually appears in the data stream.  That is, symbols with a count of zero occurrences are not encoded in the tree.  Also, symbols might go "extinct" in the data stream as
they are entirely consumed by yet more complex symbols, as will be seen.  As a result, the Huffman code tree is rebuilt every time a new symbol is added to the dictionary.  This means that the Huffman code for a given symbol can change with every pass. 
The encoded length of the data stream usually decreases with each pass.
<br/><br/> Calculating the Compressed File Size
<br/><br/> The compressed file size is the total amount of space that it takes to store the Huffman-encoded data stream plus the information about the compression, such as information about the file, the dictionary, and the Huffman encoding tree.  The
compression information must be saved along with other information so that the encoded data can be decompressed later.
<br/><br/> To accomplish this, artisans count the number of times that each symbol appears in the data stream.  They also count the number of bits in the symbol's Huffman code to find its bit length.  They then multiply the bit length by the symbol count
to calculate the total bits needed to store all occurrences of the symbol.  This is then repeated for each symbol.  Thereafter, the total bit counts for all symbols are added to determine how many bits are needed to store only the compressed data.  To
determine the compressed file size, add the total bit count for the data to the number of bits required for the related compression information (the dictionary and the symbol-encoding information).
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Substituting a tuple with a single symbol reduces the total number of characters in a data stream by one for each instance of a tuple that is replaced by a symbol.  That is, for each instance, two existing characters are replaced with one new
character.  In a given pass, each instance of the tuple is replaced by a new symbol.  There are three observed results: The length of the data stream (as measured by how many characters make up the text) decreases by half the number of tuples replaced. 
The number of symbols in the alphabet increases by one.  The number of nodes in the Huffman tree increases by two.
<br/><br/> By repeating the compression procedure a sufficient number of times, any series of characters can eventually be reduced to a single character.  That "super-symbol" character conveys the entire meaning of the original text.  However, the
information about the symbols and encoding that is used to reach that final symbol is needed to restore the original data later.  As the number of total characters in the text decreases with each repetition of the procedure, the number of symbols
increases by one.  With each new symbol, the size of the dictionary and the size of the Huffman tree increase, while the size of the data decreases relative to the number of instances of the tuple it replaces.  It is possible that the information about
the symbol takes more space to store than the original data it replaces.  In order for the compressed file size to become smaller than the original data stream size, the text size must decrease faster than the size increases for the dictionary and the
Huffman encoding information.
<br/><br/> The question at hand is then, what is the optimal number of substitutions (new symbols) to make, and how should those substitutions be determined?
<br/><br/> For each pass through the data stream, the encoded length of the text decreases, while the size of the dictionary and the Huffman tree increases.  It has been observed that the compressed file size will reach a minimal value, and then increase. 
The increase occurs at some point because so few tuple replacements are done that the decrease in text size no longer outweighs the increase in size of the dictionary and Huffman tree.
<br/><br/> The size of the compressed file does not decrease smoothly or steadily downward.  As the compression process proceeds, the size might plateau or temporarily increase.  In order to determine the true (global) minimum, it is necessary to continue
some number of iterations past the each new (local) minimum point.  This true minimal value represents the optimal compression for the data stream using this method.
<br/><br/> Through experimentation, three conditions have been found that can be used to decide when to terminate the compression procedure: asymptotic reduction, observed low, and single character.  Each method is described below.  Other terminating
conditions might be determined through further experimentation.
<br/><br/> Asymptotic Reduction
<br/><br/> An asymptotic reduction is a concession to processing efficiency, rather than a completion of the procedure.  When compressing larger files (100 kilobytes (KB) or greater), after several thousand passes, each additional pass produces only a very
small additional compression.  The compressed size is still trending downward, but at such a slow rate that additional compute time is not warranted.
<br/><br/> Based on experimental results, the process is terminated if at least 1000 passes have been done, and less than 1% of additional data stream compression has occurred in the last 1000 passes.  The previously noted minimum is therefore used as the
optimum compressed file.
<br/><br/> Observed Low
<br/><br/> A reasonable number of passes have been performed on the data and in the last reasonable number of passes a new minimum encoded file size has not been detected.  It appears that further passes only result in a larger encoded file size.
<br/><br/> Based on experimental results, the process is terminated if at least 1000 passes have been done, and in the last 10% of the passes, a new low has not been established.  The previously noted minimum is then used as the optimum compressed file.
<br/><br/> Single Character
<br/><br/> The data stream has been reduced to exactly one character.  This case occurs if the file is made up of data that can easily reduce to a single symbol, such a file filled with a repeating pattern.  In cases like this, compression methods other
than this one might result in smaller compressed file sizes.
<br/><br/> How the Procedure Optimizes Compression
<br/><br/> The representative embodiment of the invention uses Huffman trees to encode the data stream that has been progressively shortened by tuple replacement, and balanced against the growth of the resultant Huffman tree and dictionary representation.
<br/><br/> The average length of a Huffman encoded symbol depends upon two factors: How many symbols must be represented in the Huffman tree The distribution of the frequency of symbol use
<br/><br/> The average encoded symbol length grows in a somewhat stepwise fashion as more symbols are added to the dictionary.  Because the Huffman tree is a binary tree, increases naturally occur as the number of symbols passes each level of the power of
2 (2, 4, 8, 16, 32, 64, etc.).  At these points, the average number of bits needed to represent any given symbol normally increases by 1 bit, even though the number of characters that need to be encoded decreases.  Subsequent compression passes usually
overcome this temporary jump in encoded data stream length.
<br/><br/> The second factor that affects the efficiency of Huffman coding is the distribution of the frequency of symbol use.  If one symbol is used significantly more than any other, it can be assigned a shorter encoding representation, which results in
a shorter encoded length overall, and results in maximum compression.  The more frequently a symbol occurs, the shorter the encoded stream that replaces it.  The less frequently a symbol occurs, the longer the encoded stream that replaces it.
<br/><br/> If all symbols occur at approximately equal frequencies, the number of symbols has the greater effect than does the size of the encoded data stream.  Supporting evidence is that maximum compression occurs when minimum redundancy occurs, that is,
when the data appears random.  This state of randomness occurs when every symbol occurs at the same frequency as any other symbol, and there is no discernable ordering to the symbols.
<br/><br/> The method and procedure described in this document attempt to create a state of randomness in the data stream.  By replacing highly occurring tuples with new symbols, eventually the frequency of all symbols present in the data stream becomes
roughly equal.  Similarly, the frequency of all tuples is also approximately equal.  These two criteria (equal occurrence of every symbol and equal occurrence of ordered symbol groupings) is the definition of random data.  Random data means no
redundancy.  No redundancy means maximum compression.
<br/><br/> This method and procedure derives optimal compression from a combination of the two factors.  It reduces the number of characters in the data stream by creating new symbols to replace highly occurring tuples.  The frequency distribution of
symbol occurrence in the data stream tends to equalize as oft occurring symbols are eliminated during tuple replacement.  This has the effect of flattening the Huffman tree, minimizing average path lengths, and therefore, minimizing encoded data stream
length.  The number of newly created symbols is held to a minimum by measuring the increase in dictionary size against the decrease in encoded data stream size.
<br/><br/> Example of Compression
<br/><br/> To demonstrate the compression procedure, a small data file contains the following simple ASCII characters: aaaaaaaaaaaaaaaaaaaaaaaaaaabaaabaaaaaaaababbbbbb
<br/><br/> Each character is stored as a sequence of eight bits that correlates to the ASCII code assigned to the character.  The bit values for each character are: a=01100001 b=01100010
<br/><br/> The digital data that represents the file is the original data that we use for our compression procedure.  Later, we want to decompress the compressed file to get back to the original data without data loss.
<br/><br/> Preparing the Data Stream
<br/><br/> The digital data that represents the file is a series of bits, where each bit has a value of 0 or 1.  We want to abstract the view of the bits by conceptually replacing them with symbols to form a sequential stream of characters, referred to as
a data stream.
<br/><br/> For our sample digital data, we create two new symbols called 0 and 1 to represent the raw bit values of 0 and 1, respectively.  These two symbols form our initial alphabet, so we place them in the dictionary 26, FIG. 8.
<br/><br/> The data stream 30 in FIG. 9 represents the original series of bits in the stored file, e.g., the first eight bits 32 are "01100001" and correspond to the first letter "a" in the data file.  Similarly, the very last eight bits 34 are "01100010"
and correspond to the final letter "b" in the data file, and each of the 1's and 0's come from the ASCII code above.
<br/><br/> Also, the characters in data stream 30 are separated with a space for user readability, but the space is not considered, just the characters.  The space would not occur in computer memory either.
<br/><br/> Compressing the Data Stream
<br/><br/> The data stream 30 of FIG. 9 is now ready for compression.  The procedure will be repeated until the compression goal is achieved.  For this example, the compression goal is to minimize the amount of space that it takes to store the digital
data.
<br/><br/> Initial Pass
<br/><br/> For the initial pass, the original data stream and alphabet that were created in "Preparing the Data Stream" are obtained.
<br/><br/> Identifying all Possible Tuples
<br/><br/> An easy way to identify all possible combinations of the characters in our current alphabet (at this time having 0 and 1) is to create a tuple array (table 35, FIG. 10).  Those symbols are placed or fitted as a column and row, and the cells are
filled in with the tuple that combines those symbols.  The columns and rows are constructed alphabetically from left to right and top to bottom, respectively, according to the order that the symbols appear in our dictionary.  For this demonstration, we
will consider the symbol in a column to be the first character in the tuple, and the symbol in a row to be the last character in the tuple.  To simplify the presentation of tuples in each cell, we will use the earlier-described notation of
"first&gt;last" to indicate the order of appearance in the pair of characters, and to make it easier to visually distinguish the symbols in the pair.  The tuples shown in each cell now represent the patterns we want to look for in the data stream.
<br/><br/> For example, the table 35 shows the tuple array for characters 0 and 1.  In the cell for column 0 and row 0, the tuple is the ordered pair of 0 followed by 0.  The shorthand notation of the tuple in the first cell is "0&gt;0".  In the cell for
column 0 and row 1, the tuple is 0 followed by 1, or "0&gt;1".  In the cell for column 1 and row 0, the tuple is "1&gt;0".  In the cell for column 1 and row 1, the tuple is "1&gt;1".  (As skilled artisans will appreciate, most initial dictionaries and
original tuple arrays will be identical to these.  The reason is that computing data streams will all begin with a stream of 1's and 0's having two symbols only.)
<br/><br/> Determining the Highly Occurring Tuple
<br/><br/> After completion of the tuple array, we are ready to look for the tuples in the data stream 30, FIG. 9.  We start at the beginning of the data stream with the first two characters "01" labeled element 37.  We compare this pair of characters to
our known tuples, keeping in mind that order matters.  We match the pair to a tuple, and add one count for that instance.  We move forward by one character, and look at the pair of characters 38 in positions two and three in the data stream, or "11." We
compare and match this pair to one of the tuples, and add one count for that instance.  We continue tallying occurrences of the tuples in this manner until we reach the end of the data stream.  In this instance, the final tuple is "10" labeled 39.  By
incrementing through the data stream one character at a time, we have considered every combination of two adjacent characters in the data stream, and tallied each instance against one of the tuples.  We also consider the rule for sequences of repeated
symbols, described above, to determine the actual number of instances for the tuple that is defined by pairs of that symbol.
<br/><br/> For example, the first two characters in our sample data stream are 0 followed by 1.  This matches the tuple 0&gt;1, so we count that as one instance of the tuple.  We step forward one character.  The characters in positions two and three are 1
followed by 1, which matches the tuple 1&gt;1.  We count it as one instance of the 1&gt;1 tuple.  We consider the sequences of three or more zeros in the data stream (e.g., 01100001 .  . . ) to determine the actual number of tuples for the 0&gt;0 tuple. 
We repeat this process to the end of the data set with the count results in table 40, FIG. 11.
<br/><br/> Now that we have gathered statistics for how many times each tuple appears in the data stream 30, we compare the total counts for each tuple to determine which pattern is the most highly occurring.  The tuple that occurs most frequently is a tie
between a 1 followed by 0 (1&gt;0), which occurs 96 times, and a 0 followed by 1 (0&gt;1), which also occurs 96 times.  As discussed above, skilled artisans then choose the most complex tuple and do so according to Pythagorean's Theorem.  The sum of the
squares for each tuple is the same, which is 1 (1+0) and 1 (0+1).  Because they have the same complexity, it does not matter which one is chosen as the highest occurring.  In this example, we will choose tuple 1&gt;0.
<br/><br/> We also count the number of instances of each of the symbols in the current alphabet as seen in table 41, FIG. 12.  The total symbol count in the data stream is 384 total symbols that represent 384 bits in the original data.  Also, the symbol 0
appears 240 times in original data stream 30, FIG. 9, while the symbol 1 only appears 144 times.
<br/><br/> Pass 1
<br/><br/> In this next pass, we replace the most highly occurring tuple from the previous pass with a new symbol, and then we determine whether we have achieved our compression goal.
<br/><br/> Creating a Symbol for the Highly Occurring Tuple
<br/><br/> We replace the most highly occurring tuple from the previous pass with a new symbol and add it to the alphabet.  Continuing the example, we add a new symbol 2 to the dictionary and define it with the tuple defined as 1 followed by 0 (1&gt;0). 
It is added to the dictionary 26' as seen in FIG. 13.  (Of course, original symbol 0 is still defined as a 0, while original symbol 1 is still defined as a 1.  Neither of these represent a first symbol followed a last symbol which is why dashes appear in
the dictionary 26' under "Last" for each of them.)
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> In the original data stream 30, every instance of the tuple 1&gt;0 is now replaced with the new, single symbol.  In our example data stream 30, FIG. 9, the 96 instances of the tuple 1&gt;0 have been replaced with the new symbol "2" to create the
output data stream 30'.  FIG. 14, that we will use for this pass.  As skilled artisans will observe, replacing ninety-six double instances of symbols with a single, new symbol shrinks or compresses the data stream 30' in comparison to the original data
stream 30.  FIG. 8.
<br/><br/> Encoding the Alphabet
<br/><br/> After we compress the data stream by using the new symbol, we use a path-weighted Huffman coding scheme to assign bits to each symbol in the current alphabet.
<br/><br/> To do this, we again count the number of instances of each of the symbols in the current alphabet (now having "0," "1" and "2.") The total symbol count in the data stream is 288 symbols as seen in table 41', FIG. 15.  We also have one
end-of-file (EOF) symbol at the end of the data stream (not shown).
<br/><br/> Next, we use the counts to build a Huffman binary code tree.  1) List the symbols from highest count to lowest count.  2) Combine the counts for the two least frequently occurring symbols in the dictionary.  This creates a node that has the
value of the sum of the two counts.  3) Continue combining the two lowest counts in this manner until there is only one symbol remaining.  This generates a Huffman binary code tree.
<br/><br/> Finally, label the code tree paths with zeros (0s) and ones (1s).  The Huffman coding scheme assigns shorter code words to the more frequent symbols, which helps reduce the size length of the encoded data.  The Huffman code for a symbol is
defined as the string of values associated with each path transition from the root to the symbol terminal node.
<br/><br/> With reference to FIG. 16, the tree 50 demonstrates the process of building the Huffman tree and code for the symbols in the current alphabet.  We also create a code for the end of file marker that we placed at the end of the data stream when we
counted the tuples.  In more detail, the root contemplates 289 total symbols, i.e., the 288 symbols for the alphabet "0," "1" and "2" plus one EOF symbol.  At the leaves, the "0" is shown with its counts 144, the "1" with its count of 48, the "2" with
its count of 96 and the EOF with its count of 1.  Between the leaves and root, the branches define the count in a manner skilled artisans should readily understand.
<br/><br/> In this compression procedure, we will re-build a Huffman code tree every time we add a symbol to the current dictionary.  This means that the Huffman code for a given symbol can change with every compression pass.
<br/><br/> Calculating the Compressed File Size
<br/><br/> From the Huffman tree, we use its code to evaluate the amount of space needed to store the compressed data as seen in table 52, FIG. 17.  First, we count the number of bits in the Huffman code for each symbol to find its bit length 53.  Next, we
multiply a symbol's hit length by its count 54 to calculate the total bits 55 used to store the occurrences of that symbol.  We add the total bits 56 needed for all symbols to determine how many bits are needed to store only the compressed data.  As
seen, the current data stream 30', FIG. 14 requires 483 bits to store only the information.
<br/><br/> To know whether we achieved optimal compression, we must consider the total amount of space that it takes to store the compressed data plus the information about the compression that we need to store in order to decompress the data later.  We
also must store information about the file, the dictionary, and the Huffman tree.  The table 57 in FIG. 18 shows the total compression overhead as being 25 bits, which brings the compressed size of the data stream to 508 bits, or 483 bits plus 25 bits.
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Finally, we compare the original number of bits (384, FIG. 12) to the current number of bits (508) that are needed for this compression pass.  We find that it takes 1.32 times as many bits to store the compressed data as it took to store the
original data, table 58, FIG. 19.  This is not compression at all, but expansion.
<br/><br/> In early passes, however, we expect to see that the substitution requires more space than the original data because of the effect of carrying a dictionary, adding symbols, and building a tree.  On the other hand, skilled artisans should observe
an eventual reduction in the amount of space needed as the compression process continues.  Namely, as the size of the data set decreases by the symbol replacement method, the size grows for the symbol dictionary and the Huffman tree information that we
need for decompressing the data.
<br/><br/> Pass 2
<br/><br/> In this pass, we replace the most highly occurring tuple from the previous pass (pass 1) with still another new symbol, and then we determine whether we have achieved our compression goal.
<br/><br/> Identifying all Possible Topics
<br/><br/> As a result of the new symbol, the tuple array is expanded by adding the symbol that was created in the previous pass.  Continuing our example, we add 2 as a first symbol and last symbol, and enter the tuples in the new cells of table 35'.  FIG.
20.
<br/><br/> Determining the Highly Occurring Tuple
<br/><br/> As before, the tuple array identifies the tuples that we look for and tally in our revised alphabet.  As seen in table 40', FIG. 21, the Total Symbol Count=288.  The tuple that occurs most frequently when counting the data stream 30', FIG. 14,
is the character 2 followed by the character 0 (2&gt;0).  It occurs 56 times as seen circled in table 40', FIG. 21.
<br/><br/> Creating a Symbol for the Highly Occurring Tuple
<br/><br/> We define still another new symbol "3" to represent the most highly occurring tuple 2&gt;0, and add it to the dictionary 26'', FIG. 22, for the alphabet that was developed in the previous passes.
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> In the data stream 30'.  FIG. 14, we replace every instance of the most highly occurring tuple with the new single symbol.  We replace the 56 instances of the 2&gt;0 tuple with the symbol 3 and the resultant data stream 30''' is seen in FIG. 23.
<br/><br/> Encoding the Alphabet
<br/><br/> As demonstrated above, we count the number of symbols in the data stream, and use the count to build a Huffman tree and code for the current alphabet.  The total symbol count has been reduced from 288 to 234 (e.g., 88+48+40+58, but not including
the EOF marker) as seen in table 41'', FIG. 24.
<br/><br/> Calculating the Compressed File Size
<br/><br/> We need to evaluate whether our substitution reduces the amount of space that it takes to store the data.  As described above, we calculate the total bits needed (507) as in table 52', FIG. 25.
<br/><br/> In table 57', FIG. 26, the compression overhead is calculated as 38 bits.
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Finally, we compare the original number of bits (384) to the current number of bits (545=507+38) that are needed for this compression pass.  We find that it takes 141% or 1.41 times as many bits to store the compressed data as it took to store
the original data.  Compression is still not achieved and the amount of data in this technique is growing larger rather than smaller in comparison to the previous pass requiring 132%.
<br/><br/> Pass 3
<br/><br/> In this pass, we replace the most highly occurring tuple from the previous pass with a new symbol, and then we determine whether we have achieved our compression goal.
<br/><br/> Identifying all Possible Tipples
<br/><br/> We expand the tuple array 35'', FIG. 28 by adding the symbol that was created in the previous pass.  We add the symbol "3" as a first symbol and last symbol, and enter the tuples in the new cells.
<br/><br/> Determining the Highly Occurring Tuple
<br/><br/> The tuple array identifies the tuples that we look for and tally in our revised alphabet.  In table 40''.  FIG. 29, the Total Symbol Count is 232, and the tuple that occurs most frequently is the character 1 followed by character 3 (1&gt;3).  It
occurs 48 times, which ties with the tuple of character 3 followed by character 0.  We determine that the tuple 1&gt;3 is the most complex tuple because it has a hypotenuse length 25' of 3.16 (SQRT(1.sup.2+3.sup.2)), and tuple 3&gt;0 has a hypotenuse of
3 (SQRT(0.sup.2+3.sup.2)).
<br/><br/> Creating a Symbol for the Highly Occurring Tuple
<br/><br/> We define a new symbol 4 to represent the most highly occurring tuple 1&gt;3, and add it to the dictionary 26'''.  FIG. 30, for the alphabet that was developed in the previous passes.
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> In the data stream, we replace every instance of the most highly occurring tuple from the earlier data stream with the new single symbol.  We replace the 48 instances of the 1&gt;3 tuple with the symbol 4 and new data stream 30-4 is obtained,
FIG. 31.
<br/><br/> Encoding the Alphabet
<br/><br/> We count the number of symbols in the data stream, and use the count to build a Huffman tree and code for the current alphabet as seen in table 41''' FIG. 32.  There is no Huffman code assigned to the symbol 1 because there are no instances of
this symbol in the compressed data in this pass.  (This can be seen in the data stream 30-4, FIG. 31.) The total symbol count has been reduced from 232 to 184 (e.g., 88+0+40+8+48, but not including the EOF marker).
<br/><br/> Calculating the Compressed File Size
<br/><br/> We need to evaluate whether our substitution reduces the amount of space that it takes to store the data.  As seen in table 52''.  FIG. 33, the total bits are equal to 340.
<br/><br/> In table 57'', FIG. 34, the compression overhead in bits is 42.
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Finally, we compare the original number of bits (384) to the current number of bits (382) that are needed for this compression pass.  We find that it takes 0.99 times as many bits to store the compressed data as it took to store the original
data.  Compression is achieved.
<br/><br/> Pass 4
<br/><br/> In this pass, we replace the most highly occurring tuple from the previous pass with a new symbol, and then we determine whether we have achieved our compression goal.
<br/><br/> Identifying all Possible Tuples
<br/><br/> We expand the tuple array 35''', FIG. 36, by adding the symbol that was created in the previous pass.  We add the symbol 4 as a first symbol and last symbol, and enter the tuples in the new cells.
<br/><br/> Determining the Highly Occurring Tuple
<br/><br/> The tuple array identifies the tuples that we look for and tally in our revised alphabet.  In table 40'''.  FIG. 37, the Total Symbol Count=184 and the tuple that occurs most frequently is the character 4 followed by character 0 (4&gt;0).  It
occurs 48 times.
<br/><br/> Creating a Symbol Far the Highly Occurring Tuple
<br/><br/> We define a new symbol 5 to represent the 4&gt;0 tuple, and add it to the dictionary 26-4, FIG. 38, for the alphabet that was developed in the previous passes.
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> In the data stream, we replace every instance of the most highly occurring tuple with the new single symbol.  We replace the 48 instances of the 40 tuple in data stream 30-4, FIG. 31, with the symbol 5 as seen in data stream 30-5, FIG. 39.
<br/><br/> Encoding the Alphabet
<br/><br/> As demonstrated above, we count the number of symbols in the data stream, and use the count to build a Huffman tree and code for the current alphabet.  There is no Huffman code assigned to the symbol 1 and the symbol 4 because there are no
instances of these symbols in the compressed data in this pass.  The total symbol count has been reduced from 184 to 136 (e.g., 40+0+40+8+0+48, but not including the EOF marker) as seen in table 41-4, FIG. 40.
<br/><br/> Calculating the Compressed File Size
<br/><br/> We need to evaluate whether our substitution reduces the amount of space that it takes to store the data.  As seen in table 52''', FIG. 41, the total number of bits is 283.
<br/><br/> As seen in table 57''', FIG. 42, the compression overhead in bits is 48.
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Finally, we compare the original number of bits (384) to the current number of bits (331) that are needed for this compression pass as seen in table 58'''.  FIG. 43.  In turn, we find that it takes 0.86 times as many bits to store the compressed
data as it took to store the original data.
<br/><br/> Pass 5
<br/><br/> In this pass, we replace the most highly occurring tuple from the previous pass with a new symbol, and then we determine whether we have achieved our compression goal.
<br/><br/> Identifying all Possible Tuples
<br/><br/> We expand the tuple array by adding the symbol that was created in the previous pass.  We add the symbol 5 as a first symbol and last symbol, and enter the tuples in the new cells as seen in table 35-4, FIG. 44.
<br/><br/> Determining the Highly Occurring Tuple
<br/><br/> The tuple array identifies the tuples that we look for and tally in our revised alphabet as seen in table 40-4, FIG. 45.  (Total Symbol Count=136) The tuple that occurs most frequently is the symbol 2 followed by symbol 5 (2&gt;5), which has a
hypotenuse of 5.4.  It occurs 39 times.  This tuple ties with the tuple 0&gt;2 (hypotenuse is 2) and 5&gt;0 (hypotenuse is 5).  The tuple 2&gt;5 is the most complex based on the hypotenuse length 25'' described above.
<br/><br/> Creating a Symbol for the Highly Occurring Tuple
<br/><br/> We define a new symbol 6 to represent the most highly occurring tuple 2&gt;5, and add it to the dictionary for the alphabet that was developed in the previous passes as seen in table 26-5, FIG. 46.
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> In the data stream, we replace every instance of the most highly occurring tuple with the new single symbol.  We replace the 39 instances of the 2&gt;5 tuple in data stream 30-5, FIG. 39, with the symbol 6 as seen in data stream 30-6, FIG. 47.
<br/><br/> Encoding the Alphabet
<br/><br/> As demonstrated above, we count the number of symbols in the data stream, and use the count to build a Huffman tree and code for the current alphabet as seen in table 41-5, FIG. 48.  There is no Huffman code assigned to the symbol 1 and the
symbol 4 because there are no instances of these symbols in the compressed data in this pass.  The total symbol count has been reduced from 136 to 97 (e.g., 40+1+8+9+39, but not including the EOF marker) as seen in table 52-4, FIG. 49.
<br/><br/> Calculating the Compressed File Size
<br/><br/> We need to evaluate whether our substitution reduces the amount of space that it takes to store the data.  As seen in table 52-4, FIG. 49, the total number of bits is 187.
<br/><br/> As seen in table 57-4.  FIG. 50, the compression overhead in bits is 59.
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Finally, we compare the original number of bits (384) to the current number of bits (246, or 187+59) that are needed for this compression pass as seen in table 58-4, FIG. 51.  We find that it takes 0.64 times as many bits to store the compressed
data as it took to store the original data.
<br/><br/> Pass 6
<br/><br/> In this pass, we replace the most highly occurring tuple from the previous pass with a new symbol, and then we determine whether we have achieved our compression goal.
<br/><br/> Identifying all Possible Topics
<br/><br/> We expand the tuple array 35-5 by adding the symbol that was created in the previous pass as seen in FIG. 52.  We add the symbol 6 as a first symbol and last symbol, and enter the tuples in the new cells.
<br/><br/> Determining the Highly Occurring Topic
<br/><br/> The tuple array identifies the tuples that we look for and tally in our revised alphabet.  (Total Symbol Count=97) The tuple that occurs most frequently is the symbol 0 followed by symbol 6 (0&gt;6).  It occurs 39 times as seen in table 40-5,
FIG. 53.
<br/><br/> Creating a Symbol for the Highly Occurring Tuple
<br/><br/> We define a new symbol 7 to represent the 0&gt;6 tuple, and add it to the dictionary for the alphabet that was developed in the previous passes as seen in table 26-6, FIG. 54.
<br/><br/> Replacing the Tuple with the New Symbol
<br/><br/> In the data stream, we replace every instance of the most highly occurring tuple with the new single symbol.  We replace the 39 instances of the 0&gt;6 tuple in data stream 30-6, FIG. 47, with the symbol 7 as seen in data stream 30-7, FIG. 55.
<br/><br/> Encoding the Alphabet
<br/><br/> As demonstrated above, we count the number of symbols in the data stream, and use the count to build a Huffman tree and code for the current alphabet as seen in table 41-6, FIG. 56.  There is no Huffman code assigned to the symbol 1, symbol 4
and symbol 6 because there are no instances of these symbols in the compressed data in this pass.  The total symbol count has been reduced from 97 to 58 (e.g., 1+0+1+8+0+9+0+39, but not including the EOF marker).
<br/><br/> Because all the symbols 1, 4, and 6 have been removed from the data stream, there is no reason to express them in the encoding scheme of the Huffman tree 50', FIG. 57.  However, the extinct symbols will be needed in the decode table.  A complex
symbol may decode to two less complex symbols.  For example, a symbol 7 decodes to 0&gt;6.
<br/><br/> We need to evaluate whether our substitution reduces the amount of space that it takes to store the data.  As seen in table 52-5, FIG. 58, the total number of bits is 95.
<br/><br/> As seen in table 57-5, FIG. 59, the compression overhead in bits is 71.
<br/><br/> Determining Whether the Compression Goal has been Achieved
<br/><br/> Finally, we compare the original number of bits (384) to the current number of bits (166, or 95+71) that are needed for this compression pass as seen in table 58-5, FIG. 60.  We find that it takes 0.43 times as many bits to store the compressed
data as it took to store the original data.
<br/><br/> Subsequent Passes
<br/><br/> Skilled artisans will also notice that overhead has been growing in size while the total number of bits is still decreasing.  We repeat the procedure to determine if this is the optimum compressed file size.  We compare the compression size for
each subsequent pass to the first occurring lowest compressed file size.  The chart 60, FIG. 61, demonstrates how the compressed file size grows, decreases, and then begins to grow as the encoding, information and dictionary sizes grow.  We can continue
the compression of the foregoing techniques until the text file compresses to a single symbol after 27 passes.
<br/><br/> Interesting Symbol Statistics
<br/><br/> With reference to table 61, FIG. 62, interesting statistics about the symbols for this compression are observable.  For instance, the top 8 symbols represent 384 bits (e.g., 312+45+24+2+1) and 99.9% (e.g., 81.2+11.7+6.2+0.5+0.3%) of the file.
<br/><br/> Storing the Compressed File
<br/><br/> The information needed to decompress a file is usually written at the front of a compressed file, as well as to a separate dictionary only file.  The compressed file contains information about the file, a coded representation of the Huffman tree
that was used to compress the data, the dictionary of symbols that was created during the compression process, and the compressed data.  The goal is to store the information and data in as few bits as possible.
<br/><br/> This section describes a method and procedure for storing information in the compressed file.
<br/><br/> File Type
<br/><br/> The first four bits in the file are reserved for the version number of the file format, called the file type.  This field allows flexibility for future versions of the software that might be used to write the encoded data to the storage media. 
The file type indicates which version of the software was used when we saved the file in order to allow the file to be decompressed later.
<br/><br/> Four bits allows for up to 16 versions of the software.  That is, binary numbers from 0000 to 1111 represent version numbers from 0 to 15.  Currently, this field contains binary 0000.
<br/><br/> Maximum Symbol Width
<br/><br/> The second four bits in the file are reserved for the maximum symbol width.  This is the number of bits that it takes to store in binary form the largest symbol value.  The actual value stored is four less than the number of bits required to
store the largest symbol value in the compressed data.  When we read the value, we add four to the stored number to get the actual maximum symbol width.  This technique allows symbol values up to 20 bits.  In practical terms, the value 2^20 (2 raised to
the 20.sup.th power) means that about 1 million symbols can be used for encoding.
<br/><br/> For example, if symbols 0-2000 might appear in the compressed file, the largest symbol ID (2000) would fit in a field containing 11 bits.  Hence, a decimal 7 (binary 0111) would be stored in this field.
<br/><br/> In the compression example, the maximum symbol width is the end-of-file symbol 8, which takes four bits in binary (1000).  We subtract four, and store a value of 0000.  When we decompress the data, we add four to zero to find the maximum symbol
width of four bits.  The symbol width is used to read the Huffman tree that immediately follows in the coded data stream.
<br/><br/> Coded Huffman Tree
<br/><br/> We must store the path information for each symbol that appears in the Huffman tree and its value.  To do this, we convert the symbol's digital value to binary.  Each symbol will be stored in the same number of bits, as determined by the symbol
with the largest digital value and stored as the just read "symbol width".
<br/><br/> In the example, the largest symbol in the dictionary in the Huffman encoded tree is the end-of-file symbol 8.  The binary form of 8 is 1000, which takes 4 bits.  We will store each of the symbol values in 4 bits.
<br/><br/> To store a path, we will walk the Huffman tree in a method known as a pre-fix order recursive parse, where we visit each node of the tree in a known order.  For each node in the tree one bit is stored.  The value of the bit indicates if the node
has children (1) or if it is a leaf with no children (0).  If it is a leaf, we also store the symbol value.  We start at the root and follow the left branch down first.  We visit each node only once.  When we return to the root, we follow the right
branch down, and repeat the process for the right branch.
<br/><br/> In the following example, the Huffman encoded tree is redrawn as 50-2 to illustrate the prefix-order parse, where nodes with children are labeled as 1, and leaf nodes are labeled as 0 as seen in FIG. 63.
<br/><br/> The discovered paths and symbols are stored in the binary form in the order in which they are discovered in this method of parsing.  Write the following bit string to the file, where the bits displayed in bold/underline represent the path, and
the value of the 0 node are displayed without bold/underline.  The spaces are added for readability; they are not written to media.  1100101 1100000 101000 00010 00011 00111 Encode Array for the Dictionary
<br/><br/> The dictionary information is stored as sequential first/last definitions, starting with the two symbols that define the symbol 2.  We can observe the following characteristics of the dictionary: The symbols 0 and 1 are the atomic
(non-divisible) symbols common to every compressed file, so they do not need to be written to media.  Because we know the symbols in the dictionary are sequential beginning with 2, we store only the symbol definition and not the symbol itself.  A symbol
is defined by the tuple it replaces.  The left and right symbols in the tuple are naturally symbols that precede the symbol they define in the dictionary.  We can store the left/right symbols of the tuple in binary form.  We can predict the maximum
number of bits that it takes to store numbers in binary form.  The number of bits used to store binary numbers increases by one bit with each additional power of two as seen, for example, in table 62, FIG. 64:
<br/><br/> Because the symbol represents a tuple made up of lower-level symbols, we will increase the bit width at the next higher symbol value; that is, at 3, 5, 9, and 17, instead of at 2, 4, 8, and 16.
<br/><br/> We use this information to minimize the amount of space needed to store the dictionary.  We store the binary values for the tuple in the order of first and last, and use only the number of bits needed for the values.
<br/><br/> Three dictionary instances have special meanings.  The 0 and 1 symbols represent the atomic symbols of data binary 0 binary 1, respectively.  The last structure in the array represents the end-of-file (EOF) symbol, which does not have any
component pieces.  The EOF symbol is always assigned a value that is one number higher than the last symbol found in the data stream.
<br/><br/> Continuing our compression example, the table 63, FIG. 65, shows how the dictionary is stored.
<br/><br/> Write the following bit string to the file.  The spaces are added for readability; they are not written to media.  1010000111100000010101000110 Encoded Data
<br/><br/> To store the encoded data, we replace the symbol with its matching Huffman code and write the bits to the media.  At the end of the encoded bit string, we write the EOF symbol.  In our example, the final compressed symbol string is seen again as
30-7, FIG. 66, including the EOF.
<br/><br/> The Huffman code for the optimal compression is shown in table 67, FIG. 67.
<br/><br/> As we step through the data stream, we replace the symbol with the Huffman coded bits as seen at string 68, FIG. 68.  For example, we replace symbol 0 with the bits 0100 from table 67, replace symbol 5 with 00 from table 67, replace instances of
symbol 7 with 1, and so on.  We write the following string to the media, and write the end of file code at the end.  The bits are separated by spaces for readability; the spaces are not written to media.
<br/><br/> The compressed bit string for the data, without spaces is: 0100001111111111111111111111111110110011101100111111110110010110001100011- 0001100011000101101010 Overview of the Stored File
<br/><br/> As summarized in the diagram 69, FIG. 69, the information stored in the compressed file is the file type, symbol width, Huffman tree, dictionary, encoded data, and EOF symbol.  After the EOF symbol, a variable amount of pad bits are added to
align the data with the final byte in storage.
<br/><br/> In the example, the bits 70 of FIG. 70 are written to media.  Spaces are shown between the major fields for readability; the spaces are not written to media.  The "x" represents the pad bits.  In FIG. 69, the bits 70 are seen filled into diagram
69b corresponding to the compressed file format.
<br/><br/> Decompressing the Compressed File
<br/><br/> The process of decompression unpacks the data from the beginning of the file 69, FIG. 69, to the end of the stream.
<br/><br/> File Type
<br/><br/> Read the first four bits of the file to determine the file format version.
<br/><br/> Maximum Symbol Width
<br/><br/> Read the next four bits in the file, and then add four to the value to determine the maximum symbol width.  This value is needed to read the Huffman tree information.
<br/><br/> Huffman Tree
<br/><br/> Reconstruct the Huffman tree.  Each 1 bit represents a node with two children.  Each 0 bit represents a leaf node, and it is immediately followed by the symbol value.  Read the number of bits for the symbol using the maximum symbol width.
<br/><br/> In the example, the stored string for Huffman is: 11001011100000101000000100001100111
<br/><br/> With reference to FIG. 71, diagram 71 illustrates how to unpack and construct the Huffman tree using the pre-fix order method.
<br/><br/> Dictionary
<br/><br/> To reconstruct the dictionary from file 69, read the values for the pairs of tuples and populate the table.  The values of 0 and 1 are known, so they are automatically included.  The bits are read in groups based on the number of bits per symbol
at that level as seen in table 72, FIG. 72.
<br/><br/> In our example, the following bits were stored in the file: 1010000111101000010101000110
<br/><br/> We read the numbers in pairs, according to the bits per symbol, where the pairs represent the numbers that define symbols in the dictionary:
<br/><br/> TABLE-US-00001 Bits Symbol 1 0 2 10 00 3 01 11 4 100 000 5 010 101 6 000 110 7
<br/><br/> We convert each binary number to a decimal number:
<br/><br/> TABLE-US-00002 Decimal Value Symbol 1 0 2 2 0 3 1 3 4 4 0 5 2 5 6 0 6 7
<br/><br/> We identify the decimal values as the tuple definitions for the symbols:
<br/><br/> TABLE-US-00003 Symbol Tuple 2 1 &gt; 0 3 2 &gt; 0 4 1 &gt; 3 5 4 &gt; 0 6 2 &gt; 5 7 0 &gt; 6
<br/><br/> We populate the dictionary with these definitions as seen in table 73, FIG. 73.
<br/><br/> Construct the Decode Tree
<br/><br/> We use the tuples that are defined in the re-constructed dictionary to build the Huffman decode tree.  Let's decode the example dictionary to demonstrate the process.  The diagram 74 in FIG. 74 shows how we build the decode tree to determine the
original bits represented by each of the symbols in the dictionary.  The step-by-step reconstruction of the original bits is as follows:
<br/><br/> Start with symbols 0 and 1.  These are the atomic elements, so there is no related tuple.  The symbol 0 is a left branch from the root.  The symbol 1 is a right branch.  (Left and right are relative to the node as you are facing the
diagram--that is, on your left and on your right.) The atomic elements are each represented by a single bit, so the binary path and the original path are the same.  Record the original bits 0 and 1 in the decode table.
<br/><br/> Symbol 2 is defined as the tuple 1&gt;0 (symbol 1 followed by symbol 0).  In the decode tree, go to the node for symbol 1, then add a path that represents symbol 0.  That is, add a left branch at node 1.  The terminating node is the symbol 2. 
Traverse the path from the root to the leaf to read the branch paths of left (L) and right (R).  Replace each left branch with a 0 and each right path with a 1 to view the binary forum of the path as LR, or binary 10.
<br/><br/> Symbol 3 is defined as the tuple 2&gt;0.  In the decode tree, go to the node for symbol 2, then add a path that represents symbol 0.  That is, add a left branch at node 2.  The terminating node is the symbol 3.  Traverse the path from the root
to the leaf to read the branch path of RLL.  Replace each left branch with a 0 and each right path with a 1 to view the binary form of the path as 100.
<br/><br/> Symbol 4 is defined as the tuple 1&gt;3.  In the decode tree, go to the node for symbol 1, then add a path that represents symbol 3.  From the root to the node for symbol 3, the path is RLL.  At symbol 1, add the RLL path.  The terminating node
is symbol 4.  Traverse the path from the root to the leaf to read the path of RRLL, which translates to the binary format of 1100.
<br/><br/> Symbol 5 is defined as the tuple 4&gt;0.  In the decode tree, go to the node for symbol 4, then add a path that represents symbol 0.  At symbol 4, add the L path.  The terminating node is symbol 5.  Traverse the path from the root to the leaf to
read the path of RRLLL, which translates to the binary format of 11000.
<br/><br/> Symbol 6 is defined as the tuple 2&gt;5.  In the decode tree, go to the node for symbol 2, then add a path that represents symbol 5.  From the root to the node for symbol 5, the path is RRLLL.  The terminating node is symbol 6.  Traverse the
path from the root to the leaf to read the path of RLRRLLL, which translates to the binary format of 1011000.
<br/><br/> Symbol 7 is defined as the tuple 0&gt;6.  In the decode tree, go to the node for symbol 0, then add a path that represents symbol 6.  From the root to the node for symbol 6, the path is RLRRLLL.  The terminating node is symbol 7.  Traverse the
path from the root to the leaf to read the path of LRLRRLLL, which translates to the binary format of 01011000.
<br/><br/> Decompress the Data
<br/><br/> To decompress the data, we need the reconstructed Huffman tree and the decode table that maps the symbols to their original bits as seen at 75, FIG. 75.  We read the bits in the data file one bit at a time, following the branching path in the
Huffman tree from the root to a node that represents a symbol.
<br/><br/> The compressed file data bits are: 0100001111111111111111111111111110110011101100111111110110010110001100011- 0001100011000101101010
<br/><br/> For example, the first four bits of encoded data 0100 takes us to symbol 0 in the Huffman tree, as illustrated in the diagram 76, FIG. 76.  We look up 0 in the decode tree and table to find the original bits.  In this case, the original bits are
also 0.  We replace 0100 with the single bit 0.
<br/><br/> In the diagram 77 in FIG. 77, we follow the next two bits 00 to find symbol 5 in the Huffman tree.  We look up 5 in the decode tree and table to find that symbol 5 represents original bits of 11000.  We replace 00 with 11000.
<br/><br/> In the diagram 78, FIG. 78, we follow the next bit 1 to find symbol 7 in the Huffman tree.  We look up 7 in the decode tree and table to find that symbol 7 represents the original bits 01011000.  We replace the single bit 1 with 01011000.  We
repeat this for each 1 in the series of 1 s that follow.
<br/><br/> The next symbol we discover is with bits 011.  We follow these bits in the Huffman tree in diagram 79, FIG. 79.  We look up symbol 3 in the decode tree and table to find that it represents original bits 100, so we replace 011 with bits 100.
<br/><br/> We continue the decoding and replacement process to discover the symbol 2 near the end of the stream with bits 01011, as illustrated in diagram 80, FIG. 80.  We look up symbol 2 in the decode tree and table to find that it represents original
bits 10, so we replace 01011 with bits 10.
<br/><br/> The final unique sequence of bits that we discover is the end-of-file sequence of 01010, as illustrated in diagram 81, FIG. 81.  The EOF tells us that we are done unpacking.
<br/><br/> Altogether, the unpacking of compressed bits recovers the original bits of the original data stream in the order of diagram 82 spread across two FIGS. 82a and 82b.
<br/><br/> With reference to FIG. 83, a representative computing system environment 100 includes a computing device 120.  Representatively, the device is a general or special purpose computer, a phone, a PDA, a server, a laptop, etc., having a hardware
platform 128.  The hardware platform includes physical I/O and platform devices, memory (M), processor (P), such as a CPU(s), USB or other interfaces (X), drivers (D), etc. In turn, the hardware platform hosts one or more virtual machines in the form of
domains 130-1 (domain 0, or management domain), 130-2 (domain U1), .  . . 130-n (domain Un), each having its own guest operating system (O.S.) (e.g., Linux, Windows, Netware, Unix, etc.), applications 140-1, 140-2, .  . . 140-n, file systems, etc. The
workloads of each virtual machine also consume data stored on one or more disks 121.
<br/><br/> An intervening Xen or other hypervisor layer 150, also known as a "virtual machine monitor," or virtualization manager, serves as a virtual interface to the hardware and virtualizes the hardware.  It is also the lowest and most privileged layer
and performs scheduling control between the virtual machines as they task the resources of the hardware platform, e.g., memory, processor, storage, network (N) (by way of network interface cards, for example), etc. The hypervisor also manages conflicts,
among other things, caused by operating system access to privileged machine instructions.  The hypervisor can also be type 1 (native) or type 2 (hosted).  According to various partitions, the operating systems, applications, application data, boot data,
or other data, executable instructions, etc., of the machines are virtually stored on the resources of the hardware platform.  Alternatively, the computing system environment is not a virtual environment at all, but a more traditional environment lacking
a hypervisor, and partitioned virtual domains.  Also, the environment could include dedicated services or those hosted on other devices.
<br/><br/> In any embodiment, the representative computing device 120 is arranged to communicate 180 with one or more other computing devices or networks.  In this regard, the devices may use wired, wireless or combined connections to other
devices/networks and may be direct or indirect connections.  If direct, they typify connections within physical or network proximity (e.g., intranet).  If indirect, they typify connections such as those found with the internet, satellites, radio
transmissions, or the like.  The connections may also be local area networks (LAN), wide area networks (WAN), metro area networks (MAN), etc., that are presented by way of example and not limitation.  The topology is also any of a variety, such as ring,
star, bridged, cascaded, meshed, or other known or hereinafter invented arrangement.
<br/><br/> In still other embodiments, skilled artisans will appreciate that enterprises can implement some or all of the foregoing with humans, such as system administrators, computing devices, executable code, or combinations thereof.  In turn, methods
and apparatus of the invention further contemplate computer executable instructions, e.g., code or software, as part of computer program products on readable media, e.g., disks for insertion in a drive of a computing device 120, or available as downloads
or direct use from an upstream computing device.  When described in the context of such computer program products, it is denoted that items thereof, such as modules, routines, programs, objects, components, data structures, etc., perform particular tasks
or implement particular abstract data types within various structures of the computing system which cause a certain function or group of function, and such are well known in the art.
<br/><br/> While the foregoing produces a well-compressed output file, e.g., FIG. 69, skilled artisans should appreciate that the algorithm requires relatively considerable processing time to determine a Huffman tree, e.g., element 50, and a dictionary,
e.g., element 26, of optimal symbols for use in encoding and compressing an original file.  Also, the time spent to determine the key information of the file is significantly longer than the time spent to encode and compress the file with the key.  The
following embodiment, therefore, describes a technique to use a file's compression byproducts to compress other data files that contain substantially similar patterns.  The effectiveness of the resultant compression depends on how similar a related
file's patterns are to the original file's patterns.  As will be seen, using previously created, but related key, decreases the processing time to a small fraction of the time needed for the full process above, but at the expense of a slightly less
effective compression.  The process can be said to achieve a "fast approximation" to optimal compression for the related files.
<br/><br/> The definitions from FIG. 1 still apply.
<br/><br/> Broadly, the "fast approximation" hereafter 1) greatly reduces the processing time needed to compress a file using the techniques above, and 2) creates and uses a decode tree to identify the most complex possible pattern from an input bit stream
that matches previously defined patterns.  Similar to earlier embodiments, this encoding method requires repetitive computation that can be automated by computer software.  The following discusses the logical processes involved.
<br/><br/> Compression Procedure Using a Fast Approximation to Optimal Compression
<br/><br/> Instead of using the iterative process of discovery of the optimal set of symbols, above, the following uses the symbols that were previously created for another file that contains patterns significantly similar to those of the file under
consideration.  In a high-level flow, the process involves the following tasks: 1.  Select a file that was previously compressed using the procedure(s) in FIGS. 2-82b.  The file should contain data patterns that are significantly similar to the current
file under consideration for compression.  2.  From the previously compressed file, read its key information and unpack its Huffman tree and symbol dictionary by using the procedure described above, e.g., FIGS. 63-82b.  3.  Create a decode tree for the
current file by using the symbol dictionary from the original file.  4.  Identify and count the number of occurrences of patterns in the current file that match the previously defined patterns.  5.  Create a Huffman encoding tree for the symbols that
occur in the current file plus an end-of-file (EOF) symbol.  6.  Store the information using the Huffman tree for the current file plus the file type, symbol width, and dictionary from the original file.  Each of the tasks is described in more detail
below.  An example is provided thereafter.  Selecting a Previously Compressed File
<br/><br/> The objective of the fast approximation method is to take advantage of the key information in an optimally compressed file that was created by using the techniques above.  In its uncompressed form of original data, the compressed file should
contain data patterns that are significantly similar to the patterns in the current file under consideration for compression.  The effectiveness of the resultant compression depends on how similar a related file's patterns are to the original file's
patterns.  The way a skilled artisan recognizes a similar file is that similar bit patterns are found in the originally compressed and new file yet to be compressed.  It can be theorized a priori that files are likely similar if they have similar
formatting (e.g., text, audio, image, powerpoint, spreadsheet, etc), topic content, tools used to create the files, file type, etc. Conclusive evidence of similar bit patterns is that similar compression ratios will occur on both files (i.e. original
file compresses to 35% of original size, while target file also compresses to about 35% of original size).  It should be noted that similar file sizes are not a requisite for similar patterns being present in both files.
<br/><br/> With reference to FIG. 84, the key information 200 of a file includes the file type, symbol width, Huffman tree, and dictionary from an earlier file, e.g., file 69, FIG. 69.
<br/><br/> Reading and Unpacking the Key Information
<br/><br/> From the key information 200, read and unpack the File Type, Maximum Symbol Width, Huffman Tree, and Dictionary fields.
<br/><br/> Creating a Decode Tree for the Current File
<br/><br/> Create a pattern decode tree using the symbol dictionary retrieved from the key information.  Each symbol represents a bit pattern from the original data stream.  We determine what those bits are by building a decode tree, and then parsing the
tree to read the bit patterns for each symbol.
<br/><br/> We use the tuples that are defined in the re-constructed dictionary to build the decode tree.  The pattern decode tree is formed as a tree that begins at the root and branches downward.  A terminal node represents a symbol ID value.  A
transition node is a placeholder for a bit that leads to terminal nodes.
<br/><br/> Identifying and Counting Pattern Occurrences
<br/><br/> Read the bit stream of the current file one bit at a time.  As the data stream is parsed from left to right, the paths in the decode tree are traversed to detect patterns in the data that match symbols in the original dictionary.
<br/><br/> Starting from the root of the pattern decode tree, use the value of each input bit to determine the descent path thru the pattern decode tree.  A "0" indicates a path down and to the left, while a "1" indicates a path down and to the right. 
Continue descending through the decode tree until there is no more descent path available.  This can occur because a branch left is indicated with no left branch available, or a branch right is indicated with no right branch available.
<br/><br/> When the end of the descent path is reached, one of the following occurs: If the descent path ends in a terminal node, count the symbol ID found there, If the descent path ends in a transition node, retrace the descent path toward the root,
until a terminal node is encountered.  This terminal node represents the most complex pattern that could be identified in the input bit stream.  For each level of the tree ascended, replace the bit that the path represents back into the bit stream
because those bits form the beginning of the next pattern to be discovered.  Count the symbol ID found in the terminal node.
<br/><br/> Return to the root of the decode tree and continue with the next bit in the data stream to find the next symbol.
<br/><br/> Repeat this process until all of the bits in the stream have been matched to patterns in the decode tree.  When done, there exists a list of all of the symbols that occur in the bit stream and the frequency of occurrence for each symbol.
<br/><br/> Creating a Huffman Tree and Code for the Current File
<br/><br/> Use the frequency information to create a Huffman encoding tree for the symbols that occur in the current file.  Include the end-of-file (EOF) symbol when constructing the tree and determining the code.
<br/><br/> Storing the Compressed File
<br/><br/> Use the Huffman tree for the current file to encode its data.  The information needed to decompress the file is written at the front of the compressed file, as well as to a separate dictionary only file.  The compressed file contains: The file
type and maximum symbol width information from the original file's key A coded representation of the Huffman tree that was created for the current file and used to compress its data, The dictionary of symbols from the original file's key, The
Huffman-encoded data, and The Huffman-encoded EOF symbol.  Example of "Fast Approximation"
<br/><br/> This example uses the key information 200 from a previously created but related compressed file to approximate the symbols needed to compress a different file.
<br/><br/> Reading and Unpacking the Key Information
<br/><br/> With reference to table 202, FIG. 85, a representative dictionary of symbols (0-8) was unpacked from the key information 200 for a previously compressed file.  The symbols 0 and 1 are atomic, according to definition (FIG. 1) in that they
represent bits 0 and 1, respectively.  The reading and unpacking this dictionary from the key information is given above.
<br/><br/> Construct the Decode Tree from the Dictionary
<br/><br/> With reference to FIG. 86, a diagram 204 demonstrates the process of building the decode tree for each of the symbols in the dictionary (FIG. 85) and determining the original bits represented by each of the symbols in the dictionary.  In the
decode tree, there are also terminal nodes, e.g., 205, and transition nodes, e.g., 206.  A terminal node represents a symbol value.  A transition node does not represent a symbol, but represents additional bits in the path to the next symbol.  The
step-by-step reconstruction of the original bits is described below.
<br/><br/> Start with symbols 0 and 1.  These are the atomic elements, by definition, so there is no related tuple as in the dictionary of FIG. 85.  The symbol 0 branches left and down from the root.  The symbol 1 branches right and down from the root. 
(Left and right are relative to the node as you are facing the diagram--that is, on your left and on your right.) The atomic elements are each represented by a single bit, so the binary path and the original path are the same.  You record the "original
bits" 0 and 1 in the decode table 210, as well as its "branch path."
<br/><br/> Symbol 2 is defined from the dictionary as the tuple 1&gt;0 (symbol 1 followed by symbol 0).  In the decode tree 212, go to the node for symbol 1 (which is transition node 205 followed by a right path R and ending in a terminal node 206, or
arrow 214), then add a path that represents symbol 0 (which is transition node 205 followed by a left path L and ending in a terminal node 206, or path 216).  That is, you add a left branch at node 1.  The terminating node 220 is the symbol 2.  Traverse
the path from the root to the leaf to read the branch paths of right (R) and left (L).  Replace each left branch with a 0 and each right path with a 1 to view the binary form of the path as RL, or binary 10 as in decode table 210.
<br/><br/> Symbol 3 is defined as the tuple 2&gt;0.  In its decode tree 230, it is the same as the decode tree for symbol 2, which is decode tree 212, followed by the "0." Particularly, in tree 230, go to the node for symbol 2, then add a path that
represents symbol 0.  That is, you add a left branch (e.g., arrow 216) at node 2.  The terminating node is the symbol 3.  Traverse the path from the root to the leaf to read the branch path of RLL.  Replace each left branch with a 0 and each right path
with a 1 to view the binary format of 100 as in the decode table.
<br/><br/> Similarly, the other symbols are defined with decode trees building on the decode trees for other symbols.  In particular, they are as follows:
<br/><br/> Symbol 4 from the dictionary is defined as the tuple 1&gt;3.  In its decode tree, go to the node for symbol 1, then add a path that represents symbol 3.  From the root to the node for symbol 3, the path is RLL.  At symbol 1, add the RLL path. 
The terminating node is symbol 4.  Traverse the path from the root to the leaf to read the path of RRLL, which translates to the binary format of 1100 as in the decode table.
<br/><br/> Symbol 5 is defined as the tuple 4&gt;0.  In its decode tree, go to the node for symbol 4, then add a path that represents symbol 0.  At symbol 4, add the L path.  The terminating node is symbol 5.  Traverse the path from the root to the leaf to
read the path of RRLLL, which translates to the binary format of 11000.
<br/><br/> Symbol 6 is defined as the tuple 5&gt;3.  In its decode tree, go to the node for symbol 5, then add a path that represents symbol 3.  The terminating node is symbol 6.  Traverse the path from the root to the leaf to read the path of RRLLLRLL,
which translates to the binary format of 11000100.
<br/><br/> Symbol 7 is defined from the dictionary as the tuple 5&gt;0.  In its decode tree, go to the node for symbol 5, then add a path that represents symbol 0.  From the root to the node for symbol 5, the path is RRLLL.  Add a left branch.  The
terminating node is symbol 7.  Traverse the path from the root to the leaf to read the path of RRLLLL, which translates to the binary format of 110000.
<br/><br/> Finally, symbol 8 is defined in the dictionary as the tuple 7&gt;2.  In its decode tree, go to the node for symbol 7, then add a path that represents symbol 2.  From the root to the node for symbol 7, the path is RRLLLL.  Add a RL path for
symbol 2.  The terminating node is symbol 8.  Traverse the path from the root to the leaf to read the path of RRLLLLRL, which translates to the binary format of 11000010.
<br/><br/> The final decode tree for all symbols put together in a single tree is element 240, FIG. 87, and the decode table 210 is populated with all original bit and branch path information.
<br/><br/> Identifying and Counting Pattern Occurrences
<br/><br/> For this example, the sample or "current file" to be compressed is similar to the one earlier compressed who's key information 200, FIG. 84, was earlier extracted.  It contains the following representative "bit stream" (reproduced in FIG. 88,
with spaces for readability): 0110000101100010011000010110001001100001011000010110001001100001011000100- 11000010110000101100010011000010110001001100001011000100110000101100010011-
00010011000100110001001100010011000010110000101100010011000010110001001100 00101100010
<br/><br/> We step through the stream one bit at a time to match patterns in the stream to the known symbols from the dictionary 200, FIG. 85.  To determine the next pattern in the bit stream, we look for the longest sequence of bits that match a known
symbol.  To discover symbols in the new data bit stream, read a single bit at a time from the input bit stream.  Representatively, the very first bit, 250 FIG. 88, of the bit stream is a "0." With reference to the Decode Tree, 240 in FIG. 87, start at
the top-most (the root) node of the tree.  The "0" input bit indicates a down and left "Branch Path" from the root node.  The next bit from the source bit stream at position 251 in FIG. 88, is a "1," indicating a down and right path.  The Decode Tree
does not have a defined path down and right from the current node.  However the current node is a terminal node, with a symbol ID of 0.  Write a symbol 0 to a temporary file, and increment the counter corresponding to symbol ID 0.  Return to the root
node of the Decode Tree, and begin looking for the next symbol.  The "1" bit that was not previously usable in the decode (e.g., 251 in FIG. 88) indicates a down and right.  The next bit "1" (252 in FIG. 88) indicates a down and right.  Similarly,
subsequent bits "000010" indicate further descents in the decode tree with paths directions of LLLLRL, resulting in path 254 from the root.  The next bit "1" (position 255, FIG. 88) denotes a further down and right path, which does not exist in the
decode tree 240, as we are presently at a terminal node.  The symbol ID for this terminal node is 8.  Write a symbol 8 to the temporary file, and increment the counter corresponding to symbol ID 8.
<br/><br/> Return to the root node of the Decode Tree, and begin looking for the next symbol again starting with the last unused input stream bit, e.g., the bit "1" at position 255, FIG. 88.  Subsequent bits in the source bit stream, "11000100," lead down
through the Decode Tree to a terminal node for symbol 6.  The next bit.  "1", at position 261, FIG. 88, does not represent a possible down and right traversal path.  Thus, write a symbol 6 to the temporary file, and increment the counter corresponding to
symbol ID 6.  Again, starting back at the root of the tree, perform similar decodes and book keeping to denote discovery of symbols 86886868868686866666886868.  Starting again at the root of the Decode Tree, parse the paths represented by input bits
"1100010" beginning at position 262.  There are no more bits available in the input stream.  However, the current position in the Decode Tree, position 268, does not identify a known symbol.  Thus, retrace the Decode Tree path upward toward the root.  On
each upward level node transition, replace a bit at the front of the input bit stream with a bit that represents that path transition; e.g. up and right is a "0", up and left is a "1".  Continue the upward parse until reaching a valid symbol ID node, in
this case the node 267 for symbol ID 5.  In the process, two bits (e.g., positions 263 and 264, FIG. 88) will have been pushed back onto the input stream, a "0", and then a "1." As before, write a symbol 5 to a temporary file, and increment the counter
corresponding to symbol ID 5.  Starting back at the root of the tree, bits are pulled from the input stream and parsed downward, in this case the "1" and then the "0" at positions 263 and 264.  As we are now out of input bits, after position 264, examine
the current node for a valid symbol ID, which in this case does exist at node 269, a symbol ID of 2.  Write a symbol 2 to the temporary files, increment the corresponding counter.  All input bits have now been decoded to previously defined symbols.  The
entire contents of the temporary file are symbols: "0868688686886868686666688686852."
<br/><br/> From here, the frequency of occurrence of each of the symbols in the new bit stream is counted.  For example, the symbols "0" and 2" are each found occurring once at the beginning and end of the new bit stream.  Similarly, the symbol "5" is
counted once just before the symbol "2." Each of the symbols "6" and "8" are counted fourteen times in the middle of the new bit stream for a total of thirty-one symbols.  Its result is shown in table 275, FIG. 89.  Also, one count for the end of file
(EOF) symbol is added that is needed to mark the end of the encoded data when we store the compressed data.
<br/><br/> Creating a Huffman Tree and Code for the Current File
<br/><br/> From the symbol "counts" in FIG. 89, a Huffman binary code tree 280 is built for the current file, as seen in FIG. 90.  There is no Huffman code assigned to the symbol 1, symbol 3, symbol 4, and symbol 7 because there are no instances of these
symbols in the new bit stream.  However, the extinct symbols will be needed in the decode table for the tree.  The reason for this is that a complex symbol may decode to two less complex symbols.  For example, it is known that a symbol 8 decodes to tuple
7&gt;2, e.g., FIG. 85.
<br/><br/> To construct the tree 280, list first the symbols from highest count to lowest count.  In this example, the symbol "8" and symbol "6" tied with a count of fourteen and are each listed highest on the tree.  On the other hand, the least counted
symbols were each of symbol "0," "2," "5." and the EOF.  Combine the counts for the two least frequently occurring symbols in the dictionary.  This creates a node that has the value of the sum of the two counts.  In this example, the EOF and 0 are
combined into a single node 281 as are the symbols 2 and 5 at node 283.  Together, all four of these symbols combine into a node 285.  Continue combining the two lowest counts in this manner until there is only one symbol remaining.  This generates a
Huffman binary code tree.
<br/><br/> Label the code tree paths with zeros (0s) and ones (1s).  To encode a symbol, parse from the root to the symbol.  Each left and down path represents a 0 in the Huffman code.  Each right and down path represents a 1 in the Huffman code.  The
Huffman coding scheme assigns shorter code words to the more frequent symbols, which helps reduce the size length of the encoded data.  The Huffman code for a symbol is defined as the string of values associated with each path transition from the root to
the symbol terminal node.
<br/><br/> With reference to FIG. 91, table 290 shows the final Huffman code for the current file, as based on the tree.  For example, the symbol "8" appears with the Huffman code 0.  From the tree, and knowing the rule that "0" is a left and down path. 
the "8" should appear from the root at down and left, as it does.  Similarly, the symbol "5" should appear at "1011" or right and down, left and down, right and down, and right and down, as it does.  Similarly, the other symbols are found.  There is no
code for symbols 1, 3, 4, and 7, however, because they do not appear in the current file.
<br/><br/> Storing the Compressed File
<br/><br/> The diagram in FIG. 92 illustrates how we now replace the symbols with their Huffman code value when the file is stored, such as in file format element 69, FIG. 69.  As is seen, the diagram 295 shows the original bit stream that is coded to
symbols or a new bit stream, then coded to Huffman codes.  For example, the "0" bit at position 250 in the original bit stream coded to a symbol "0" as described in FIG. 88.  By replacing the symbol 0 with its Huffman code (1001) from table 290, FIG. 91,
the Huffman encoded bits are seen, as: 1001011011001101100110110110111111111100110110101110101000
<br/><br/> Spaces are shown between the coded bits for readability; the spaces are not written to media.  Also, the code for the EOF symbol (1000) is placed at the end of the encoded data and shown in underline.
<br/><br/> With reference to FIG. 93, the foregoing information is stored in the compressed file 69' for the current file.  As skilled artisans will notice, it includes both original or re-used information and new information, thereby resulting in a "fast
approximation." In detail, it includes the file type from the original key information (200), the symbol width from the original key information (200), the new Huffman coding recently created for the new file, the dictionary from the key information
(200) of the original file, the data that is encoded by using the new Huffman tree, and the new EOF symbol.  After the EOF symbol, a variable amount of pad bits are added to align the data with the final byte in storage.
<br/><br/> In still another alternate embodiment, the following describes technology to identify a file by its contents.  It is defined, in one sense, as providing a file's "digital spectrum." The spectrum, in turn, is used to define a file's position in
an N-dimensional universe.  This universe provides a basis by which a file's position determines similarity, adjacency, differentiation and grouping relative to other files.  Ultimately, similar files can originate many new compression features, such as
the "fast approximations" described above.  The terminology defined in FIG. 1 remains valid as does the earlier-presented information for compression and/or fast approximations using similar files.  It is supplemented with the definitions in FIG. 94. 
Also, the following considers an alternate use of the earlier described symbols to define a digital variance in a file.  For simplicity in this embodiment, a data stream under consideration is sometimes referred to as a "file."
<br/><br/> The set of values that digitally identifies the file, referred to as the file's digital spectrum, consists of several pieces of information found in two scalar values and two vectors.
<br/><br/> The scalar values are:
<br/><br/> The number of symbols in the symbol dictionary (the dictionary being previously determined above.) The number of symbols also represents the number of dimensions in the N-dimensional universe, and thus, the number of coordinates in the vectors. 
The length of the source file in bits.  This is the total number of bits in the symbolized data stream after replacing each symbol with the original bits that the symbol represents.  The vectors are: An ordered vector of frequency counts, where each
count represents the number of times a particular symbol is detected in the symbolized data stream.  F.sub.x=(F.sub.0x, F.sub.1x, F.sub.2x, F.sub.3x, .  . . , F.sub.Nx), where F represents the symbol frequency vector, 0 to N are the symbols in a file's
symbol dictionary, and x represents the source file of interest.  An ordered vector of bit lengths, where each bit length represents the number of bits that are represented by a particular symbol.  B.sub.x=(B.sub.0x, B.sub.1x, B.sub.2x, B.sub.3x, .  . .
, B.sub.Nx), where B represents the bit-length vector, 0 to N are the symbols in a file's symbol dictionary, and x represents the source file of interest.
<br/><br/> The symbol frequency vector can be thought of as a series of coordinates in an N-dimensional universe where N is the number of symbols defined in the alphabet of the dictionary, and the counts represent the distance from the origin along the
related coordinate axis.  The vector describes the file's informational position in the N-dimension universe.  The meaning of each dimension is defined by the meaning of its respective symbol.
<br/><br/> The origin of N-dimensional space is an ordered vector with a value of 0 for each coordinate: F.sub.O=(0, 0, 0, 0, 0, 0, 0, 0, .  . . , 0).
<br/><br/> The magnitude of the frequency vector is calculated relative to the origin.  An azimuth in each dimension can also be determined using ordinary trigonometry, which may be used at a later time.  By using Pythagorean geometry, the distance from
the origin to any point F.sub.x in the N-dimensional space can be calculated, i.e.: D.sub.ox=square root(((F.sub.0x-F.sub.0o)^2)+((F.sub.1x-F.sub.1o)^2)+((F.sub.2x-F.sub.2o)- ^2)+((F.sub.3x-F.sub.3o)^2)+ .  . . +((F.sub.Nx-F.sub.No)^2))
<br/><br/> Substituting the 0 at each coordinate for the values at the origin, the simplified equation is: D.sub.ox=square root((F.sub.0x)^2)+(F.sub.1x)^2)+(F.sub.2x)^2)+(F.sub.3x)^2)+ .  . . +(F.sub.Nx)^2))
<br/><br/> As an example, imagine that a file has 10 possible symbols and the frequency vector for the file is: F.sub.x=(3,5,6,1,0,7,19,3,6,22).
<br/><br/> Since this vector also describes the file's informational position in this 10-dimension universe, its distance from the origin can be calculated using the geometry outlined.  Namely, Dox=square
root(((3-0)^2)+((5-0)^2)+((6-0)^2)+((6-0)^2)+((1-0)^2)+((0-0)^2)+((7-0)^2- )+((19-0)^2)+((3-0)^2)+((6-0)^2)+((22-0)^2)) Dox=31.78.  Determining a Characteristic Digital Spectrum
<br/><br/> To create a digital spectrum for a file under current consideration, we begin with the key information 200, FIG. 84, which resulted from an original file of interest.  The digital spectrum determined for this original file is referred to as the
characteristic digital spectrum.  A digital spectrum for a related file of interest, on the other hand, is determined by its key information from another file.  Its digital spectrum is referred to as a related digital spectrum.
<br/><br/> The key information actually selected for the characteristic digital spectrum is considered to be a "well-suited key." A "well-suited key" is a key best derived from original data that is substantially similar to the current data in a current
file or source file to be examined.  The key might even be the actual compression key for the source file under consideration.  However, to eventually use the digital spectrum information for the purpose of file comparisons and grouping, it is necessary
to use a key that is not optimal for any specific file, but that can be used to define the N-dimensional symbol universe in which all the files of interest are positioned and compared.  The more closely a key matches a majority of the files to be
examined, the more meaningful it is during subsequent comparisons.
<br/><br/> The well-suited key can be used to derive the digital spectrum information for the characteristic file that we use to define the N-dimensional universe in which we will analyze the digital spectra of other files.  From above, the following
information is known about the characteristic digital spectrum of the file: The number of symbols (N) in the symbol dictionary The length of the source file in bits An ordered vector of symbol frequency counts F.sub.i=(F.sub.0i, F.sub.1i, F.sub.2i,
F.sub.3i, .  . . , F.sub.Ni), where F represents the symbol frequency, 0 to N are the symbols in the characteristic file's symbol dictionary, and i represents the characteristic file of interest.  An ordered vector of bit lengths B.sub.i=(B.sub.0i,
B.sub.1i, B.sub.2i, B.sub.3i, .  . . , B.sub.Ni), where B represents the bit-length vector, 0 to N are the symbols in the characteristic file's symbol dictionary, and i represents the characteristic file of interest.  Determining a Related Digital
Spectrum
<br/><br/> Using the key information and digital spectrum of the characteristic file, execute the process described in the fast approximation embodiment for a current, related file of interest, but with the following changes: 1.  Create a symbol frequency
vector that contains one coordinate position for the set of symbols described in the characteristic file's symbol dictionary.  F.sub.j=(F.sub.0j, F.sub.1j, F.sub.2j, F.sub.3j, .  . . , F.sub.Nj), where F represents the symbol frequency, 0 to N are the
symbols in the characteristic file's symbol dictionary, and j represents the related file of interest.  Initially, the count for each symbol is zero (0).  2.  Parse the data stream of the related file of interest for symbols.  As the file is parsed,
conduct the following: a. Tally the instance of each discovered symbol in its corresponding coordinate position in the symbol frequency vector.  That is, increment the respective counter for a symbol each time it is detected in the source file.  b. Do
not Huffman encode or write the detected symbol.  c. Continue parsing until the end of the file is reached.  3.  At the completion of the source file parsing, write a digital spectrum output file that contains the following: a. The number of symbols (N)
in the symbol dictionary b. The length of the source file in bits c. The symbol frequency vector developed in the previous steps.  F.sub.j=(F.sub.0v, F.sub.1j, F.sub.2j, F.sub.3j, .  . . , F.sub.Nj), where F represents the frequency vector, 0 to N are
the symbols in the characteristic file's symbol dictionary, and the j represents the file of interest.  d. The bit length vector B.sub.j=(B.sub.0j, B.sub.1j, B.sub.2j, B.sub.3j, .  . . , B.sub.Nj), where B represents the bit-length vector, 0 to N are the
symbols in the characteristic file's symbol dictionary, and j represents the file of interest.  Advantages of Digital Spectrum Analysis
<br/><br/> The digital spectrum of a file can be used to catalog a file's position in an N-dimensional space.  This position in space, or digital spectrum, can be used to compute "distances" between file positions, and hence similarity, e.g., the closer
the distance, the closer the similarity.  The notion of a digital spectrum may eventually lead to the notion of a self-cataloging capability of digital files, or other.
<br/><br/> Begin: Example Defining a File's Digital Spectrum
<br/><br/> To demonstrate the foregoing embodiment, the digital spectrum will be determined for a small data file that contains the following simple ASCII characters: aaaaaaaaaaaaaaaaaaaaaaaaaaabaaabaaaaaaaababbbbbb (eqn.  100)
<br/><br/> Each character is stored as a sequence of eight bits that correlates to the ASCII code assigned to the character.  The bit values for each character are: a=01100001 (eqn.  101) b=01100010 (eqn.  102)
<br/><br/> By substituting the bits of equations 101 and 102 for the "a" and "b" characters in equation 100, a data stream 30 results as seen in FIG. 9.  (Again, the characters are separated in the Figure with spaces for readability, but the spaces are not
considered, just the characters.)
<br/><br/> After performing an optimal compression of the data by using the process defined above in early embodiments, the symbols remaining in the data stream 30-7 are seen in FIG. 55.  Alternatively, they are shown here as:
0577777777777777777777777777735777357777777735735353535352 (eqn.  103)
<br/><br/> With reference to FIG. 95, table 300 identifies the symbol definitions from equation 103 and the bits they represent.  The symbol definition 302 identifies the alphabet of symbols determined from the data during the compression process.  The
symbols 0 and 1 are atomic symbols and represent original bits 0 and 1, by definition.  The subsequent symbols, i.e., 2-7, are defined by tuples, or ordered pairs of symbols, that are represented in the data, e.g. symbol 4 corresponds to a "1" followed
by a "3." or 1&gt;3.  In turn, each symbol represents a series or sequence of bits 304 in the data stream of equation 103 (the source file), e.g., symbol 4 corresponds to original bits 1100.
<br/><br/> With reference to table 310, FIG. 96, the number of occurrences of each symbol is counted in the data stream (equation 103) and the number of bits represented by each symbol is counted.  For example, the symbol "7" in equation 103 appears thirty
nine (39) times.  In that its original bits 304, correspond to "01011000," it has eight (8) original bits appearing in the data stream for every instance of a "symbol 7" appearing.  For a grand total of numbers of bits, the symbol count 312 is multiplied
by the bit length 314 to arrive at a bit count 316.  In this instance, thirty nine (39) is multiplied by eight (8) to achieve a bit count of three-hundred twelve (312) for the symbol 7.  A grand total of the number of bit counts 316 for every symbol 320
gives a length of the source file 325 in numbers of bits.  In this instance, the source file length (in bits) is three-hundred eighty-four (384).
<br/><br/> In turn, the scalar values to be used in the file's digital spectrum are: Source File Length in bits=384 Number of Symbols=8 total (or symbols 0 through 7, column 320, FIG. 96) The vectors to be used in the file's digital spectrum are: Frequency
spectrum, F.sub.x, represented by the ordered vector of counts for each symbol, from column 312, FIG. 96: F.sub.x=(1,0,1,8,0,9,0,39) Bit length spectrum, Bx, is represented by the ordered vector of counts for the original bits in the file that are
represented by each symbol, from column 314, FIG. 96: B.sub.x=(1,1,2,3,4,5,7,8)
<br/><br/> The digital spectrum information can be used to calculate various useful characteristics regarding the file from which it was derived, as well as its relationship to other spectra, and the files from which the other spectra were derived.  As an
example, the frequency spectrum F(x) shown above, may be thought to describe a file's informational position in an 8-dimension universe, where the meaning of each dimension is defined by the meaning of its respective symbols.
<br/><br/> Since the origin of the 8-dimensional space is an ordered vector with a value of 0 at each symbol position, e.g., F(0)=(0, 0, 0, 0, 0, 0, 0, 0), the informational position in 8-dimensional space can be defined as an azimuth and distance from the
origin.  The magnitude of the position vector is calculated using Pythagorean geometry.  Dist(x,0) sqrt(((F(x,0)-F(00)^2)+ .  . . (F(x,7)-F(0,7)^2)).  Simplified, this magnitude becomes Dist(x,0)=sqrt((F(x,0)^2+F(x,2)^2+F(x,3)^2 .  . . F(x,7)^2)).  Using
the values above in F.sub.x, the magnitude of the Dist(x,0)=40.84, or D.sub.x0=square root(((1)^2)+((0)^2)+((1)^2)+((8)^2)+((0)^2)+((9)^2)+((0)^2) ((39)^2))=square root (1+0+1+64+0+81+0+1521)=40.84.  Azimuth of the vector can be computed using basic
trigonometry.
<br/><br/> Using information found in the digital spectra of a group of files, an analysis can be done to determine similarity, or not, of two or more subject files.  Information from the digital spectrum is used to create an information statistic for a
file.  Statistics found to be pertinent in doing this analysis include at least:
<br/><br/> S1) Frequency of occurrence of each possible symbol (FREQ)
<br/><br/> S2) Normalized frequency of occurrence of each possible symbol (NORM FREQ)
<br/><br/> S3) Informational content of occurrence of each symbol (INFO)
<br/><br/> S4) Normalized information content of occurrence of each symbol (NORM INFO)
<br/><br/> For ease of reference, statistic S1 can be called FREQ for frequency, statistic S2 can be called NORM FREQ for normalized frequency, statistic S1 can be called INFO for informational content, and statistic S4 can be called NORM INFO for
normalized informational content.  A further discussion is given below for each of these statistical values.
<br/><br/> As a first example, a digital spectra of three files, F1, F2, and F3 is given with respect to a common set of "N" symbols, e.g., symbols 1, symbol 2 and symbol 3.  Each file is processed looking for the number of times each symbol is found in
the file.  The frequency of each symbol as it is found in each file is recorded along with a total number of symbols in each file.  For this example, their respective spectra are:
<br/><br/> TABLE-US-00004 File Description Total Symbol 1 Symbol 2 Symbol 3 File 1 Number of Symbols 3 Sum of all Symbol 9 Occurrences Symbol frequencies 2 4 3 Symbol bits sized 7 6 10 File 2 Number of Symbols 3 Sum of all Symbol 8 Occurrences Symbol
frequencies 4 2 2 Symbol bits sized 7 6 10 File 3 Number of Symbols 3 Sum of all Symbol 27 Occurrences Symbol frequencies 8 11 8 Symbol bits sized 7 6 10
<br/><br/> Using a relevant pattern-derived statistic (possibly including S1, S2, S3, or S4 above), a vector of values is calculated for the N symbol definitions that may occur in each file.  A position in N-dimensional space is determined using this
vector, where the distance along each axis in N-space is determined by the statistic describing its corresponding symbol.
<br/><br/> Specifically in this example, we will use statistic S1 (FREQ) and we have three (3) common symbols that we are using to compare these files and so a 3-dimensional space is determined.  Each file is then defined as a position in this
3-dimensional space using a vector of magnitude 3 for each file.  The first value in each vector is the frequency of symbol 1 in that file, the second value is the frequency of symbol 2, and the third value is the frequency of symbol 3.
<br/><br/> With reference to FIG. 97, these three example files are plotted.  The frequency vectors are F1=(2, 4, 3), F2=(4, 2, 2), and F3=(8, 11, 8).  The relative position in 3-space (N=3) for each of these files is readily seen.
<br/><br/> A matrix is created with the statistic chosen to represent each file.  A matrix using the symbol frequency as the statistic looks like the following:
<br/><br/> TABLE-US-00005 FileID Sym1 Sym2 Sym3 F1 2 4 3 F2 4 2 2 F3 8 11 8
<br/><br/> Using Pythagorean arithmetic, the distance (D) between the positions of any two files (Fx, Fy) is calculated as D(Fx,Fy)= {square root over ((Fx.sub.1-Fy.sub.1).sup.2+(Fx.sub.2-Fy.sub.2).sup.2+(Fx.sub.n-Fy.sub.n).- sup.2)}{square root over
((Fx.sub.1-Fy.sub.1).sup.2+(Fx.sub.2-Fy.sub.2).sup.2+(Fx.sub.n-Fy.sub.n).- sup.2)}{square root over ((Fx.sub.1-Fy.sub.1).sup.2+(Fx.sub.2-Fy.sub.2).sup.2+(Fx.sub.n-Fy.sub.n).- sup.2)} (1) In the example above, the distance between the position of F1 and
F2 is {square root over ((2-4).sup.2+(4-2).sup.2+(3-2).sup.2)}{square root over ((2-4).sup.2+(4-2).sup.2+(3-2).sup.2)}{square root over ((2-4).sup.2+(4-2).sup.2+(3-2).sup.2)}= {square root over ((4+4+1))}= {square root over (9)}=3.00 (2) Similarly, the
distance between H and F3 is found by {square root over ((2-8).sup.2+(4-11).sup.2+(3-8).sup.2)}{square root over ((2-8).sup.2+(4-11).sup.2+(3-8).sup.2)}{square root over ((2-8).sup.2+(4-11).sup.2+(3-8).sup.2)}= {square root over ((36+49+25))}= {square
root over (110)}=10.49 (3)
<br/><br/> A matrix of distances between all possible files is built.  In the above example this matrix would look like this:
<br/><br/> TABLE-US-00006 F1 F2 F3 F1 0.00 3.00 10.49 F2 3.00 0.00 11.53 F3 10.49 11.53 0.00 Distance between files
<br/><br/> It can be seen graphically in FIG. 97, that the position of File 1 is closer to File 2 than it is to File 3.  It can also be seen in FIG. 97 that File 2 is closer to File 1 than it is to File 3.  File 3 is closest to File 1; File 2 is slightly
further away.
<br/><br/> Each row of the matrix is then sorted, such that the lowest distance value is on the left, and the highest value is on the right.  During the sort process, care is taken to keep the File ID associated with each value.  The intent is to determine
an ordered distance list with each file as a reference.  The above matrix would sort to this:
<br/><br/> TABLE-US-00007 File Distance F1 F1 (0.00) F2 (3.00) F3 (10.49) F2 F2 (0.00) F1 (3.00) F3 (11.53) F3 F3 (0.00) F1 (10.49) F2 (11.53) Sorted Distance between files
<br/><br/> Using this sorted matrix, the same conclusions that were previously reached by visual examination can now be determined mathematically.  Exclude column 1, wherein it is obvious that the closest file to a given file is itself (or a distance value
of 0.00).  Column 2 now shows that the closest neighbor to F1 is F2, the closest neighbor to F2 is F1, and the closest neighbor the F3 is F1.
<br/><br/> Of course, this concept can be expanded to hundreds, thousands, or millions or more of files and hundreds, thousands, or millions or more of symbols.  While the matrices and vectors are larger and might take more time to process, the math and
basic algorithms are the same.  For example, consider a situation in which there exist 10,000 files and 2,000 symbols.
<br/><br/> Each file would have a vector of length 2000.  The statistic chosen to represent the value of each symbol definition with respect to each file is calculated and placed in the vector representing that file.  An information position in 2000-space
(N=2000) is determined by using the value in each vector position to represent the penetration along the axis of each of the 2000 dimensions.  This procedure is done for each file in the analysis.  With the statistic value matrix created, the distances
between each file position are calculated using the above distance formula.  A matrix that has 10,000 by 10,000 cells is created, for the 10,000 files under examination.  The content of each cell is the calculated distance between the two files
identified by the row and column of the matrix.  The initial distance matrix would be 10,000.times.10,000 with the diagonal values all being 0.  The sorted matrix would also be 10,000 by 10,000 with the first column being all zeros.
<br/><br/> In a smaller example, say ten files, the foregoing can be much more easily demonstrated using actual tables represented as text tables in this document.  An initial matrix containing the distance information of ten files might look like this.
<br/><br/> TABLE-US-00008 Distance Matrix Files F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F1 0.0 17.4 3.5 86.4 6.7 99.4 27.6 8.9 55.1 19.3 F2 17.4 0.0 8.6 19.0 45.6 83.2 19.9 4.5 49.2 97.3 F3 3.5 8.6 0.0 33.7 83.6 88.6 42.6 19.6 38.2 89.0 F4 86.4 19.0 33.7 0.0 36.1
33.6 83.9 36.2 48.1 55.8 F5 6.7 45.6 83.6 36.1 0.0 38.0 36.9 89.3 83.4 28.9 F6 99.4 83.2 88.6 33.6 38.0 0.0 38.4 11.7 18.4 22.0 F7 27.6 19.9 42.6 83.9 36.9 38.4 0.0 22.6 63.3 35.7 F8 8.9 4.5 19.6 36.2 89.3 11.7 22.6 0.0 8.1 15.3 F9 55.1 49.2 38.2 48.1
83.4 18.4 63.3 8.1 0.0 60.2 F10 19.3 97.3 89.0 55.8 28.9 22.0 35.7 15.3 60.2 0.0
<br/><br/> The distances in each row are then sorted such that an ordered list of distances, relative to each file, is obtained.  The file identity relation associated with each distance is preserved during the sort.  The resulting matrix now looks like
this:
<br/><br/> TABLE-US-00009 Sorted Distance Matrix 1 2 3 4 5 6 7 8 9 10 F1 F1(0.0) F3(3.5) F5(6.7) F8(8.9) F2(17.4) F10(19.3) F7(27.6) F9(55.1) F4- (86.4) F6(99.4) F2 F2(0.0) F8(4.5) F3(8.6) F1(17.4) F4(19.0) F7(19.9) F5(45.6) F9(49.2) F6- (83.2) F10(97.3)
F3 F3(0.0) F1(3.5) F2(8.6) F8(19.6) F4(33.7) F9(38.2) F7(42.6) F5(83.6) F6- (88.6) F10(89.0) F4 F4(0.0) F2(19.0) F6(33.6) F3(33.7) F5(36.1) F8(36.2) F9(48.1) F10(55.8)- F1(86.4) F7(83.9) F5 F5(0.0) F1(6.7) F10(28.9) F4(36.1 F7(36.9) F6(38.0) F2(45.6)
F9(83.4) F- 3(83.6) F8(89.3) F6 F6(0.0) F8(11.7) F9(18.4) F10(22.0) F4(33.6) F5(38.0) F7(38.4 F2(83.2) - F3(88.6 F1(99.4) F7 F7(0.0) F2(19.9) F8(22.6) F1(27.6) F5(36.9) F10(35.7) F6(38.4) F3(42.6)- F9(63.3 F4(83.9) F8 F8(0.0) F2(4.5) F9(8.1) F1(8.9)
F6(11.7) F10(15.3 F3(19.6 F7(22.6) F4(3- 6.2) F5(89.3) F9 F9(0.0 F8(8.1) F6(18.4) F3(38.2) F4(48.1) F2(49.2) F1(55.1) F10(60.2) F- 7(63.3) F5(83.4) F10 F10(0.0 F8(15.3 F1(19.3) F6(22.0) F5(28.9) F7(35.7) F4(55.8) F9(60.2) - F3(89.0) F2(97.3)
<br/><br/> Using the information in columns 1 and 2 a relationship graph can be created of closest neighbor files.  From the above matrix, skilled artisans will note the following:
<br/><br/> F1's nearest neighbor is F3.  Create a group, G1, assign these two files to that group.
<br/><br/> F2's nearest neighbor is F8.  Create a group.  G2, assign these two files to that group.
<br/><br/> F3 has already been assigned, its nearest neighbor is F1, and they belong to group G1.
<br/><br/> F4's nearest neighbor is F2, which already belongs to G2.  Assign F4 to G2 as well.
<br/><br/> F5's nearest neighbor is F1, which already belongs to G1.  Assign F5 to G1 as well.
<br/><br/> F6's nearest neighbor is F8, which already belongs to G2.  Assign F6 to G2 as well.
<br/><br/> F7's nearest neighbor is F2, which already belongs to G2.  Assign F7 to G2 also.
<br/><br/> F8's has already been assigned.  Its nearest neighbor is F2, and they belong to G2.
<br/><br/> F9's nearest neighbor is F8, which already belongs to G2.  Assign F9 to G2 also.
<br/><br/> F10's nearest neighbor is F8, which already belongs to G2.  Assign F10 to G2 also.
<br/><br/> The above "nearest neighbor" logic leads to the conclusion that two groups (G1 and G2) of files exist.  Group G1 contains F1, F3, F5, while Group G2 contains F2, F4, F6, F7, F8, F9, and F10.
<br/><br/> An algorithm for determining groups based on adjacent neighbors is given in FIG. 98A.  For each file in the scope of analysis 900, a closest neighbor is determined, 910.  From the example, this includes using the distance values that have been
sorted in columns 1 and 2.  If a closest neighbor already belongs to a group at 920, the file joins that group at 930.  Else, if the closest neighbor belongs to no group at 940, a new group is created at 950 and both files are added to the new group at
960.  From the example, F1's nearest neighbor is F3 and no groups exist at 940.  Thus, a new group G1 is created at 950 and both F1 and F3 are assigned, or added.  Similarly, F2's nearest neighbor is F8, but only group G1 exists.  Thus, a new group G2 is
created at 950 for files F2 and F8 at 960.  Later, it is learned that F4's nearest neighbor is F2, which already belongs to G2 at step 920.  Thus, at 930 file F4 joins group G2.  Once all files have been analyzed, the groups are finalized and group
processing ceases at 970.
<br/><br/> With reference to FIG. 98B, a graph of the relationships can be made, although doing so in 2D space is often difficult.  In groups G1 and G2 above, a representation of a 2-D graph that meets the neighbor criteria might look like reference
numeral 980.  Using this grouping method and procedure, it can be deduced that a group of files are pattern-related and are more closely similar to each other, than to files which find membership in another group.  Thus, files F1, F3 and F5 are more
closely similar than those in group G2.
<br/><br/> In order to find relationships to these groupings of files relevant to still other information, the following proposes an embodiment of a dynamic relevancy agent.
<br/><br/>Example
<br/><br/> 1.  First, the foregoing techniques are executed on unstructured or structured data.
<br/><br/> 2.  The self-organizing, emergent groups that this process uncovers are found.  It results first in digital spectra in N-dimensional space, such as FIG. 97, and second in groupings, such as 980, FIG. 98B.  Also, each member in a group is
relevant to other members of the group.  This could be one with one or more sets of keys 200 so that the groupings are varied and possibly overlapping.  That is one key could be generated by a target subset set of all of the files, another key could be
generated by the whole set of files, and in another case the key could be a key that has been created (using data outside of the data set under consideration) for a specific goal or purpose.
<br/><br/> 3.  These groups can be either raw (not tagged, not named, not classified, etc.) or that can be processed in a way that adds semantic meaning to the whole group.  The latter can occur by finding and adding semantic meaning and meta data to
groups either by using representative samples from the group, e.g., file F8, FIG. 98B having many associations to other files, or by harvesting unions from members of the groups, e.g., when more than one grouping shares a common file.
<br/><br/> Alternatively still, semantic meaning can be added by examining the most important symbols in the key that define an essence of the group.  As in FIG. 96, for instance, symbols 3, 5 and 7 would be the likely candidate symbols for defining an
essence of table 310 corresponding to the underlying data stream (equation 103).  Naturally, symbol 7 would be the best candidate as it appears thirty nine (39) times as compared to zero, one, eight, or nine times for the other symbols (symbol count
312).  In turn, other files in the groupings of files would reveal symbols that could be evaluated for their file's essence, and then applied to a group's essence.
<br/><br/> Regardless of how undertaken, FIG. 99 shows the grouping and differentiating of files occurring at step 800.
<br/><br/> 4.  One or more users work alone or in teams collaborating on a common task, assignment, document, picture, video, audio recording, etc. A Dynamic Relevancy Agent is installed on a computing device, e.g., FIG. 83, and is executing.  It
monitoring current data that the users are manipulating and events that the users are undertaking, step 810, FIG. 99.  Upon an appropriate trigger event, step 820, the agent undertakes finding relevancy data in the groupings, e.g., 980 of files.  It can
use several mechanisms representatively given as: By some action initiated by the user (save, send, copy, paste, delete, new paragraph, etc) By some time interval (every 3 minutes, 5 hours, 2 days, etc.) By some service specific action integrated into a
collaborative UI between the users (find now, find later, etc.).
<br/><br/> No matter how the action of finding relevant data is triggered, the agent runs the foregoing techniques against the current data being worked using the key or keys identified in item #2 of this example.
<br/><br/> 5.  At step 830, FIG. 99, the Dynamic Relevancy Agent (DRA) uses the groupings to find which group is the closest to the current data under consideration.  The closest groups could be any one of the following established by criterion/criteria in
a predetermined policy: The single closest group.  The I out of J closest groups.  The groups that are within some tolerance (might be 0 up to J groups).
<br/><br/> The furthest group (to show differentiation).  By applying statistical analysis.
<br/><br/> In this step, the DRA compares the location in N dimensional space for the current data that is being worked and compares it against the groupings that were found earlier.  If there is a match, it means some sort of relevancy exists between the
groupings and current data.  Also, the underlying content of the files and current data can exist in a variety of locations, such as a corporate store, public cloud, private cloud, local or remote storage, internet, intranet, etc.
<br/><br/> 6.  At 840, FIG. 99, the DRA then suggests offerings to the users that some other body of data exists that may be of interest to the current data or current actions.  Representatively, this suggestion is presented to the users in a UI.  The UI
can be separate or integral with the collaboration or productivity applications and user(s) can explore more what is being suggested.  They may chose to either ignore it or accept it.  In either case, the information is retained by the DRA to make even
better suggestions in the future.  If the users choose to accept the recommendation, the suggested relevant content is brought into the current context.
<br/><br/> With reference to FIG. 100, a more detailed example is given in the context of an email system 850 substantiated for use in a home, office, or enterprise context, etc. As a user enters current data 852 into a field monitored by the DRA, the DRA
is also monitoring actions of the user, such as whether "Send" email 854 is being requested.  If this action is established as the appropriate trigger event, the DRA automatically commences to finding or harvesting data relevant to the current data.  It
creates a digital spectrum of the appropriate current information, including any attachments 856 to the email, and examines this against the earlier grouped files G1, G2, at 980, FIG. 98B.  Upon finding that grouping G1 involves data about World War II,
and the current data relates to Winston Churchill, a user interface (UI) 860 on a computing device monitor offers suggestions 840 to the user.  If the user accepts it, the underlying content in files F1, F3 and F5 of group G1 are decompressed and
displayed to the user.  Naturally, this may further include an instance of arranging the files for presentation, such as by most-to-least relevant, or by some other criteria.  In any event, skilled artisans should recognize that what is being presented
to the user for examination is relevant matter, but without express or implicit requests by the user to find it.  It also occurs without need of any history of the user having been involved in finding data related to Winston Churchill or WWII data. 
Moreover, the current or original file data can be wholly unstructured and found variously in the farthest reaches of the internet and without metadata or other information associated with any of the files.  This is quite unlike modern day searching of
the internet that returns "hits" based on related metadata.
<br/><br/> With reference to FIG. 101, high level objectives are seen in diagram form 870, including multiple users.  At "C," the existing data is self-organized into various relevancy groups G1-G3, e.g., element 980, FIG. 98B.  At "D" and "E," two groups
of users are involved in collaborative efforts.  One is working on a project that turns out to be relevant to the "square" relevancy group G1, even though they do not know it.  The other is working on a project that turns out to be relevant to the
"triangle" relevancy group G2, even though they do not know it.
<br/><br/> At "F." the DRA exists.
<br/><br/> In step 2, the DRA determines if there is any content from C that is relevant to collaborative groups D and E. If so, it finds them and makes their existence known.  The net result is that the DRA can actively find data related to the work that
the collaborative team is working on and produce it for them without requested input.  Also, the process occurs on an entirety of information without any advance knowledge of where relevance groups are found in N-space and without needing any additional
algorithms for edge detection, hierarchical clustering, or other advanced mathematics.  Further, since a file's digital spectrum is created without regard to the type of information contained in the file, it applies equally to digital information of
files of any type, for example, text, audio, image, data, .pdf, .xls., .ppt, foreign language, etc. In turn, application of a file's grouping and differentiating can be applied vastly across technology described as "blue ocean." Early possibilities
considered by the inventors include, but are not limited to, automated organization of unstructured data based on underlying content (not metadata), research applications, such as the human genome databases, forensic searches, etc.
<br/><br/> Among certain advantages of the DRA approach to finding data include: finding and retrieving relevant data pro-actively; avoiding taking specific actions by users, other than to optionally accept or reject any suggested content; finding relevant
data by actual content, not associated metadata or other information; and targeting unstructured data found anywhere.
<br/><br/> The foregoing has been described in terms of specific embodiments, but one of ordinary skill in the art will recognize that additional embodiments are possible without departing from its teachings.  This detailed description, therefore, and
particularly the specific details of the exemplary embodiments disclosed, is given primarily for clarity of understanding, and no unnecessary limitations are to be implied, for modifications will become evident to those skilled in the art upon reading
this disclosure and may be made without departing from the spirit or scope of the invention.  Relatively apparent modifications, of course, include combining the various features of one or more figures with the features of one or more of the other
figures.
<br/><br/><center><b>* * * * *</b></center>
<hr/>
   <center>
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09292594&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D1005%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D21%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>
   <table>
   <tbody><tr><td align="center"><a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1005%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D21%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209292594"><img alt="[View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9292594&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D1005%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D21%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209292594">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
     <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1005&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=20&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1005&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=21&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1005&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=22&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1004&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=21&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=1006&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=21&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

   <a href="#top"><img alt="[Top]" border="0" src="/netaicon/PTO/top.gif" valign="middle"/></a>
   </td></tr>
   </tbody></table>
   <a name="bottom"></a>
   <a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
   </center>

</coma></body></html>
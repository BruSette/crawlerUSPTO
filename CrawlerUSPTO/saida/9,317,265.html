<html><head>
<base target="_top"/>
<title>United States Patent: 9317265</title></head>
<!---BUF1=9317265
BUF7=2016
BUF8=85095
BUF9=/1/
BUF51=9
---->
<body bgcolor="#FFFFFF">
<a name="top"></a>
<center>
<img alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" src="/netaicon/PTO/patfthdr.gif"/>
<br/>
<table>
<tbody><tr><td align="center">
<a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
<a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
<a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
<a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
</td></tr>
<tr><td align="center">
   <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=785&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=15&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=785&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=785&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=784&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=786&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

<a href="#bottom"><img alt="[Bottom]" border="0" src="/netaicon/PTO/bottom.gif" valign="middle"/></a>
</td></tr>
   <tr><td align="center">
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D785%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D16%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209317265"><img alt="[
View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9317265&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D785%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D16%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209317265">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09317265&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D785%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D16%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>

   </td></tr>
</tbody></table>
</center>
<table width="100%">
<tbody><tr><td align="left" width="50%"> </td>
<td align="right" valign="bottom" width="50%"><font size="-1">( <strong>785</strong></font> <font size="-2">of</font> <strong><font size="-1">7895</font></strong> <font size="-1">)</font></td></tr></tbody></table>
<hr/>
   <table width="100%">
   <tbody><tr>	<td align="left" width="50%"><b>United States Patent </b></td>
   <td align="right" width="50%"><b>9,317,265</b></td>
   </tr>
     <tr><td align="left" width="50%"><b>
             Adl-Tabatabai
,   et al.</b>
     </td>
     <td align="right" width="50%"> <b>
     April 19, 2016
</b></td>
     </tr>
     </tbody></table>
       <hr/>
       <font size="+1">Optimizing intermediate representation of script code for atomic execution
</font><br/>
       <br/><center><b>Abstract</b></center>
       <p> Disclosed here are methods, systems, paradigms and structures for
     optimizing intermediate representation (IR) of a script code for atomic
     execution. Atomic execution of the script is achieved by generating
     portions of the IR as an atomic transaction. In an atomic transaction, a
     series of operations either all execute, or none executes. The IR
     includes checkpoints that evaluate to one of two possible values. The
     checkpoint evaluates to a first value when there is no error during
     execution, and evaluates to a second value when an error occurs. The IR
     is optimized for atomic execution by regenerating a portion of the IR
     including the checkpoint and code associated with the checkpoint as a
     transaction. When an error occurs during the execution of the
     transaction, the transaction is aborted and a state of execution of the
     script code is reverted to a state prior to the beginning of the
     transaction.
</p>
       <hr/>
<table width="100%"> <tbody><tr> <th align="left" scope="row" valign="top" width="10%">Inventors:</th> <td align="left" width="90%">
 <b>Adl-Tabatabai; Ali-Reza</b> (San Jose, CA)<b>, de Lima Ottoni; Guilherme</b> (Campbell, CA)<b>, Paleczny; Michael</b> (San Jose, CA) </td> </tr>
<tr><th align="left" scope="row" valign="top" width="10%">Applicant: </th><td align="left" width="90%"> <table> <tbody><tr> <th align="center" scope="column">Name</th> <th align="center" scope="column">City</th> <th align="center" scope="column">State</th> <th align="center" scope="column">Country</th> <th align="center" scope="column">Type</th> </tr> <tr> <td> <b><br/>Adl-Tabatabai; Ali-Reza
<br/>de Lima Ottoni; Guilherme
<br/>Paleczny; Michael</b> </td><td> <br/>San Jose
<br/>Campbell
<br/>San Jose </td><td align="center"> <br/>CA
<br/>CA
<br/>CA </td><td align="center"> <br/>US
<br/>US
<br/>US </td> <td align="left"> </td> </tr> </tbody></table>
<!-- AANM>
~AANM Adl-Tabatabai; Ali-Reza
~AACI San Jose
~AAST CA
~AACO US
~AANM de Lima Ottoni; Guilherme
~AACI Campbell
~AAST CA
~AACO US
~AANM Paleczny; Michael
~AACI San Jose
~AAST CA
~AACO US
</AANM -->
</td></tr>
<tr> <th align="left" scope="row" valign="top" width="10%">Assignee:</th>
<td align="left" width="90%">

<b><a href="#h0" name="h1"></a><a href="#h2"></a><b><i>Facebook,</i></b> Inc.</b>
 (Menlo Park, 
CA)
<br/>

</td>
</tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Family ID:
       </th><td align="left" width="90%">
       <b>1000001786676
</b></td></tr>
       <tr><th align="left" nowrap="" scope="row" valign="top" width="10%">Appl. No.:
       </th><td align="left" width="90%">
       <b>13/850,238</b></td></tr>
       <tr><th align="left" scope="row" valign="top" width="10%">Filed:
       </th><td align="left" width="90%">
       <b>March 25, 2013</b></td></tr>
     </tbody></table>
<hr/> <center><b>Prior Publication Data</b></center> <hr/> <table width="100%"> <tbody><tr><th scope="col"></th><th scope="col"></th><td></td></tr> <tr><td align="left">
</td><th align="center" scope="col"><b><u>Document Identifier</u></b></th><th align="center" scope="col"><b><u>Publication Date</u></b></th></tr><tr><td align="center"> </td><td align="center"> US 20140289716 A1</td><td align="center">Sep 25, 2014</td></tr><tr><td align="center"> 
</td>
</tr> </tbody></table>
     <hr/>
<p> <table width="100%"> <tbody><tr><td align="left" valign="top" width="30%"><b>Current U.S. Class:</b></td> <td align="right" valign="top" width="70%"><b>1/1</b> </td></tr> 
       <tr><td align="left" valign="top" width="30%"><b>Current CPC Class: </b></td>
       <td align="right" valign="top" width="70%">G06F 8/4441 (20130101)</td></tr>
         <tr><td align="left" valign="top" width="30%"><b>Current International Class: </b></td>
         <td align="right" valign="top" width="70%">G06F 9/45 (20060101)</td></tr>
     </tbody></table>
</p><hr/><center><b>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=PALL&amp;Query=ref/9317265">[Referenced By]</a></b></center>       <hr/>
       <center><b>U.S. Patent Documents</b></center>
<table width="100%"> <tbody><tr><th scope="col" width="33%"></th> <th scope="col" width="33%"></th> <th scope="col" width="34%"></th></tr> <tr> <td align="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6363403">6363403</a></td><td align="left">
March 2002</td><td align="left">
Roy et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20030101444&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2003/0101444</a></td><td align="left">
May 2003</td><td align="left">
Wu et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20060130038&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2006/0130038</a></td><td align="left">
June 2006</td><td align="left">
Claussen et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080244544&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0244544</a></td><td align="left">
October 2008</td><td align="left">
Neelakantam et al.</td></tr><tr><td align="left">
<a href="http://appft.uspto.gov/netacgi/nph-Parser?TERM1=20080294853&amp;Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PG01&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.html&amp;r=0&amp;f=S&amp;l=50" target="_blank">2008/0294853</a></td><td align="left">
November 2008</td><td align="left">
Kowlali et al.</td></tr><tr><td align="left">

</td>
</tr> </tbody></table>
       <i>Primary Examiner:</i> Das; Chameli
<br/>
       <i>Assistant Examiner:</i> Macasiano; Joanne
<br/>
       <i>Attorney, Agent or Firm:</i> <coma>Perkins Coie LLP
<br/>
         <hr/>
<center><b><i>Claims</i></b></center> <hr/> <br/><br/>What is claimed is: <br/><br/> 1.  A method, comprising: generating, at a computer in a computer system, an intermediate representation of a script code, the intermediate representation having intermediate
code representing the script code;  identifying, at the computer, a unit of intermediate code, the unit of intermediate code including (i) a checkpoint that evaluates to a first value or a second value and (ii) the intermediate code associated with the
checkpoint, the intermediate code associated with the checkpoint including: a first set of code associated with a variable on which the checkpoint is operating, the first set of code causing the variable to evaluate to the first value or the second value
and executing prior to execution of the checkpoint, and a second set of code that is dependent on a value of the variable;  and regenerating, by the computer and in the intermediate representation, the unit of intermediate code as a transaction, the
regenerating as a transaction including: causing, upon execution of the intermediate representation, to abort execution of the unit of intermediate code when the checkpoint evaluates to the second value, and causing, upon abortion of the execution of the
unit of intermediate code, a current state of execution of the intermediate representation to revert to a state that existed before the beginning of execution of the unit of intermediate code.
<br/><br/> 2.  The method of claim 1 further comprising: converting, at the computer, the intermediate representation to the executable code in response to a request to execute the script code.
<br/><br/> 3.  The method of claim 2 further comprising: executing, at the computer, the script code using the generated executable code in response to the request.
<br/><br/> 4.  The method of claim 1, wherein the first value of the checkpoint causes the script code to execute in a fast path.
<br/><br/> 5.  The method of claim 4, wherein the fast path includes a path of execution of the script code whose frequency of execution exceeds a predefined threshold.
<br/><br/> 6.  The method of claim 1, wherein the second value of the checkpoint causes the script code to execute in a slow path.
<br/><br/> 7.  The method of claim 6, wherein the slow path includes a path of execution of the script code whose frequency of execution is below a predefined threshold.
<br/><br/> 8.  The method of claim 1, wherein the checkpoint evaluates to the first value more frequently than to the second value.
<br/><br/> 9.  The method of claim 1, wherein the checkpoint evaluates to the first value when no errors are detected in the intermediate code associated with the checkpoint.
<br/><br/> 10.  The method of claim 1, wherein the checkpoint evaluates to the second value when an error is detected in the intermediate code associated with the checkpoint.
<br/><br/> 11.  The method of claim 1, wherein the intermediate code associated with the checkpoint includes intermediate code that (i) influences the checkpoint to evaluate to the first value or the second value and (ii) is affected by the checkpoint.
<br/><br/> 12.  The method of claim 1, wherein the checkpoint in the transaction includes intermediate code for decrementing a reference count of an object when a pointer referring to the object is removed.
<br/><br/> 13.  The method of claim 12, wherein the intermediate code for decrementing the reference count includes a condition to determine whether the reference count of the object is a non-zero value or zero.
<br/><br/> 14.  The method of claim 13, wherein the checkpoint including the intermediate code decrementing the reference count causes the transaction to abort if the reference count is decremented to zero.
<br/><br/> 15.  The method of claim 1, wherein the checkpoint in the transaction includes a condition to determine whether a data type of a programming construct is of a particular data type.
<br/><br/> 16.  The method of claim 15, wherein the checkpoint causes the transaction to abort if the data type of the programming construct is not of the particular data type.
<br/><br/> 17.  A method, comprising: storing a first state of execution of a script code in a memory of a computer, the first state being a state of execution of the script code prior to beginning the execution of a transaction, the transaction being a
unit of intermediate code in an intermediate representation of the script code, the unit of intermediate code including (i) a checkpoint that evaluates to a first value or a second value and (ii) the intermediate code associated with the checkpoint, the
intermediate code associated with the checkpoint including: a first set of code associated with a variable on which the checkpoint is operating, the first set of code causing the variable to evaluate to the first value or the second value and executing
prior to execution of the checkpoint, and a second set of code that is dependent on a value of the variable;  executing, at the computer, the transaction;  determining, at the computer, whether the checkpoint evaluated to the second value;  responsive to
a determination that the checkpoint evaluated to the second value, aborting the execution of the transaction, and reverting a current state of execution of the script code to the first state.
<br/><br/> 18.  The method of claim 17, wherein reverting a current state of execution of the script code to the first state includes undoing changes made to data associated with the script code from the beginning of the transaction to until the
transaction is aborted.
<br/><br/> 19.  The method of claim 17, wherein the checkpoint evaluates to the first value more frequently than to the second value.
<br/><br/> 20.  A system, comprising: a processor;  an intermediate representation generation module working in cooperation with the processor to generate an intermediate representation of a script code, the intermediate representation including
intermediate code representing the script code;  an intermediate representation analysis module working in cooperation with the processor to identify a unit of intermediate code in the intermediate representation, the unit of intermediate code including
(i) a checkpoint that evaluates to a first value or a second value and (ii) the intermediate code associated with the checkpoint, the intermediate code associated with the checkpoint including: a first set of code associated with a variable on which the
checkpoint is operating, the first set of code causing the variable to evaluate to the first value or the second value and executing prior to execution of the checkpoint, and a second set of code that is dependent on a value of the variable;  a
transaction generation module that works in cooperation with the processor to regenerate the unit of intermediate code as a transaction;  and a transactional memory that works in cooperation with the processor, to execute the transaction, the executing
the transaction including causing, upon execution of the intermediate representation, to abort execution of the unit of intermediate code when the checkpoint evaluates to the second value, and causing, upon abortion of the execution of the unit of
intermediate code, a current state of execution of the intermediate representation to revert to a state that existed before the beginning of execution of the unit of intermediate code. <hr/> <center><b><i>Description</i></b></center> <hr/> <br/><br/>FIELD OF
INVENTION
<br/><br/> This invention relates to compilation of script code in general and more specifically to optimizing an intermediate representation (IR) of the script code for atomic execution.
<br/><br/>BACKGROUND
<br/><br/> Scripting languages offer simplicity and ease of development to software developers.  Script code is easy to write since scripting languages are often based on a small set of expressions and statements that are simple to learn.  Software
developers often use scripting languages for rapid development of applications, for example, web applications.  Scripting languages may be used for server side programs or for client side programs.  Examples of server side scripting languages include PHP
(Personal Home Page) and examples of client side scripting languages include JAVASCRIPT.
<br/><br/> Server side script code can be used for executing a user request received at a web server by dynamically generating web pages.  Server side scripting is often used for implementation of interactive websites that interface with data stores for
retrieving and storing information.  The PHP scripting language allows embedding of script code with hypertext markup language (HTML).  Client side script code is often used for performing simple computations on the client side rather than sending a
request to the server for simple computations.
<br/><br/> Conventional approaches to execute script code include executing the script code using an interpreter.  However, an interpreter may not be able to perform several optimizations that a compiler that generates executable code can perform. 
Therefore, interpreting script code can be inefficient compared to running executable code obtained by compiling the script code.  Most compilers translate the source program first to some form of intermediate representation (IR) and convert from there
into machine code.  The IR is independent of the machine for which the IR is generated, and independent of the source code language it is generated from.
<br/><br/> There are many IRs in use but these various representations are not efficient in terms of consumption of computing resources.  The IRs include code for performing error checks.  For example, in one situation where a destructor is executed, the
code may potentially run into an error such as null pointer exception.  So, the IRs include code for checking if an error has occurred due to the execution of the destructor and for handling the error.  However, such checks are performed at every
instance a programming construct that can potentially be affected is accessed, and/or every time the program is executed.  Further, these checks are executed even in situations where the likelihood of a executing a destructor is less.  Accordingly, an
executable code generated from the IR includes significant amount of code for performing such checks, which consumes significant computing resources.
<br/><br/>SUMMARY
<br/><br/> Introduced here are methods, systems, paradigms and structures for optimizing an intermediate representation (IR) of a script code for atomic execution.  Atomic execution of the script is achieved by generating portions of the IR as an atomic
transaction (also referred to as "transaction").  In an atomic transaction, a series of operations either all execute, or none executes.  When an error occurs during the execution of the operations in the transaction, the transaction is aborted and a
state of execution of the script code is reverted to a state prior to the beginning of execution of the transaction.  Any changes made to data associated with the script code from the beginning of the transaction to up until the transaction is aborted is
undone.
<br/><br/> The IR includes checkpoints which evaluate to one of two possible values.  While one of the values results in a fast path execution, the other results in a slow path execution.  A fast path is typically a path that handles most commonly
occurring tasks more efficiently than less commonly occurring ones.  The less commonly occurring ones are handled by slow paths.  The less commonly occurring tasks may include uncommon cases, error handling, and other anomalies.
<br/><br/> The IR is optimized for fast path execution by regenerating a portion of the IR including the checkpoint and code associated with the checkpoint as a transaction.  As long as the checkpoint evaluates to a value that results in fast path
execution, the transaction executes successfully.  When the checkpoint evaluates to a value that results in slow path execution, for example, on occurrence of error in execution, the execution of the transaction is aborted and a state of execution of the
script code is reverted to a state prior to the beginning of the execution of the transaction.
<br/><br/> Embodiments of the disclosed techniques eliminate the need to generate code for error handling.  Accordingly, the code for a number of error checks is minimized, which results in an improved performance in execution of the code.
<br/><br/> Some embodiments of the disclosed technique have other aspects, elements, features, and steps in addition to or in place of what is described above.  These potential additions and replacements are described throughout the rest of the
specification. <br/><br/>BRIEF DESCRIPTION OF THE DRAWINGS
<br/><br/> FIG. 1 is an environment in which an embodiment of the disclosed technique may operate.
<br/><br/> FIG. 2 is a block diagram illustrating an architecture of an online system that generates dynamic web pages by incrementally compiling script code at runtime.
<br/><br/> FIG. 3 is a flow diagram illustrating the process of compiling script code.
<br/><br/> FIG. 4 illustrates the structure of executable code generated by a script compiler.
<br/><br/> FIG. 5 is a block diagram illustrating incremental compilation of byte code obtained from an example script code.
<br/><br/> FIG. 6 illustrates a block diagram of a system for generating an intermediate representation (IR) of a script code and converting the IR to executable code for executing the script code.
<br/><br/> FIG. 7 illustrates a block diagram of a system for optimizing the IR of the script code for atomic execution.
<br/><br/> FIG. 8 illustrates an example of optimizing an IR of script code for atomic execution by regenerating a unit of intermediate code in the IR as a transaction.
<br/><br/> FIG. 9 is a flow diagram illustrating a process of optimizing the IR of the script code for atomic execution by regenerating a unit of intermediate code in the IR as a transaction.
<br/><br/> FIG. 10 is a flow diagram illustrating a process of executing the script code having transactions.
<br/><br/> FIG. 11 is a block diagram of a processing system that can implement operations of the present invention.
<br/><br/>DETAILED DESCRIPTION
<br/><br/> References in this description to "an embodiment", "one embodiment", or the like, mean that the particular feature, function, or characteristic being described is included in at least one embodiment of the present invention.  Occurrences of such
phrases in this specification do not necessarily all refer to the same embodiment, nor are they necessarily mutually exclusive.
<br/><br/> A software source code compiler can translate a source program first to some form of an intermediate representation (IR) and then convert the IR into machine code or executable code.  In an embodiment, the IR is a machine-and-language
independent version of the source code.  Use of an IR provides advantages in increased abstraction, cleaner separation between the front and back ends, and adds possibilities for cross-compilation among various type of systems and/or languages.  IRs also
lend themselves to supporting advanced compiler optimizations.  Further, different compilers can generate different types of IR.
<br/><br/> Disclosed here are methods, systems, paradigms and structures for optimizing an intermediate representation (IR) of a script code for atomic execution.  Atomic execution of the script is achieved by generating portions of the IR as an atomic
transaction (also referred to as "transaction").  In an atomic transaction, a series of operations either all execute, or none executes.  When an error occurs during the execution of the operations in the transaction, the transaction is aborted and a
state of execution of the script code is reverted to a state prior to the beginning of execution of the transaction.  Any changes made to data associated with the script code from the beginning of the transaction to up until the transaction is aborted is
undone.
<br/><br/> The IR includes checkpoints which evaluate to one of two possible values.  While one of the values results in a fast path execution, the other results in a slow path execution.  A fast path is typically a path that handles most commonly
occurring tasks more efficiently than less commonly occurring ones.  The less commonly occurring ones are handled by slow paths.  The less commonly occurring tasks may include uncommon cases, error handling, and other anomalies.
<br/><br/> The IR is optimized for fast path execution by regenerating a portion of the IR including the checkpoint and code associated with the checkpoint as a transaction.  As long as the checkpoint evaluates to a value that results in fast path
execution, the transaction executes successfully.  When the checkpoint evaluates to a value that results in slow path execution, for example, on occurrence of error in execution, the execution of the transaction is aborted and a state of execution of the
script code is reverted to a state prior to the beginning of the execution of the transaction.
<br/><br/> Embodiments of the disclosed techniques eliminate the need to generate code for error handling.  Accordingly, the code for a number of error checks is minimized, which results in an improved performance in execution of the code.
<br/><br/> The IR for the script code could be in various formats that are in between the original source code and an executable code generated for a particular machine.  The various formats can include a byte code, a low level language code, or any other
human understandable format.  The script code can be written in various programming languages, including PHP (Personal Home Page), and programming languages that provide support for either a single-threaded execution or multi-threaded execution.  The
embodiments of the disclosed technique are described with reference to FIGS. 6-11.  Further, the above described embodiments may be performed in various environments, including the environments described in association with FIGS. 1-5.
<br/><br/> FIG. 1 shows a system environment for allowing a client device to interact with an online system that generates dynamic web pages by compiling script code, in accordance with an embodiment of the disclosed technique.  FIG. 1 illustrates client
devices 160 interacting with an online system 100 using the network 150.  The client devices 160 send requests to the online system 100 via the network 150.  The online system 100 may dynamically generate web pages in response to the request and send the
generated web pages to the client device 160 in response to the request.
<br/><br/> FIG. 1 and the other figures use like reference numerals to identify like elements.  A letter after a reference numeral, such as "160a," indicates that the text refers specifically to the element having that particular reference numeral.  A
reference numeral in the text without a following letter, such as "160," refers to any or all of the elements in the figures bearing that reference numeral (e.g. "160" in the text refers to reference numerals "160a" and/or "160b" in the figures).
<br/><br/> Embodiments of the computing environment can have multiple client devices 160 and multiple online systems 100 connected to the network 150.  Certain functionality described in one embodiment as being performed on the server side can also be
performed on the client side in other embodiments if appropriate.  For example, although FIG. 1 shows the script compiler 110 running on the online system 100 for compiling server side script code, in other embodiments, the script compiler 110 may run on
the client device 160 for compiling client side script code.  In addition, the functionality attributed to a particular component can be performed by different or multiple components operating together.
<br/><br/> The client devices 160 include one or more computing devices that can receive user input and can transmit and receive data via the network 150.  The client device 160 can execute an application, for example, a browser application 170 that allows
a user of the client device 160 to interact with the online system 100.  A user may provide input using a user interface presented to the user via the browser application 170.  The interactions of the user via the browser application 170 may cause the
browser application 170 to send a request for information that identifies a markup language document including server side scripting code.  The markup language document is processed to obtain a transformed markup language document that is returned in
response to the request.
<br/><br/> The network 150 uses standard communications technologies and/or protocols.  Thus, the network 150 can include links using technologies such as Ethernet, 802.11, worldwide interoperability for microwave access (WiMAX), 3G, digital subscriber
line (DSL), etc. Similarly, the networking protocols used on the network 150 can include multiprotocol label switching (MPLS), the transmission control protocol/Internet protocol (TCP/IP), the User Datagram Protocol (UDP), the hypertext transport
protocol (HTTP), the simple mail transfer protocol (SMTP), the file transfer protocol (FTP), etc. The data exchanged over the network 170 can be represented using technologies and/or formats including the hypertext markup language (HTML), the extensible
markup language (XML), etc. In addition, all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer (SSL), transport layer security (TLS), Internet Protocol security (IPsec), etc.
<br/><br/> The online system 100 comprises a web server 130, a script compiler 110 and a script code store 120.  The web server 130 is a module processing requests received by the online system 100 from client devices 160 or other external systems that
interact with the online system 100.  The web server 110 may be implemented by conventional web server software, such as APACHE or INTERNET INFORMATION SERVICES.  In response to a request from a client device 160, the web server 130 may invoke other
modules of the online system 100 to process the request.  For example, the web server 130 may invoke modules of the online system 100 to obtain a web page in response to the request from the client device 160.  The web server 130 sends the web page to
the client device 160 for presentation on the browser 170.
<br/><br/> The script code store 120 stores script code that implements portions of functionality provided by the online system 100 to client devices 160.  A script code may include a function, procedure, method, or a block of code that may be embedded
within an HTML document.  The script code implements functionality, for example, retrieving information stored in various databases of the online system 100, performing computations, or interacting with other systems.
<br/><br/> The script compiler 110 takes script code in source code form and generates equivalent executable code for execution by a processor of the online system 100 (in this disclosure, the term "script code" is also referred to as "script.) In an
embodiment, the script compiler 110 performs incremental compilation of the script code in a lazy fashion.  For example, a portion of script code is compiled if a request causes this portion of script code to execute.  Once a portion of the script code
is compiled, the generated executable code is available for future requests.  However, if no request received by the online system 100 needs to execute a particular portion of the script code, that particular portion may not be compiled.  Therefore, no
executable code corresponding to a particular portion of script may exist in the online system 100 if no request from a client device needs to execute that portion of script.  For example, a script may include an "if-then-else" statement that executes an
"if" portion of script if a condition evaluates to true and an "else" portion of script if the condition evaluates to false.  If all incoming requests evaluate the condition to a true value, these request only execute the "if" part of the script. 
Accordingly, executable code corresponding to the "else" part of the "if-then else" statement may never be generated, unless an incoming request results in the condition being evaluated to a false value.
<br/><br/> FIG. 2 illustrates an architecture of an online system 100 that generates dynamic web pages by incrementally compiling script code at runtime, in accordance with an embodiment of the disclosed technique.  The online system includes the script
code store 120, an abstract syntax tree (AST) store 250, a byte code store 260, an executable code store 270, an execution engine 240, and the script compiler 110.  The script compiler 110 further includes a parser 210, a byte code generator 220, and a
byte code compiler 230.  Some embodiments of the online system 100 have different and/or other modules than the ones described herein, and the functions can be distributed among the modules in a different manner than is described here.  For example,
several modules shown in the online system 100 may be present in a client device 160 if the script code being processed is client side script code.
<br/><br/> The script code store 120 stores script code, for example, script code specified as PHP, server side JAVASCRIPT, or another syntax.  The script code may be input by a software developer using an editor or copied from another computer.  In an
embodiment, the script code is specified in a human readable text form.  The parser 210 reads the script code from one or more files in the script code store 120 and builds a data structure called an AST that is stored in the AST store 250.  The AST is a
hierarchical tree representation of script code.  The parser 125 checks the script code for syntax errors and reports the errors to allow a user to correct the errors.
<br/><br/> The byte code generator 220 traverses the AST representation of the script code and generates byte code corresponding to the script code.  The byte code is stored in the byte code store 260.  The byte code includes code represented using an
instruction set that is designed for efficient execution by an interpreter or for efficient compilation into executable code, for example, machine code.  The byte code instructions may correspond to a virtual stack machine or a virtual register machine. 
The byte code compiler 230 converts byte code into executable code and stores the generated executable code in the executable code store 270.
<br/><br/> The execution engine 240 executes the instructions available in the executable store 270.  For example, the execution engine 240 may be invoked in response to a request received from a client device 160.  The execution engine 240 identifies
executable code corresponding to the request received for execution.  An online system 100 may compile all available byte code stored in the byte code store 260, for example, as a batch process and store the generated executable code in the executable
code store 270.  Compiling all available byte code store in advance ensures that executable code is readily available for any request that is received by the online system, so long as the corresponding script code is available in the script code store
120.  However, script code typically supports features that make it difficult to generate efficient executable code.  For example, script code may support untyped variable for which the type is not available until runtime.  Programmers often use untyped
variables since they do not require the programmer to make early decisions regarding types of variables used.  A programmer may specify a variable as untyped even if at runtime the variable only stores values of one particular type, for example, an
integer value.  In practice significant amount of script code is executed based on a limited set of types corresponding to the untyped variables.  However, if the online system 100 compiles the byte code to executable code prior to receiving the requests
at runtime, the type information may not be available for the variables.  A byte code compiler 230 that compiles the byte code without making any specific assumptions about the types of the variables may generate inefficient executable code since the
generated executable code accounts for all possible types that each untyped variable may take, whether or not the incoming requests use these types.
<br/><br/> Embodiments of the byte code compiler 230 compile byte code to executable code based on information available at runtime.  For example, the byte code compiler 230 may utilize type information of variables obtained during an execution of the
script code to generate executable code optimized for these specific types.  Accordingly, executable code required for executing a request may or may not be available in the executable code store 270 at runtime.  If executable code corresponding to the
request is not available in the executable code store 270, the execution engine 240 identifies byte code corresponding to the request from the byte code store 230.  The execution engine 240 invokes the byte code compiler 230 to compile the byte code
corresponding to the request to generate executable code.  The execution engine 240 provides type information of variables obtained during the current execution of the script code to the byte code compiler 230.  Accordingly, the byte code compiler 230
generates efficient executable code based on the type information of variables available.  The execution engine 240 executes the generated executable code.  In some embodiments, executable code may be generated directly from script code without requiring
byte code generation.
<br/><br/> If future executions of the script code provide variables of the same type as the first request, the executable code can be reused for the future requests.  However, if a subsequent execution provides a different combination of types of
variables compared to the first execution, the execution engine 240 invokes the byte code compiler 230 to generate executable code corresponding to the new combination of types corresponding to the variables.  Accordingly, the executable code store 270
may store different executable codes for the same byte code program, each executable code corresponding to a different combination of variable types.  The byte code compiler 230 may never generate executable code corresponding to type combinations that
are never received in executions of the script code.
<br/><br/> In an embodiment, the byte code compiler 230 compiles a basic block of byte code at a time.  A basic block of code has one entry point, i.e., no instruction within the basic block other than the entry point can be reached from anywhere in the
script code as a destination of a jump instruction.  The entry point is typically the first instruction of the basic block.  A basic block may have one or more exit point, i.e., typically the last instruction of the basic block causes the program control
to start executing another basic block.  The last instruction may evaluate certain condition and determine the next basic block for execution based on the result of the evaluation of the condition.  For example, the last instruction may evaluate a binary
condition and transfer program control to one basic block if the condition evaluates to true otherwise transfer program control to another basic block (if condition evaluates to false).  Similarly, the last instruction of the basic block may transfer
control to different basic blocks based on the value of a particular variable.  For example, if the variable value is 1, program control is transferred to basic block B1, if the variable value is 2, program control is transferred to basic block B2, if
the variable value is 3, program control is transferred to basic block B3, and so on.  The simple structure of a basic block makes it easy for the byte code compiler 230 to optimize and compile a basic block.
<br/><br/> The executable code of the script includes executable blocks (also referred as "executable basic blocks") of the script and/or executable control regions of the script.  An executable block corresponds to a basic block of the script (which is
described in further detail with reference to FIGS. 4 and 5), whereas an executable control region of the script includes instructions for executing a set of basic blocks.  An executable control generator 235 generates an executable control region for a
set of basic blocks based on various criteria (which is described in further detail with reference to FIGS. 6-10).
<br/><br/> FIG. 3 is a flow diagram illustrating the process of compiling script code, in accordance with one embodiment of the disclosed technique.  The process illustrated in FIG. 3 may be executed by the script compiler 110 as a batch process that
compiles script code stored in the script code store 120.  For example, software developers may periodically provide new scripts implementing certain features of the online system 100.  The received script code may be compiled as a batch process by the
online system 100.  Alternatively, software developers may update existing script code, thereby requiring recompilation of the updated script code.  The script compiler 110 may repeat the steps shown in FIG. 3 for all the script code that need to be
recompiled.
<br/><br/> The script compiler 110 identifies 310 a script for compilation.  The script compiler 110 invokes the parser 210 for parsing the script.  The parser 210 parses 320 the script code to generate an AST representation of the script code.  The parser
210 stores the AST representation in the AST store 250.  In an embodiment, modules of the script compiler 110 perform various operations using the AST representation, for example, static analysis, type inference, and optimizations.  As a result, the
script compiler 110 may annotate the AST and/or transform the AST.  The script compiler 110 stores the annotated ASTs or the transformed ASTs in the AST store 250.  Each step performed by the script compiler 110 typically use the latest version of the
AST from the AST store 250 and generates a subsequent version of the AST.  The byte code compiler 230 generates 330 byte code from the AST representation of the script code and stores 340 the generated byte code in the byte code store 260.
<br/><br/> The byte code compiler 230 incrementally compiles the byte code stored in the byte code store at runtime to generate corresponding executable code.  The byte code compiler 230 performs the incremental compilation responsive to executions of the
script code, for example, executions caused by requests received from client devices 160.
<br/><br/> In at least some embodiments, the execution engine 240 requests compilation of one basic block of byte code at a time.  More specifically, the execution engine 240 requests compilation of one basic block for a particular combination of types of
the variables as required for execution of an incoming request.  In at least some other embodiments, the execution engine 240 may request compilation of a group of basic blocks to generate more optimal executable code.  Additionally or alternatively, the
execution engine 240 may request the compilation of one basic block during a first phase of execution of the script, and request compilation of group of basic blocks during a second phase of execution.
<br/><br/> FIG. 4 is a diagram illustrating the structure of executable code generated by a script compiler, in accordance with one embodiment of the disclosed technique.  The generated executable basic block 410 includes a portion of guard code 430, a
basic block body 440, and one or more exit pointers 450.  The executable basic block 410 is generated in response to receiving a request from the client device 160.  Accordingly, the executable basic block 410 is optimized for the types of variables as
provided by the incoming request.
<br/><br/> The following example illustrates how executable code is generated for a given basic block.  Assume that a basic block includes two untyped variables varA and varB.  Further assume that for a particular execution it is determined that both
variables varA and varB are integers.  Accordingly, the byte code compiler 230 compiles the basic block to generate the basic block body 440 assuming the variables varA and varB are integers.  The guard code 430 includes instructions that check a
particular condition before executing the basic block body 440.  In the above example, the generated guard code 430 verifies that the types of variables varA and varB are integers.  If the types of both variables are integers, the guard code 430
continues execution of the basic block body 440.
<br/><br/> The last instruction of an executable basic block 410a that is executed typically causes the program control to begin execution of another executable basic block 410b.  Accordingly, the last instruction of the executable basic block 410 may
include an exit pointer 450 that specifies the address of an executable basic block 410b for execution after the execution of the executable basic block 410.  The last instruction of an executable basic block 410a that is executed may transfer control to
different executable basic blocks 410 depending on certain criteria.  For example, the last instruction in a basic block may correspond to an "if" condition that executes one basic block if the condition is evaluated to true and another basic block if
the condition is evaluated to false.  Therefore, the last instruction of the executable basic block 410 may include one or more exit pointers 450a, 455a, and so on.
<br/><br/> The exit pointer 450a points to another executable basic block 410b.  If a particular executable block that needs to be executed subsequent to the execution of the executable basic block 410a has not been compiled so as to generate a
corresponding executable basic block, the corresponding exit pointer 455a transfers control to the byte code compiler 230.  The byte code compiler 420 may be provided with information describing the subsequent basic block that needs to be compiled.  The
address of the subsequent basic block may be communicated to the byte code compiler 230 using function-calling conventions of the native machine in which the system is hosted.  In this embodiment, the byte code compiler 230 obtains the address of the
byte code corresponding to the subsequent basic block to be compiled from the top of the stack.  Once the byte code compiler 230 generates an executable basic block 410 corresponding to the subsequent basic block, the pointer 455a is changed to point to
the generated executable basic block instead of the byte code compiler 230.
<br/><br/> In at least some embodiments, the byte code compiler 230 generates different executable basic blocks for different combinations of type of the variables of a basic block.  That is, the byte code compiler 230 generates one executable basic block
for variable types integer, another executable basic block where both the variables are float, another executable basic block where one variable is integer and another is float and so on.
<br/><br/> Further, in at least some other embodiments, the executable basic blocks may be generated based on criterion other than type of variables in the basic block.  The guard code would have instructions accordingly to verify the criteria based on
which the executable block is created before the basic block body of the executable block is executed.
<br/><br/> FIG. 5 illustrates incremental compilation of byte code obtained from an example script code, in accordance with one embodiment of the disclosed technique.  FIG. 5 shows an example script code 500 executed in response to a request from client
device 160.  The example script code 500 includes a portion of byte code 510a followed by an if-then-else statement, followed by another portion of byte code 510d.  The if-then-else statement includes a condition 510e, a portion of byte code 510b that is
executed if condition 510e evaluates to true, and a portion of byte code 510c that is executed if the condition 510e evaluates to false.
<br/><br/> Assume that a request is received from a client 160 that includes values of variables that result in the condition 410e evaluating to true.  The resulting executable code generated by the byte code compiler 230 includes the executable code 550a
shown in FIG. 5.  The portion of script code 510a combined with the condition 510e corresponds to executable code 520a.  The executable code 520 includes a guard code 430 in the beginning to verify whether the types of the variables correspond to a
specific combination.  The end of the executable code 520a includes instructions evaluating the condition 510e.  If the condition 410e evaluates to true, the program control is transferred according to exit pointer 530a otherwise the program control is
transferred according to exit pointer 540a.
<br/><br/> Since the current request received from the client 160 results in the condition 410e evaluating to true, the executable basic block 520b corresponding to portion of script code 510b is also generated.  The script code 500 shows that after
execution of script code 510b, the script code 510d is executed.  Accordingly, the executable basic block 520d corresponding to the script code 510d is also generated.  For the execution of the current request, the script code 510c is never executed
since it corresponds to the "else" portion of the if-the-else statement that is not executed when the condition 510e evaluates to true.  Accordingly, the end of executable basic block 520a includes an exit pointer 540a pointing to the byte code compiler
230 with information identifying byte code corresponding to script code 510c.
<br/><br/> If several subsequent requests all include variables with types matching those corresponding to the previous request and result in condition 510e evaluating to true, the executable code 550a can be executed to process these requests.  A new set
of executable code 550 may be generated if a request is received that requires execution of script code 500 with a new combination of types of variables, different from those corresponding to executable code 550.  However, if all requests received from
the client device 160 continue providing the same combination of variable types and always result in the condition 510e evaluating to true, the executable code 550 continues to process the requests and no new executable code needs to be generated.
<br/><br/> If at any stage, an execution of the script code is performed that provides the previous combination of variable types that cause the condition 510e to evaluate to false, the exit pointer 540a causes the byte code compiler 230 to be invoked
causing an executable basic block to be generated corresponding to the script code 510c.  The script compiler 110 changes the exit pointer 540a to point to the generated executable basic block instead of the byte code compiler 230.  Since the execution
of the script code 510c is followed by the execution of the script code 510d, the exit pointer at the end of the executable basic block is configured to point to the executable block 520d corresponding to script code 510d.  The executable code 550a which
now includes executable block for script code 510c can process requests that result in the condition 510e evaluating to true as well as false without having to invoke the byte code compiler 230.  Furthermore, the executable basic block for script code
510c is not generated unless an execution that causes the condition 510e to evaluate to false is received.  Accordingly, the script compiler 110 generates executable code in a lazy fashion, the generation performed only if a request requires certain
portion of script code to be executed.  As a result, the script compiler 110 does not generate dead code, i.e., code that is never executed.
<br/><br/> In at least some embodiments, the execution of the script can be further optimized by generating a single executable control region for a set of basic blocks of the script.  The executable control region having instructions for executing a set
of basic blocks can be generated by combining the executable basic blocks generated for each of the set of basic blocks.  The execution engine 240 executes the executable control regions in subsequent requests to execute the executable blocks.  The time
taken to generate or load one executable control region per multiple basic blocks is lesser compared to the time taken to generate or load one executable block per each of the multiple basic blocks.  Accordingly, the efficiency of execution of the script
is improved by executing one executable control region instead of executable blocks.  However, to combine appropriate executable blocks, the byte code compiler 230 has to have knowledge or context of a set of executable blocks.  Since the executable
blocks are generated on a need basis, the execution engine 240 may not have the knowledge or context of a group of executable blocks.  Accordingly, the execution engine 240 may have to wait until necessary knowledge for further optimization is obtained.
<br/><br/> In at least some embodiments, the execution of the script code 500 is optimized using an intermediate representation (IR) of the script code.  Typically, a compiler, such as a byte code compiler 230, translates the script code first to some form
of IR and then convert the IR into machine code/executable code such as executable blocks of FIGS. 4 and 5.  The IR has intermediate code that represents the script code.  The IR includes a checkpoint that evaluates to a first value or a second value. 
While the checkpoint evaluates to the first value in most cases (fast path), it evaluates to the second value in lesser cases, which typically are error handling (slow path) cases.  The disclosed embodiments optimize the IR for fast path execution by
generating portions of the IR as atomic transactions.
<br/><br/> FIGS. 6-8 provide examples of generating an IR of a script code, and optimizing the IR based on an analysis of code for reference count of an object.  FIG. 6 illustrates an example environment 600 in which an embodiment of the disclosed
technique may operate.  The environment 600 includes an IR generation module 610 to generate an IR 615 of script code 605, and an executable code generation module 620 to generate an executable code 625 based on the IR 615.  The script code 605 and IR
615 can take various forms.  For example, the script code can be similar to script code 500, byte code as described in FIG. 2, or can include code written in programming languages other than PHP, such as Java, C++, etc. The IR 615 can be generated as a
byte code of FIG. 2, or in formats other than the byte code, or in any form between the script code 605 and executable code 625.  The executable code 625 is a code generated for a particular type of processor.  Further, the script code 605 can be
programmed to be executed in either a single threaded environment or a multi-threaded environment.
<br/><br/> In an embodiment, the environment 600 can be part of online system 100, and therefore, the script code 605 can be similar to script code 500 of FIG. 5, the IR 615 can be similar to the byte code described with reference to FIG. 2 or can be
generated from the byte code in a form between the byte code and the executable blocks of FIGS. 4 and 5, and the executable code 625 can include executable blocks such as executable basic blocks of FIGS. 4 and 5.
<br/><br/> The IR 615 includes code for tracking reference count of an object, that is, number of references, entities, or pointers pointing to an object allocated in the memory, code for checking data type of an object, etc. The reference count operations
include (a) "incref" code--code for incrementing a reference count of an object when a programming construct such as a variable refers to the object, and (b) an associated "decref" code--code for decrementing the reference count of the object when a
reference to the object is removed.
<br/><br/> Further, the decref code can trigger the execution of a user-defined code, such as a destructor, when the reference count of the object goes down to zero.  In an embodiment, the destructor is typically executed to perform certain user defined
operations when the object is deleted from the memory.  Executing the destructor can have adverse effects on execution of the code following the decref code that triggered the destructor.  Adverse effects include, for example, accessing of an object that
is deleted from the memory, changing of the data type of an object, etc. that can cause an error.  Accordingly, the execution of code following the decref code may be affected by such operations.
<br/><br/> Typically, in order to ensure these adverse effects are minimized, the IR 615 includes code for performing the necessary checks, such as whether an object is null or whether a data type of a variable is as expected, etc. at every portion in the
IR 615 where the object which could have been affected is accessed.  The checks include code for recovering from error and for resuming the execution of the code.  However, the amount of code generated for these checks is significant, which consumes
significant computing resources during execution.
<br/><br/> In an embodiment, the IR 615 is optimized to perform certain operations as atomic transactions.  Generating certain operations as atomic transactions eliminate the need to generate certain error checking and error handling code.
<br/><br/> FIG. 7 illustrates a block diagram of a system 700 to generate an optimized IR for a script code by generating a unit of intermediate code in the IR as a transaction, according to an embodiment of the disclosed technique.  In an embodiment, the
system 700 can be part of online system 100.  The system 700 includes an IR analysis module 705 that is configured to identify a unit of intermediate code in the IR 615 that can be generated as a transaction, and a transaction generation module 710 that
generates the transaction in an optimized IR 715.  The optimized IR 715 is further converted to the executable code 625 for execution.
<br/><br/> In a transaction, either all operations are executed or none is executed.  If any of the operations in the transaction fails or provides an undesirable result, such as an error, the transaction fails.  That is, the execution of the transaction
is aborted and a state of execution of the script code is reverted to a state prior to the beginning of the execution of the transaction.  In an embodiment, a computer program stores data in variables, which represent storage locations in the memory of
the computer.  The state of the program includes contents of these memory locations, at any given point in the program's execution.
<br/><br/> Additionally or alternatively, after aborting the transaction, the control can be transferred to either the beginning of the transaction or to any other specified portion of the IR 615.
<br/><br/> Generating a set of operations as a transaction also eliminates the need for generating error checking and error handling code because, in case of an error, the execution of the transaction is aborted and the execution of the script code is
recovered from an error automatically.  The execution of the script code is recovered from the error automatically since a state of execution of the script code is reverted to a state prior to the beginning of the execution of the transaction.
<br/><br/> One example of intermediate code of IR that can be generated as a transaction includes a unit of intermediate code having (a) a checkpoint and (b) the intermediate code associated with the checkpoint.  As described above, a checkpoint can
include conditions, operations, or other code that evaluate to one of two possible values that result in either a fast path execution or slow path execution of the script code.  Examples of checkpoint that can result in slow path or fast path execution
include a decref operation that decrements the reference count of an object.  The decref operation can evaluate to a zero or non-zero value.  In an embodiment, the decref operation evaluates to zero when the reference count of an object is decremented to
zero, which happens when the object is not being used anymore and is garbage collected.  Typically, the decref operation evaluates to a non-zero value more often than zero.
<br/><br/> Accordingly, IR analysis module 705 determines that the decref operation can be included in a transaction.  Further, the IR analysis module 705 also determines the intermediate code associated with the decref operation to be included in the
transaction.  The intermediate code associated with the decref operation can include any intermediate code that (a) can cause, directly or indirectly, the decref operation to evaluate to a particular value or (b) is affected or is dependent on the value
of the decref operation.  The IR analysis module 705 identifies the above decref operation and the associated intermediate code as an unit of intermediate code that can be generated as a transaction.
<br/><br/> In another example, a checkpoint also includes type verification code for checking whether the data type of an object is of an expected type.  The type verification code can evaluate to a true or false value.  In an embodiment, the type
verification code evaluates to true value, that is, the data type of an object is as expected, more often than it evaluates to false.  Accordingly, the IR analysis module 705 determines that the type verification code can be implemented as a transaction. Further, the IR analysis module 705 also identifies the intermediate code associated with the type verification code.  The type verification operation and the associated intermediate code forms an unit of intermediate code that can be generated as a
transaction.
<br/><br/> The transaction generation module 710 regenerates the identified unit of intermediate code as a transaction, and creates the optimized IR 715 including the transaction.  In an embodiment, generating the unit of intermediate code as a transaction
includes encapsulating the unit of intermediate code in a transaction instruction.  For instance, a transaction can be indicated using a begin and end statement, where, a beginning of the transaction is indicated by a "BEGIN TXN" instruction and an end
of the transaction is indicated by a "END TXN" instruction.  However, in other embodiments, the unit of intermediate code may be encapsulated in a transaction in other similar ways.  In at least some embodiments, the transaction can also identify a
portion of the code to which the control is transferred when the transaction aborts.  For example, the transaction can include a label in the begin transaction instruction--"BEGIN TXN [L]" that identifies the line of the optimized IR 715 to which the
control is transferred when the transaction aborts.  The label can be a number or alphanumeric.
<br/><br/> FIG. 8 illustrates an example of optimizing an IR 805 of a script code 605 by regenerating a portion of the IR having the decref operation as a transaction in the optimized IR 810, according to an embodiment of the disclosed technique.  The IR
805 can be generated using a system such as system 600, and optimized using a system such as system 700.  Consider that a portion of script code 605 includes a line of code for copying a value of one variable to another, such as "y=x." That is, a value
of variable x is copied to variable y. The variable x can be assigned to an object of any data type, including float, integer, array or a user-defined data type.  Typically, when a variable of a particular data type is initialized, the system allocates a
portion of the memory to an object "pointed to" or "referred by" the variable.  For example, when a variable x is assigned an object of a particular data type, the system allocates a portion of the memory to the object pointed to or referred by x. When
the value of variable x is copied to variable y, y also points to the object.  During the execution of the script code 605, the object assigned to a variable may be copied to various other variables, or the assignment to a particular variable may be
overwritten.  The number of pointers or references to the object may increase or decrease accordingly.
<br/><br/> The IR 805, in addition to other intermediate code, includes intermediate code representing the script code "y=x." The following describes the working of incref and decref code in the IR 805 for script code "y=x." The variable x is loaded into a
temporary variable t.sub.0.  Before variable y is overwritten with x, the current value or the object pointed to by y is stored in another temporary variable t.sub.2.  The reference count to the object pointed to by x is incremented since y also would
point to the object when x is loaded into y. Accordingly, an increment operation is performed on the most recent variable having the value of x, that is, t.sub.0.  The increment operation is assigned to a new variable t.sub.3.  Thus, code "t.sub.3=incref
t.sub.0" is generated, as shown in IR 805.  Finally, the value of x from t.sub.3 is stored into variable y. After y is overwritten with the value of x, the reference count of the object to which variable y pointing to before it was overwritten is
decremented.  That is, variable t.sub.2 is decremented.  Accordingly, "decref t.sub.2" operation 815 is generated.
<br/><br/> Further, since the decref operation 815 can trigger the execution of a destructor when the reference count of the object pointed to by t.sub.2 is decremented to zero and since executing the destructor has adverse effects such as causing null
pointer exception, the IR 805 also includes error checking and error handling code such as intermediate code 820 for handling the null pointer exception.
<br/><br/> The following describes an analysis of the IR 805 to identify the unit of intermediate code 830 that can be generated as a transaction.  The decref operation 815 decrements the reference count of the object pointed to by t.sub.2.  The reference
count of the object pointed to by t.sub.2 may result in a zero or non-zero value.  If the reference count is decremented to a non-zero value, there is no error and the script code 605 executes in fast path.  However, if the reference count is decremented
to zero, the object may be deleted from the memory and the destructor may be executed.  As described above, executing the destructor may have adverse effects, and therefore, can cause an error.  So, the decref operation 815 may put the execution of the
script code 605 into a slow path if it evaluates to zero.
<br/><br/> Accordingly, the IR analysis module 705 identifies the decref operation 815 as a potential checkpoint for optimization and indicates to the transaction generation module 710 to encapsulate the decref operation 815 in a transaction.  Further, the
IR analysis module 705 also identifies the intermediate code associated with the decref operation 815.  The intermediate code associated with the decref operation 815 includes any intermediate code that causes, directly or indirectly, the decref
operation 815 to evaluate to a zero or non-zero value and intermediate code that is dependent on the value of the decref operation 815.  For example, in the IR 805, the intermediate code associated with decref operation 815 includes intermediate code
identified by 830.  Thus, the IR analysis module 705 identifies the unit of intermediate code 830 to be generated as a transaction 835.
<br/><br/> The transaction generation module 710 encapsulates the identified unit of intermediate code 830 in the transaction 835, as shown in the optimized IR 810.  The transaction 835 is identified by a "BEGIN TXN [L]" instruction at the beginning of the
first line of unit of intermediate code 830 and an "END TXN" instruction after the last line of the unit of intermediate code 830.  Further, in the optimized IR 810, the error checking and error handling code 820 is not generated since the transaction
835 is executed atomically.  That is, the transaction 835 is executed only if all the instructions between the "BEGIN TXN [L]" and "END TXN" execute without error.  If an error, such as decref operation 815 evaluating to zero, occurs during execution of
any of the instructions between the "BEGIN TXN [L]" and "END TXN", the execution of transaction 835 is aborted.
<br/><br/> For example, in the IR 810, the transaction 835 is aborted if the decref operation evaluates to zero.  After the transaction aborts, a state of the script code 605 is reverted to a state before the beginning of execution of the transaction 835. 
All changes made to the variables, such as loading value of y into t.sub.2, incrementing t.sub.3, etc., are rolled back.  Additionally, when the transaction 835 is aborted, the execution is transferred to a portion of the IR 810 identified by the label
"[L]" in the "BEGIN TXN [L]" instruction.
<br/><br/> Another example of generating a transaction from the IR 805 includes generating the type verification code 825 and intermediate code associated with the type verification code 825 as a transaction.  As described above, one of the adverse effects
of executing the destructor includes changing the data type of an object.
<br/><br/> The script code 605 can include certain variables, referred to as boxed variables, that may be accessed in a way that is not directly represented in the script code 605.  Boxed variables are typically variables whose data type is guarded, that
is, variables whose data type is not expected to change.  For example, a global variable in the script code 605 having the same name as a local variable in a method can be a boxed variable.  The script code 605 may modify the global variable, either the
value or the data type, accidentally or intentionally, instead of the local variable.  Another example of boxed variables can include variables in the guard code of executable blocks such as executable basic block 410a of FIG. 4.  The executable blocks,
as described with reference to FIGS. 4 and 5, are executed based on the types of variables in the guard code 430.  If the variables are not of expected type, the execution is transferred to another executable basic block which has the variables of the
expected data type.  However, in certain cases, even after the variables are checked and the execution of executable block has begun, the data type of a boxed variable may change during the course of execution of the executable block.  The data type may
change due to, for example, an adverse effect of executing the destructor, which can be triggered by an operation such as a decref operation 815.
<br/><br/> Accordingly, when a boxed variable such as variable x is accessed after executing the decref operation 815 (for example, at "t.sub.5=ldloc x") the type verification code 825, "(if x.sub.t==str)," determines whether the data type of boxed
variable x is of a particular type, for example, string--a type when the variable was initially loaded at "t.sub.0=ldloc x".  The type verification code 825 can evaluate to true or false.  If the type verification code 825 evaluates to a true value (no
error), the variable x is loaded, and the script code 605 executes in fast path.  However, if the type verification code 825 evaluates to false (occurrence of an error), the script code 605 executes in slow path.
<br/><br/> Accordingly, the IR analysis module 705 identifies the type verification code 825 as a potential checkpoint that can be generated as a transaction.  The IR analysis module 705 also identifies the intermediate code associated with the type
verification code 825, for example, the instruction "t.sub.0=ldloc x" which loads value of x prior to executing the decref operation 815.  This instructions helps to identify the data type of x when it was first loaded.  Thus, the transaction generation
module 710 generates the type verification code 825 and the associated intermediate code as a transaction (not shown).  In an embodiment, the transaction for the type verification code 825 may be combined with transaction 835 (not shown).  In such a
case, the "BEGIN TXN [L]" instruction is generated prior to "t.sub.0=ldloc x" and the "END TXN" is generated after "t.sub.5=ldloc x" instruction in the optimized IR 810.  However, the error handling code beginning from "else" instruction is eliminated
from the combined transaction.
<br/><br/> During execution of the script code 605, as long as the type verification code evaluates to true, the transaction does not abort.  However, if the type verification code 825 evaluates to false, that is, data type of the boxed variable has
changed, the transaction aborts and the state is reverted to a state prior to the beginning of the execution of the transaction.
<br/><br/> FIG. 9 is a flow diagram illustrating a process 900 of optimizing an IR of script code for atomic execution, according to an embodiment of the disclosed technique.  The process 900 may be executed in a system such as online system 100 and/or
systems 600 and 700.  At step 905, the IR generation module 610 generates an IR for a script code, the IR including intermediate code that represents the script code.  In an embodiment, the IR includes operations such as (a) incref and decref
operations--for tracking a reference count of an object, (b) type verification code--for verifying a data type of an object, etc.
<br/><br/> At step 910, the IR analysis module 705 analyzes the IR 810 to identify a unit of intermediate code that includes (a) checkpoint that evaluates to a first value or a second value and (b) intermediate code associated with the checkpoint.  In at
least some embodiments, the checkpoint evaluates to the first value more often than it evaluates to the second value.  In at least some embodiments, the first value results in a fast path execution and the second value results in a slow path execution. 
In at least some embodiments, the intermediate code associated with the checkpoint includes any intermediate code that causes, directly or indirectly, the checkpoint to evaluate to a zero or non-zero value; and intermediate code that is dependent on the
value of the checkpoint.
<br/><br/> At step 915, the transaction generation module 710 regenerates the unit of intermediate code as a transaction.  Upon execution of the script code, occurrence of an error (checkpoint evaluating to the second value) causes (a) the transaction to
be aborted and (b) a current state of execution of the script code to revert to a state that existed before the beginning of execution of the unit of intermediate code.
<br/><br/> FIG. 10 is a flow diagram illustrating a process of executing the script code having transactions, according to an embodiment of the disclosed technique.  The process 1000 may be executed in a system such as online system 100.  At step 1005, the
execution engine 240 receives a request to execute a script code 605.  At step 1010, the execution engine 240 begins executing the script code 605 using the executable code 625 generated for the script code 605.
<br/><br/> At determination step 1015, the execution engine 240 determines whether the executable code 625 indicates a beginning of a transaction.  Responsive to a determination that the executable code 625 does not indicate a beginning of transaction, the
execution engine 240 continues executing the executable code.  On the other hand, responsive to a determination that the executable code 625 indicates a beginning of transaction, at step 1020, the execution engine 240 stores a current state of the script
code 605 into a memory of the system the executable code 625 is executing in. Typically, a computer program stores data in variables, which represent storage locations in the memory of the computer.  In an embodiment, a state of the program includes
contents of these memory locations, at any given point in the program's execution.  After storing the current state of the script code 605, at step 1025, the execution engine 240 continues with the execution of the transaction.
<br/><br/> At determination step 1030, the execution engine 240 determines whether a checkpoint in the transaction evaluate to a value indicating error.  The checkpoint evaluates to a first value or a second value.  In an embodiment, the first value
results in fast path execution and the second value results in slow path execution.  Generally, a checkpoint evaluates to the second value when an error occurs during execution.
<br/><br/> Responsive to a determination that the checkpoint did not evaluate to a value indicating error, at determination step 1050, the execution engine 240 determines whether the executable code 625 indicated an end of transaction.  If the executable
code 625 did not indicate an end of transaction, the execution engine 240 continues with executing the transaction.  On the other hand, if an end of transaction was detected, the execution engine 240 continues with executing the code following the
transaction.
<br/><br/> Referring back to determination step 1030, responsive to a determination that the checkpoint evaluated to an error value, at step 1035, the execution of the transaction is aborted.  At step 1040, the state of the execution of the script code 605
is restored to a state prior to the beginning of the transaction, which is the state stored at step 1020.  At step 1045, the execution of the script code is transferred to a portion of the code indicated by a label of the transaction.
<br/><br/> In an embodiment, the user may include certain user-defined code to be executed when a transaction aborts.  Such code may be generated at the portion of the code indicated by the label.
<br/><br/> The atomicity of a transaction in the above described embodiments may be achieved using software, hardware, or a combination of both.  In an embodiment, hardware such as a transactional memory can be used to provide support for executing
transactions.  A transactional memory allows a group of instructions to execute in an atomic way.
<br/><br/> FIG. 11 is a block diagram of an apparatus that may perform various operations, and store various information generated and/or used by such operations, according to an embodiment of the disclosed technique.  The apparatus can represent any
computer or processing system described herein.  The processing system 1100 is a hardware device on which any of the entities, components or services depicted in the examples of FIGS. 1-10 (and any other components described in this specification), such
as client device 160, online system 100, IR generation module 610, IR analysis module 705, transaction generation module 710, execution engine 625, etc. can be implemented.  The processing system 1100 includes one or more processors 1105 and memory 1110
coupled to an interconnect 1115.  The interconnect 1115 is shown in FIG. 11 as an abstraction that represents any one or more separate physical buses, point to point connections, or both connected by appropriate bridges, adapters, or controllers.  The
interconnect 1115, therefore, may include, for example, a system bus, a Peripheral Component Interconnect (PCI) bus or PCI-Express bus, a HyperTransport or industry standard architecture (ISA) bus, a small computer system interface (SCSI) bus, a
universal serial bus (USB), IIC (I2C) bus, or an Institute of Electrical and Electronics Engineers (IEEE) standard 1394 bus, also called "Firewire".
<br/><br/> The processor(s) 1105 is/are the central processing unit (CPU) of the processing system 1100 and, thus, control the overall operation of the processing system 1100.  In certain embodiments, the processor(s) 1105 accomplish this by executing
software or firmware stored in memory 1110.  The processor(s) 1105 may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific
integrated circuits (ASICs), programmable logic devices (PLDs), trusted platform modules (TPMs), or the like, or a combination of such devices.
<br/><br/> The memory 1110 is or includes the main memory of the processing system 1100.  The memory 1110 represents any form of random access memory (RAM), read-only memory (ROM), flash memory, or the like, or a combination of such devices.  Further, the
memory 1110 can also include a transactional memory that guarantees atomicity in executing transactions.  In use, the memory 1110 may contain a code.  In one embodiment, the code includes a general programming module configured to recognize the
general-purpose program received via the computer bus interface, and prepare the general-purpose program for execution at the processor.  In another embodiment, the general programming module may be implemented using hardware circuitry such as ASICs,
PLDs, or field-programmable gate arrays (FPGAs).
<br/><br/> Also connected to the processor(s) 1105 through the interconnect 1115 are a network adapter 1130, a storage device(s) 1120 and I/O device(s) 1125.  The network adapter 1130 provides the processing system 1100 with the ability to communicate with
remote devices, over a network and may be, for example, an Ethernet adapter or Fibre Channel adapter.  The network adapter 1130 may also provide the processing system 1100 with the ability to communicate with other computers within the cluster.  In some
embodiments, the processing system 1100 may use more than one network adapter to deal with the communications within and outside of the cluster separately.
<br/><br/> The I/O device(s) 1125 can include, for example, a keyboard, a mouse or other pointing device, disk drives, printers, a scanner, and other input and/or output devices, including a display device.  The display device can include, for example, a
cathode ray tube (CRT), liquid crystal display (LCD), or some other applicable known or convenient display device.
<br/><br/> The code stored in memory 1110 can be implemented as software and/or firmware to program the processor(s) 1105 to carry out actions described above.  In certain embodiments, such software or firmware may be initially provided to the processing
system 1100 by downloading it from a remote system through the processing system 1100 (e.g., via network adapter 1130).
<br/><br/> The techniques introduced herein can be implemented by, for example, programmable circuitry (e.g., one or more microprocessors) programmed with software and/or firmware, or entirely in special-purpose hardwired (non-programmable) circuitry, or
in a combination of such forms.  Special-purpose hardwired circuitry may be in the form of, for example, one or more ASICs, PLDs, FPGAs, etc.
<br/><br/> Software or firmware for use in implementing the techniques introduced here may be stored on a machine-readable storage medium and may be executed by one or more general-purpose or special-purpose programmable microprocessors.  A
"machine-readable storage medium", as the term is used herein, includes any mechanism that can store information in a form accessible by a machine.
<br/><br/> A machine can also be a server computer, a client computer, a personal computer (PC), a tablet PC, a laptop computer, a set-top box (STB), a personal digital assistant (PDA), a cellular telephone, an iPhone, a Blackberry, a processor, a
telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine.
<br/><br/> A machine-accessible storage medium or a storage device(s) 1120 includes, for example, recordable/non-recordable media (e.g., ROM; RAM; magnetic disk storage media; optical storage media; flash memory devices; etc.), etc., or any combination
thereof.  The storage medium typically may be non-transitory or include a non-transitory device.  In this context, a non-transitory storage medium may include a device that is tangible, meaning that the device has a concrete physical form, although the
device may change its physical state.  Thus, for example, non-transitory refers to a device remaining tangible despite this change in state.
<br/><br/> The term "logic", as used herein, can include, for example, programmable circuitry programmed with specific software and/or firmware, special-purpose hardwired circuitry, or a combination thereof.
<br/><br/><center><b>* * * * *</b></center>
<hr/>
   <center>
   <a href="http://pdfpiw.uspto.gov/.piw?Docid=09317265&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D785%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3Dfacebook%2526p%3D16%2526OS%3Dfacebook%2526RS%3Dfacebook&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=NONE&amp;Input=View+first+page"><img alt="[Image]" border="0" src="/netaicon/PTO/image.gif" valign="middle"/></a>
   <table>
   <tbody><tr><td align="center"><a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D785%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D16%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209317265"><img alt="[View Shopping Cart]" border="0" src="/netaicon/PTO/cart.gif" valign="middle"/></a>
   <a href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=9317265&amp;backUrl1=http%3A//patft.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D785%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3Dfacebook%26p%3D16%26OS%3Dfacebook&amp;backLabel1=Back%20to%20Document%3A%209317265">
   <img alt="[Add to Shopping Cart]" border="0" src="/netaicon/PTO/order.gif" valign="middle"/></a>
   </td></tr>
   <tr><td align="center">
     <a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=785&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=15&amp;Query=facebook"><img alt="[PREV_LIST]" border="0" src="/netaicon/PTO/prevlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=785&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;Query=facebook"><img alt="[HIT_LIST]" border="0" src="/netaicon/PTO/hitlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=785&amp;f=S&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=17&amp;Query=facebook"><img alt="[NEXT_LIST]" border="0" src="/netaicon/PTO/nextlist.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=784&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;OS=facebook"><img alt="[PREV_DOC]" border="0" src="/netaicon/PTO/prevdoc.gif" valign="MIDDLE"/></a>
<a href="/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&amp;r=786&amp;f=G&amp;l=50&amp;d=PTXT&amp;s1=facebook&amp;p=16&amp;OS=facebook"><img alt="[NEXT_DOC]" border="0" src="/netaicon/PTO/nextdoc.gif" valign="MIDDLE"/></a>

   <a href="#top"><img alt="[Top]" border="0" src="/netaicon/PTO/top.gif" valign="middle"/></a>
   </td></tr>
   </tbody></table>
   <a name="bottom"></a>
   <a href="/netahtml/PTO/index.html"><img alt="[Home]" border="0" src="/netaicon/PTO/home.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-bool.html"><img alt="[Boolean Search]" border="0" src="/netaicon/PTO/boolean.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/search-adv.htm"><img alt="[Manual Search]" border="0" src="/netaicon/PTO/manual.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/srchnum.htm"><img alt="[Number Search]" border="0" src="/netaicon/PTO/number.gif" valign="middle"/></a>
   <a href="/netahtml/PTO/help/help.htm"><img alt="[Help]" border="0" src="/netaicon/PTO/help.gif" valign="middle"/></a>
   </center>

</coma></body></html>